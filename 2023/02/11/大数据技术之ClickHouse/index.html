<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>大数据技术之ClickHouse | 一只散漫的猫</title><meta name="author" content="jiangnan"><meta name="copyright" content="jiangnan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="大数据技术之 ClickHouse第一部分 入门篇第 1 章 ClickHouse 入门ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的列式存储数据库（DBMS），使用 C++ 语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析数据报告。 1.1 ClickHouse 的特点1.1.1 列式存储以下面的表为例：    Id Name Age">
<meta property="og:type" content="article">
<meta property="og:title" content="大数据技术之ClickHouse">
<meta property="og:url" content="http://peninsula1.gitee.io/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/index.html">
<meta property="og:site_name" content="一只散漫的猫">
<meta property="og:description" content="大数据技术之 ClickHouse第一部分 入门篇第 1 章 ClickHouse 入门ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的列式存储数据库（DBMS），使用 C++ 语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析数据报告。 1.1 ClickHouse 的特点1.1.1 列式存储以下面的表为例：    Id Name Age">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-02-11T03:00:57.000Z">
<meta property="article:modified_time" content="2023-02-18T13:14:28.206Z">
<meta property="article:author" content="jiangnan">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://peninsula1.gitee.io/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '大数据技术之ClickHouse',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-18 21:14:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="一只散漫的猫"><span class="site-name">一只散漫的猫</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">大数据技术之ClickHouse</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-11T03:00:57.000Z" title="Created 2023-02-11 11:00:57">2023-02-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-18T13:14:28.206Z" title="Updated 2023-02-18 21:14:28">2023-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="大数据技术之ClickHouse"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="大数据技术之-ClickHouse"><a href="#大数据技术之-ClickHouse" class="headerlink" title="大数据技术之 ClickHouse"></a>大数据技术之 ClickHouse</h1><h1 id="第一部分-入门篇"><a href="#第一部分-入门篇" class="headerlink" title="第一部分 入门篇"></a>第一部分 入门篇</h1><h2 id="第-1-章-ClickHouse-入门"><a href="#第-1-章-ClickHouse-入门" class="headerlink" title="第 1 章 ClickHouse 入门"></a>第 1 章 ClickHouse 入门</h2><p>ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的<strong>列式存储数据库</strong>（DBMS），使用 C++ 语言编写，主要用于<strong>在线分析处理查询（OLAP）</strong>，能够使用 SQL 查询实时生成分析数据报告。</p>
<h3 id="1-1-ClickHouse-的特点"><a href="#1-1-ClickHouse-的特点" class="headerlink" title="1.1 ClickHouse 的特点"></a>1.1 ClickHouse 的特点</h3><h4 id="1-1-1-列式存储"><a href="#1-1-1-列式存储" class="headerlink" title="1.1.1 列式存储"></a>1.1.1 列式存储</h4><p>以下面的表为例：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>22</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>34</td>
</tr>
</tbody></table>
<p><strong>1）采用行式存储时，数据在磁盘上的组织结构为：</strong></p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906230720766.png" alt="image-20220906230720766"> </p>
<p>好处是想查某个人所有的属性时，可以通过一次磁盘查找加顺序读取就可以。但是当想查所有人的年龄时，需要不停的查找，或者全表扫描才行，遍历的很多数据都是不需要的。</p>
<p><strong>2）采用列式存储时，数据在磁盘上的组织结构为：</strong></p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906231304721.png" alt="image-20220906231304721"> </p>
<p>这时想查所有人的年龄只需把年龄那一列拿出来就可以了</p>
<p><strong>3）列式储存的好处：</strong></p>
<ul>
<li>对于列的聚合，计数，求和等统计操作优于行式存储。</li>
<li>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列选择更优的数据压缩算法，大大提高了数据的压缩比重。</li>
<li>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的发挥空间。</li>
</ul>
<h4 id="1-1-2-DBMS-的功能"><a href="#1-1-2-DBMS-的功能" class="headerlink" title="1.1.2 DBMS 的功能"></a>1.1.2 DBMS 的功能</h4><p>几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管理及权限管理，数据的备份与恢复。 </p>
<h4 id="1-1-3-多样化引擎"><a href="#1-1-3-多样化引擎" class="headerlink" title="1.1.3 多样化引擎"></a>1.1.3 多样化引擎</h4><p>ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎。</p>
<h4 id="1-1-4-高吞吐写入能力"><a href="#1-1-4-高吞吐写入能力" class="headerlink" title="1.1.4 高吞吐写入能力"></a>1.1.4 高吞吐写入能力</h4><p>ClickHouse 采用类 <strong>LSM Tree</strong> 的结构，数据写入后定期在后台 Compaction。通过类 LSM tree 的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台 compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。</p>
<p>官方公开 benchmark 测试显示能够达到 50MB-200MB&#x2F;s 的写入吞吐能力，按照每行100Byte 估算，大约相当于 50W-200W 条&#x2F;s 的写入速度。</p>
<h4 id="1-1-5-数据分区与线程级并行"><a href="#1-1-5-数据分区与线程级并行" class="headerlink" title="1.1.5 数据分区与线程级并行"></a>1.1.5 数据分区与线程级并行</h4><p>ClickHouse 将数据划分为多个 partition，每个 partition 再进一步划分为多个 index granularity(索引粒度)，然后通过多个 CPU 核心分别处理其中的一部分来实现并行数据处理。在这种设计下，<strong>单条 Query 就能利用整机所有 CPU。</strong>极致的并行处理能力，极大的降低了查询延时。</p>
<p>所以，ClickHouse 即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端就是对于单条查询使用较多 cpu，就不利于同时并发多条查询。所以对于高 qps 的查询业务，ClickHouse 并不是强项。</p>
<h4 id="1-1-6-性能对比"><a href="#1-1-6-性能对比" class="headerlink" title="1.1.6 性能对比"></a>1.1.6 性能对比</h4><p><strong>1）单表查询</strong></p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906232235037.png" alt="image-20220906232235037"> </p>
<p><strong>2）关联查询</strong></p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906232310852.png" alt="image-20220906232310852"> </p>
<p>结论: ClickHouse 像很多 OLAP 数据库一样，单表查询速度优于关联查询，而且 ClickHouse 的两者差距更为明显。</p>
<h2 id="第-2-章-ClickHouse-的安装"><a href="#第-2-章-ClickHouse-的安装" class="headerlink" title="第 2 章 ClickHouse 的安装"></a>第 2 章 ClickHouse 的安装</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-确定防火墙处于关闭状态"><a href="#2-1-1-确定防火墙处于关闭状态" class="headerlink" title="2.1.1 确定防火墙处于关闭状态"></a>2.1.1 确定防火墙处于关闭状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：生产环境不建议关闭</p>
</blockquote>
<h4 id="2-1-2-CentOS-取消打开文件数限制"><a href="#2-1-2-CentOS-取消打开文件数限制" class="headerlink" title="2.1.2 CentOS 取消打开文件数限制"></a>2.1.2 CentOS 取消打开文件数限制</h4><p>（1）查看文件数限制</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906234741765.png" alt="image-20220906234741765"> </p>
<p>（2）在 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件的末尾加入以下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">soft指当前数值，hard指最大数值</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure>

<p>（3）在 &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nproc.conf 文件的末尾加入以下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure>

<p>（4）在 &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nofile.conf 文件的末尾加入以下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure>

<p>（5）重新登录即可生效</p>
<h4 id="2-1-3-安装依赖"><a href="#2-1-3-安装依赖" class="headerlink" title="2.1.3 安装依赖"></a>2.1.3 安装依赖</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y libtool</span><br><span class="line">sudo yum install -y *unixODBC*</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-CentOS-取消-SELINUX"><a href="#2-1-4-CentOS-取消-SELINUX" class="headerlink" title="2.1.4 CentOS 取消 SELINUX"></a>2.1.4 CentOS 取消 SELINUX</h4><p>（1）修改&#x2F;etc&#x2F;selinux&#x2F;config 中的 SELINUX&#x3D;disabled</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>（2）临时关闭 SELINUX</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看SELINUX状态</span></span><br><span class="line">getenforce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭SELINUX</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-单机安装"><a href="#2-2-单机安装" class="headerlink" title="2.2 单机安装"></a>2.2 单机安装</h3><p>官方网址：<a target="_blank" rel="noopener" href="https://clickhouse.com/">https://clickhouse.com/</a></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://packages.clickhouse.com/rpm/stable/">https://packages.clickhouse.com/rpm/stable/</a></p>
<h4 id="2-2-1-在-x2F-opt-x2F-software-下创建-clickhouse-目录"><a href="#2-2-1-在-x2F-opt-x2F-software-下创建-clickhouse-目录" class="headerlink" title="2.2.1 在 &#x2F;opt&#x2F;software 下创建 clickhouse 目录"></a>2.2.1 在 &#x2F;opt&#x2F;software 下创建 clickhouse 目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software/</span><br><span class="line">mkdir clickhouse</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-将-ClickHouse-安装文件上传到-clickhouse-目录下"><a href="#2-2-2-将-ClickHouse-安装文件上传到-clickhouse-目录下" class="headerlink" title="2.2.2 将 ClickHouse 安装文件上传到 clickhouse 目录下"></a>2.2.2 将 ClickHouse 安装文件上传到 clickhouse 目录下</h4><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220907010745802.png" alt="image-20220907010745802"> </p>
<h4 id="2-2-3-安装"><a href="#2-2-3-安装" class="headerlink" title="2.2.3 安装"></a>2.2.3 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">sudo rpm -ivh *.rpm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看安装情况</span></span><br><span class="line">sudo rpm -qa|grep clickhouse</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-修改配置文件"><a href="#2-2-4-修改配置文件" class="headerlink" title="2.2.4 修改配置文件"></a>2.2.4 修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/clickhouse-server/config.xml</span><br></pre></td></tr></table></figure>

<p>（1）把 <strong><listen_host>::</listen_host></strong> 的注释打开，这样的话才能让 ClickHouse 被除本机以外的服务器访问</p>
<blockquote>
<p>注意：生产环境可以配置指定的IP进行访问</p>
</blockquote>
<p>（2）默认的路径配置</p>
<p>数据文件路径：<code>&lt;path&gt;/&lt;/path&gt;</code></p>
<p>日志文件路径：<code>&lt;log&gt;/var/log/clickhouse-server/clickhouse-server.log&lt;/log&gt;</code></p>
<h4 id="2-2-5-启动-Server"><a href="#2-2-5-启动-Server" class="headerlink" title="2.2.5 启动 Server"></a>2.2.5 启动 Server</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start clickhouse-server</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-关闭开机自启（可选）"><a href="#2-2-6-关闭开机自启（可选）" class="headerlink" title="2.2.6 关闭开机自启（可选）"></a>2.2.6 关闭开机自启（可选）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable clickhouse-server</span><br></pre></td></tr></table></figure>

<h4 id="2-2-7-使用-client-连接-server"><a href="#2-2-7-使用-client-连接-server" class="headerlink" title="2.2.7 使用 client 连接 server"></a><strong>2.2.7</strong> <strong>使用</strong> <strong>client</strong> <strong>连接</strong> <strong>server</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client -m [--password]</span><br></pre></td></tr></table></figure>

<h2 id="第-3-章-数据类型"><a href="#第-3-章-数据类型" class="headerlink" title="第 3 章 数据类型"></a><strong>第</strong> <strong>3</strong> <strong>章 数据类型</strong></h2><h3 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a><strong>3.1</strong> <strong>整型</strong></h3><p>固定长度的整型，包括有符号整型或无符号整型。</p>
<p>整型范围（-2n-1~2n-1-1）：</p>
<p>Int8 - [-128 : 127]</p>
<p>Int16 - [-32768 : 32767]</p>
<p>Int32 - [-2147483648 : 2147483647]</p>
<p>Int64 - [-9223372036854775808 : 9223372036854775807]</p>
<p>无符号整型范围（0~2n-1）：</p>
<p>UInt8 - [0 : 255]</p>
<p>UInt16 - [0 : 65535]</p>
<p>UInt32 - [0 : 4294967295]</p>
<p>UInt64 - [0 : 18446744073709551615]</p>
<h3 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a><strong>3.2</strong> <strong>浮点型</strong></h3><p>Float32 - float</p>
<p>Float64 – double</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908212753988.png" alt="image-20220908212753988"> </p>
<blockquote>
<p>注意：浮点型在进行计算时可能会引起四舍五入的误差。</p>
</blockquote>
<h3 id="3-3-布尔型"><a href="#3-3-布尔型" class="headerlink" title="3.3 布尔型"></a><strong>3.3</strong> <strong>布尔型</strong></h3><p>没有单独的类型来存储布尔值。可以使用 UInt8 类型，取值限制为 0 或 1。</p>
<h3 id="3-4-Decimal-型"><a href="#3-4-Decimal-型" class="headerlink" title="3.4 Decimal 型"></a><strong>3.4 Decimal</strong> <strong>型</strong></h3><p>有符号的浮点数，可在加、减和乘法运算过程中保持精度。对于除法，最低有效数字会被丢弃（不舍入）。</p>
<p>有三种声明：</p>
<ul>
<li>Decimal32(s)，相当于 Decimal(9-s, s)，有效位数为 1~9</li>
<li>Decimal64(s)，相当于 Decimal(18-s, s)，有效位数为 1~18</li>
<li>Decimal128(s)，相当于 Decimal(38-s, s)，有效位数为 1~38</li>
</ul>
<p><strong>s 标识小数位</strong></p>
<h3 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a><strong>3.5</strong> <strong>字符串</strong></h3><p><strong>1）String</strong></p>
<p>字符串可以任意长度的。它可以包含任意的字节集，包含空字节。</p>
<p><strong>2）FixedString(N)</strong></p>
<p>固定长度 N 的字符串，N 必须是严格的正自然数。当服务端读取长度小于 N 的字符串时候，通过在字符串末尾添加空字节来达到 N 字节长度。 当服务端读取长度大于 N 的字符串时候，将返回错误消息。</p>
<p>与 String 相比，极少会使用 FixedString，因为使用起来不是很方便。</p>
<h3 id="3-6-枚举类型"><a href="#3-6-枚举类型" class="headerlink" title="3.6 枚举类型"></a><strong>3.6</strong> <strong>枚举类型</strong></h3><p>包括 Enum8 和 Enum16 类型。Enum 保存 ‘string’&#x3D; integer 的对应关系。</p>
<p>Enum8 用 ‘String’&#x3D; Int8 对描述。</p>
<p>Enum16 用 ‘String’&#x3D; Int16 对描述。</p>
<p><strong>1）用法演示</strong></p>
<p>创建一个带有一个枚举 Enum8(‘hello’ &#x3D; 1, ‘world’ &#x3D; 2) 类型的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_enum</span><br><span class="line">(</span><br><span class="line">    `x` Enum8(<span class="string">&#x27;hello&#x27;</span> <span class="operator">=</span> <span class="number">1</span>, <span class="string">&#x27;world&#x27;</span> <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> TinyLog;</span><br></pre></td></tr></table></figure>

<p><strong>2）这个 x 列只能存储类型定义中列出的值：’hello’或’world’</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_enum <span class="keyword">VALUES</span> (<span class="string">&#x27;hello&#x27;</span>), (<span class="string">&#x27;world&#x27;</span>), (<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908213812152.png" alt="image-20220908213812152"> </p>
<p><strong>3）如果尝试保存任何其他值，ClickHouse 抛出异常</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_enum <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214102455.png" alt="image-20220908214102455"> </p>
<p><strong>4）如果需要看到对应行的数值，则必须将 Enum 值转换为整数类型</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(x, <span class="string">&#x27;Int8&#x27;</span>) <span class="keyword">FROM</span> t_enum;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214245932.png" alt="image-20220908214245932"> </p>
<h3 id="3-7-时间类型"><a href="#3-7-时间类型" class="headerlink" title="3.7 时间类型"></a><strong>3.7</strong> <strong>时间类型</strong></h3><p>目前 ClickHouse 有三种时间类型</p>
<ul>
<li>Date 接受<strong>年-月-日</strong>的字符串比如 ‘2019-12-16’</li>
<li>Datetime 接受<strong>年-月-日 时:分:秒</strong>的字符串比如 ‘2019-12-16 20:50:10’ </li>
<li>Datetime64 接受<strong>年-月-日 时:分:秒.亚秒</strong>的字符串比如 ‘2019-12-16 20:50:10.66’</li>
</ul>
<p>日期类型，用两个字节存储，表示从 1970-01-01 (无符号) 到当前的日期值。</p>
<h3 id="3-8-数组"><a href="#3-8-数组" class="headerlink" title="3.8 数组"></a><strong>3.8</strong> <strong>数组</strong></h3><p><strong>Array(T)：</strong>由 T 类型元素组成的数组。</p>
<p>T 可以是任意类型，包含数组类型。但不推荐使用多维数组，ClickHouse 对多维数组的支持有限。例如，不能在 MergeTree 表中存储多维数组。</p>
<p>（1）创建数组方式 1，使用 array 函数</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214714506.png" alt="image-20220908214714506"> </p>
<p>（2）创建数组方式 2：使用方括号</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214753599.png" alt="image-20220908214753599"> </p>
<h2 id="第-4-章-表引擎"><a href="#第-4-章-表引擎" class="headerlink" title="第 4 章 表引擎"></a><strong>第</strong> <strong>4</strong> <strong>章 表引擎</strong></h2><h3 id="4-1-表引擎的使用"><a href="#4-1-表引擎的使用" class="headerlink" title="4.1 表引擎的使用"></a><strong>4.1</strong> <strong>表引擎的使用</strong></h3><p>表引擎是 ClickHouse 的一大特色。可以说，表引擎决定了如何存储表的数据。包括：</p>
<ul>
<li>数据的存储方式和位置，写到哪里以及从哪里读取数据。</li>
<li>支持哪些查询以及如何支持。</li>
<li>并发数据访问。</li>
<li>索引的使用（如果存在）。</li>
<li>是否可以执行多线程请求。</li>
<li>数据复制参数。</li>
</ul>
<p>表引擎的使用方式就是必须显式在创建表时定义该表使用的引擎，以及引擎使用的相关参数。</p>
<blockquote>
<p>特别注意：引擎的名称大小写敏感</p>
</blockquote>
<h3 id="4-2-TinyLog"><a href="#4-2-TinyLog" class="headerlink" title="4.2 TinyLog"></a><strong>4.2 TinyLog</strong></h3><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表，生产环境上作用有限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_tinylog</span><br><span class="line">(</span><br><span class="line">    `id` String,</span><br><span class="line">    `name` String</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> TinyLog;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Memory"><a href="#4-3-Memory" class="headerlink" title="4.3 Memory"></a><strong>4.3 Memory</strong></h3><p>内存引擎，数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失。读写操作不会相互阻塞，不支持索引。简单查询下有非常非常高的性能表现（<strong>超过 10G&#x2F;s</strong>）。</p>
<h3 id="4-4-MergeTree"><a href="#4-4-MergeTree" class="headerlink" title="4.4 MergeTree"></a><strong>4.4 MergeTree</strong></h3><p>ClickHouse 中<strong>最强大的表引擎</strong>当属 MergeTree（合并树）引擎及该系列（*MergeTree）中的其他引擎，<strong>支持索引和分区</strong>，地位可以相当于 innodb 之于 Mysql。</p>
<p><strong>1）建表语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p><strong>2）插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">12000.00</span>,<span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>MergeTree 其实还有很多参数(绝大多数用默认值即可)，但是这三个参数是更加重要的，也涉及了关于 MergeTree 的很多概念。</p>
<h4 id="4-4-1-partition-by-分区-可选"><a href="#4-4-1-partition-by-分区-可选" class="headerlink" title="4.4.1 partition by 分区(可选)"></a><strong>4.4.1 partition by</strong> <strong>分区(可选)</strong></h4><p><strong>1）作用</strong></p>
<p>分区的目的主要是降低扫描的范围，优化查询速度</p>
<p><strong>2）如果不填</strong></p>
<p>只会使用一个分区。</p>
<p><strong>3）分区目录</strong></p>
<p>MergeTree 是以列文件+索引文件+表定义文件组成的，但是如果设定了分区那么这些文件就会保存到不同的分区目录中。</p>
<p>分区目录文件命名规则：PartitionId_MinBlockNum_MaxBlockNum_Level（分区值_最小分区_最大分区块编号_合并层级）</p>
<ul>
<li>PartitionId：<ul>
<li>数据分区 ID 生成规则</li>
<li>数据分区规则由分区 ID 决定，分区ID由 PARTITION BY 分区键决定。根据分区键字段类型，ID生成规则可以分为：<ul>
<li>未定义分区键：没有定义 PARTITION BY ，默认生成一个目录名为 all 的数据分区，所有数据均存放在 all 目录下。</li>
<li>整型分区键：分区键为整型，那么直接用该整型值的字符串形式作为分区ID。</li>
<li>日期类分区键：分区键为日期类型，或者可以转化成日期类型。</li>
<li>其他类型分区键：String、Float 类型等，通过128位的 Hash 算法取其 Hash 值作为分区ID。</li>
</ul>
</li>
</ul>
</li>
<li>MinBlockNum：最小分区块编号，自增类型，从1开始向上递增。每产生一个新的目录分区就向上递增一个数字。</li>
<li>MaxBlockNum：最大分区块编号，新创建的分区 MinBlockNum 等于 MaxBlockNum 的编号。</li>
<li>Level：合并的层级，被合并的次数。合并次数越多，层级值越大。</li>
</ul>
<p><strong>4）并行</strong></p>
<p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p>
<p><strong>5）数据写入与分区合并</strong></p>
<p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作（等不及也可以手动通过 optimize 执行），把临时分区的数据，合并到已有分区中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> xxxx <span class="keyword">FINAL</span>;</span><br><span class="line"># 只针对某一个分区做合并操作</span><br><span class="line">OPTIMIZE <span class="keyword">TABLE</span> xxxx <span class="keyword">PARTITION</span> <span class="string">&#x27;yyyy&#x27;</span> <span class="keyword">FINAL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-primary-key-主键-可选"><a href="#4-4-2-primary-key-主键-可选" class="headerlink" title="4.4.2 primary key 主键(可选)"></a>4.4.2 primary key 主键(可选)</h4><p>ClickHouse 中的主键，和其他数据库不太一样，<strong>它只提供了数据的一级索引，但是却不是唯一约束。</strong>这就意味着是可以存在相同 primary key 的数据的。</p>
<p>主键的设定主要依据是查询语句中的 where 条件。</p>
<p>根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity，避免了全表扫描。</p>
<p>index granularity：直接翻译的话就是索引粒度，指在<strong>稀疏索引</strong>中两个相邻索引对应数据的间隔。ClickHouse 中的 MergeTree 默认是 8192。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p>
<p><strong>稀疏索引：</strong></p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908224603867.png" alt="image-20220908224603867"> </p>
<p>稀疏索引的好处就是可以用很少的索引数据，定位更多的数据，代价就是只能定位到索引粒度的第一行，然后再进行进行一点扫描。</p>
<h4 id="4-4-3-order-by（必选）"><a href="#4-4-3-order-by（必选）" class="headerlink" title="4.4.3 order by（必选）"></a><strong>4.4.3 order by（必选）</strong></h4><p>order by 设定了<strong>分区内</strong>的数据按照哪些字段顺序进行有序保存。</p>
<p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不设置主键的情况，很多处理会依照 order by 的字段进行处理。</p>
<p><strong>要求：主键必须是 order by 字段的前缀字段。</strong></p>
<p>比如 order by 字段是 (id, sku_id) 那么主键必须是 id 或者(id, sku_id)</p>
<h4 id="4-4-4-二级索引"><a href="#4-4-4-二级索引" class="headerlink" title="4.4.4 二级索引"></a><strong>4.4.4</strong> <strong>二级索引</strong></h4><p>目前在 ClickHouse 的官网上二级索引的功能在 <strong>v20.1.2.4</strong> 之前是被标注为实验性的，在这个版本之后默认是开启的。 </p>
<p><strong>1）老版本使用二级索引前需要增加设置</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set allow_experimental_data_skipping_indices=1;</span><br></pre></td></tr></table></figure>

<p><strong>2）创建测试表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime,</span><br><span class="line">    INDEX a total_amount TYPE minmax GRANULARITY <span class="number">5</span></span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>其中 GRANULARITY N 是设定二级索引对于一级索引粒度的粒度。</p>
<p><strong>3）插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt2 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_004&#x27;</span>, <span class="number">2500.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">12000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">600.00</span>, <span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>4）对比效果</strong></p>
<p>使用下面语句进行测试，可以看出二级索引能够为非主键字段的查询发挥作用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --send_logs_level=trace &lt;&lt;&lt; &#x27;select * from t_order_mt2 where total_amount &gt; toDecimal32(900., 2)&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-5-数据-TTL"><a href="#4-4-5-数据-TTL" class="headerlink" title="4.4.5 数据 TTL"></a>4.4.5 数据 TTL</h4><p>TTL 即 Time To Live，MergeTree 提供了可以管理数据表或者列的<strong>生命周期</strong>的功能。</p>
<p><strong>1）列级别 TTL</strong></p>
<p>（1）创建测试表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt3</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>) TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>,</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>（2）插入数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt3 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">106</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, NOW()),</span><br><span class="line">(<span class="number">107</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, NOW()),</span><br><span class="line">(<span class="number">110</span>, <span class="string">&#x27;sku_003&#x27;</span>, <span class="number">600.00</span>, NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>);</span><br></pre></td></tr></table></figure>

<p>（3）<strong>手动合并</strong>，查看效果，到期后，指定的字段数据将变为默认值</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909002325459.png" alt="image-20220909002325459"> </p>
<blockquote>
<p>官方文档：When the values in the column expire, ClickHouse replaces them with the default values for the column data type. If all the column values in the data part expire, ClickHouse deletes this column from the data part in a filesystem.</p>
<p>但是实际测试下来，每个分区的最新的一条或多条数据不会被删除，原因未知。</p>
</blockquote>
<p><strong>2）表级 TTL</strong></p>
<p>下面的这条语句是数据会在 create_time 之后 10 秒丢失</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_mt3 MODIFY TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>;</span><br></pre></td></tr></table></figure>

<p>涉及判断的字段必须是 Date 或者 Datetime 类型，推荐使用分区的日期字段。</p>
<p>能够使用的时间周期：</p>
<ul>
<li>SECOND</li>
<li>MINUTE</li>
<li>HOUR</li>
<li>DAY</li>
<li>WEEK</li>
<li>MONTH</li>
<li>QUARTER</li>
<li>YEAR</li>
</ul>
<h3 id="4-5-ReplacingMergeTree"><a href="#4-5-ReplacingMergeTree" class="headerlink" title="4.5 ReplacingMergeTree"></a>4.5 ReplacingMergeTree</h3><p>ReplacingMergeTree 是 MergeTree 的一个变种，它存储特性完全继承 MergeTree，只是多了一个去重的功能。 尽管 MergeTree 可以设置主键，但是 primary key 其实没有唯一约束的功能。如果你想处理掉重复的数据，可以借助这个 ReplacingMergeTree。</p>
<p><strong>1）去重时机</strong></p>
<p><strong>数据的去重只会在合并的过程中出现。</strong>合并会在未知的时间在后台进行，所以你无法预先作出计划。有一些数据可能仍未被处理。</p>
<p><strong>2）去重范围</strong></p>
<p><strong>如果表经过了分区，去重只会在分区内部进行去重，不能执行跨分区的去重。</strong></p>
<p>所以 ReplacingMergeTree 能力有限， ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</p>
<p><strong>3）案例演示</strong></p>
<p>（1）创建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rmt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p><strong>ReplacingMergeTree() 填入的参数为版本字段，重复数据保留版本字段值最大的。</strong></p>
<p><strong>如果不填版本字段，默认按照插入顺序保留最后一条。</strong> </p>
<p>（2）向表中插入数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_rmt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_004&#x27;</span>, <span class="number">2500.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">12000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">600.00</span>, <span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（3）重复再插入一次，执行第一次查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_rmt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909003504730.png" alt="image-20220909003504730"> </p>
<p>（4）手动合并</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> t_order_rmt <span class="keyword">FINAL</span>;</span><br></pre></td></tr></table></figure>

<p>（5）再执行一次查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_rmt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909003530398.png" alt="image-20220909003530398"> </p>
<p><strong>4）通过测试得到结论</strong></p>
<ul>
<li>实际上是使用 order by 字段作为唯一键</li>
<li>去重不能跨分区</li>
<li>只有同一批插入（新版本）或合并分区时才会进行去重</li>
<li>认定重复的数据保留，取版本字段值最大的</li>
<li>如果版本字段相同则按插入顺序保留最后一笔</li>
</ul>
<h3 id="4-6-SummingMergeTree"><a href="#4-6-SummingMergeTree" class="headerlink" title="4.6 SummingMergeTree"></a><strong>4.6 SummingMergeTree</strong></h3><p>对于不查询明细，只关心以维度进行汇总聚合结果的场景。如果只使用普通的MergeTree的话，无论是存储空间的开销，还是查询时临时聚合的开销都比较大。</p>
<p>ClickHouse 为了这种场景，提供了一种能够“预聚合”的引擎 SummingMergeTree</p>
<p><strong>1）案例演示</strong></p>
<p>（1）创建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_smt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> SummingMergeTree(total_amount)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>（2）插入数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_smt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_004&#x27;</span>, <span class="number">2500.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">12000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">600.00</span>, <span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（3）重复再插入一次，执行第一次查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_smt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909004038208.png" alt="image-20220909004038208">  </p>
<p>（4）手动合并</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> t_order_smt <span class="keyword">FINAL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909004121096.png" alt="image-20220909004121096"> </p>
<p><strong>2）通过结果可以得到以下结论</strong></p>
<ul>
<li>以 SummingMergeTree（）中指定的列作为汇总数据列 </li>
<li>可以填写多列必须数字列，如果不填，以所有非维度列且为数字列的字段为汇总数据列</li>
<li>以 order by 的列为准，作为维度列</li>
<li>其他的列按插入顺序保留第一行</li>
<li>不在一个分区的数据不会被聚合</li>
<li>只有在同一批次插入（新版本）或分片合并时才会进行聚合</li>
</ul>
<p><strong>3）开发建议</strong></p>
<p>设计聚合表的话，唯一键值、流水号可以去掉，所有字段全部是维度、度量或者时间戳。</p>
<p><strong>4）问题</strong></p>
<p>能不能直接执行以下 SQL 得到汇总值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> total_amount <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> province_name <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">AND</span> create_date <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不行，<strong>可能会包含一些还没来得及聚合的临时明细</strong></p>
<p>如果要是获取汇总值，还是需要使用 sum 进行聚合，这样效率会有一定的提高，但本身 ClickHouse 是列式存储的，效率提升有限，不会特别明显。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total_amount) <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> province_name <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">AND</span> create_date <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="第-5-章-SQL-操作"><a href="#第-5-章-SQL-操作" class="headerlink" title="第 5 章 SQL 操作"></a><strong>第</strong> <strong>5</strong> <strong>章</strong> <strong>SQL</strong> <strong>操作</strong></h2><p>基本上来说传统关系型数据库（以 MySQL 为例）的 SQL 语句，ClickHouse 基本都支持，这里只介绍 ClickHouse 与标准 SQL（MySQL）不一致的地方。</p>
<h3 id="5-1-Insert"><a href="#5-1-Insert" class="headerlink" title="5.1 Insert"></a><strong>5.1 Insert</strong></h3><p>与标准 SQL（MySQL）基本一致</p>
<p>（1）标准</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [table_name] <span class="keyword">VALUES</span> (...), (...)</span><br></pre></td></tr></table></figure>

<p>（2）从表到表的插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [table_name] <span class="keyword">SELECT</span> a,b,c <span class="keyword">FROM</span> [table_name_2]</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Update-和-Delete"><a href="#5-2-Update-和-Delete" class="headerlink" title="5.2 Update 和 Delete"></a><strong>5.2 Update</strong> <strong>和</strong> <strong>Delete</strong></h3><p>ClickHouse 提供了 Delete 和 Update 的能力，这类操作被称为 Mutation 查询，它可以看做 Alter 的一种。</p>
<p>虽然可以实现修改和删除，但是和一般的 OLTP 数据库不一样，<strong>Mutation</strong> <strong>语句是一种很“重”的操作，而且不支持事务。</strong></p>
<p>“重”的原因主要是每次修改或者删除都会导致放弃目标数据的原有分区，重建新分区。所以尽量做批量的变更，不要进行频繁小数据的操作。</p>
<p>（1）删除操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_smt <span class="keyword">DELETE</span> <span class="keyword">WHERE</span> sku_id <span class="operator">=</span> <span class="string">&#x27;sku_001&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>（2）修改操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_smt <span class="keyword">UPDATE</span> total_amount <span class="operator">=</span> toDecimal32(<span class="number">2000.00</span>, <span class="number">2</span>) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">102</span>;</span><br></pre></td></tr></table></figure>

<p>由于操作比较“重”，所以 Mutation 语句分两步执行，同步执行的部分其实只是进行新增数据新增分区和并把旧分区打上逻辑上的失效标记。直到触发分区合并的时候，才会删除旧数据释放磁盘空间，一般不会开放这样的功能给用户，由管理员完成。</p>
<p><strong>问题：如何实现高性能 update 和 delete ？</strong></p>
<p>回答：在创建表时，添加两个标记字段，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A</span><br><span class="line">(</span><br><span class="line">	a xxx,</span><br><span class="line">    b xxx,</span><br><span class="line">    c xxx,</span><br><span class="line">    _sign UInt8,</span><br><span class="line">    _version UInt32</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>那么，对于更新操作，则相当于是插入一条新的数据，此时 _version + 1，查询的时候加上一个过滤条件（WHERE  _version最大）进行查询。</p>
<p>对于删除操作，通过 _sign（0表示未删除，1表示已删除），同时 _version + 1，查询的时候加上一个过滤条件（WHERE _sign &#x3D; 0 AND _version最大）进行查询。</p>
<p><strong>那么如果时间久了，数据膨胀了怎么办？</strong>可以提供类似合并的机制，定期把过期数据进行清除。</p>
<h3 id="5-3-查询操作"><a href="#5-3-查询操作" class="headerlink" title="5.3 查询操作"></a><strong>5.3</strong> <strong>查询操作</strong></h3><p>ClickHouse 基本上与标准 SQL 差别不大</p>
<ul>
<li>支持子查询</li>
<li>支持 CTE(Common Table Expression 公用表表达式 with 子句) </li>
<li>支持各种 JOIN，但是 JOIN 操作无法使用缓存，所以即使是两次相同的 JOIN 语句，ClickHouse 也会视为两条新 SQL</li>
<li>支持窗口函数</li>
<li>支持自定义函数</li>
<li>GROUP BY 操作增加了 with rollup\with cube\with total 用来计算小计和总计。</li>
</ul>
<p>（1）插入数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 清空数据</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_mt <span class="keyword">DELETE</span> <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">103</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">104</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">105</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">106</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">107</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">108</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">109</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">110</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（2）with rollup：<strong>从右至左去掉维度进行小计</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, sku_id, <span class="built_in">sum</span>(total_amount) <span class="keyword">FROM</span> t_order_mt <span class="keyword">GROUP</span> <span class="keyword">BY</span> id, sku_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912165949176.png" alt="image-20220912165949176"> </p>
<p>（3）with cube : 从右至左去掉维度进行小计，再从左至右去掉维度进行小计</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, sku_id, <span class="built_in">sum</span>(total_amount) <span class="keyword">FROM</span> t_order_mt <span class="keyword">GROUP</span> <span class="keyword">BY</span> id, sku_id <span class="keyword">WITH</span> <span class="keyword">CUBE</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912170136379.png" alt="image-20220912170136379"> </p>
<p>（4）with totals: 只计算合计</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, sku_id, <span class="built_in">sum</span>(total_amount) <span class="keyword">FROM</span> t_order_mt <span class="keyword">GROUP</span> <span class="keyword">BY</span> id, sku_id <span class="keyword">WITH</span> TOTALS;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912170328807.png" alt="image-20220912170328807"> </p>
<h3 id="5-4-alter-操作"><a href="#5-4-alter-操作" class="headerlink" title="5.4 alter 操作"></a><strong>5.4 alter</strong> <strong>操作</strong></h3><p>同 MySQL 的修改字段基本一致</p>
<p><strong>1）新增字段</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> newcolname String AFTER col1;</span><br></pre></td></tr></table></figure>

<p><strong>2）修改字段类型</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName MODIFY <span class="keyword">COLUMN</span> newcolname String;</span><br></pre></td></tr></table></figure>

<p><strong>3）删除字段</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> newcolname;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-导出数据"><a href="#5-5-导出数据" class="headerlink" title="5.5 导出数据"></a><strong>5.5 导出数据</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse<span class="operator">-</span>client <span class="comment">--query &quot;select * from t_order_mt where create_time=&#x27;2020-06-01 12:00:00&#x27;&quot; --format CSVWithNames&gt; /opt/module/data/rs1.csv</span></span><br></pre></td></tr></table></figure>

<p>更多支持格式参考：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/interfaces/formats/">https://clickhouse.com/docs/en/interfaces/formats/</a></p>
<h2 id="第-6-章-副本"><a href="#第-6-章-副本" class="headerlink" title="第 6 章 副本"></a><strong>第</strong> <strong>6</strong> <strong>章 副本</strong></h2><p>副本的目的主要是保障数据的高可用性，即使一台 ClickHouse 节点宕机，那么也可以从其他服务器获得相同的数据。</p>
<h3 id="6-1-副本写入流程"><a href="#6-1-副本写入流程" class="headerlink" title="6.1 副本写入流程"></a><strong>6.1</strong> <strong>副本写入流程</strong></h3><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912192635581.png" alt="image-20220912192635581"> </p>
<h3 id="6-2-配置步骤"><a href="#6-2-配置步骤" class="headerlink" title="6.2 配置步骤"></a><strong>6.2</strong> <strong>配置步骤</strong></h3><p>（1）启动 zookeeper 集群</p>
<p>（2）在 hadoop102 的 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.d 目录下创建一个名为 metrika.xml 的配置文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：也可以不创建外部文件，直接在 config.xml 中指定 <code>&lt;zookeeper&gt;</code></p>
</blockquote>
<blockquote>
<p>提示：这里用三台机器作为集群，分别为hadoop102 、hadoop103 和 hadoop104</p>
</blockquote>
<p>（3）同步到 hadoop103 和 hadoop104 上</p>
<p>（4）在 hadoop102 的&#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml 中增加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zookeeper</span> <span class="attr">incl</span>=<span class="string">&quot;zookeeper-servers&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include_from</span>&gt;</span>/etc/clickhouse-server/config.d/metrika.xml<span class="tag">&lt;/<span class="name">include_from</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912204716940.png" alt="image-20220912204716940"> </p>
<p>（5）同步到 hadoop103 和 hadoop104 上，然后分别在 hadoop102、hadoop103 和 hadoop104 上重启 ClickHouse 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure>

<p>（6）在 hadoop102 和 hadoop103 上分别建表</p>
<p><strong>副本只能同步数据，不能同步表结构，所以我们需要在每台机器上自己手动建表</strong></p>
<p>① hadoop102</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rep2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/table/01/t_order_rep&#x27;</span>, <span class="string">&#x27;rep_102&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>② hadoop103</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rep2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/table/01/t_order_rep&#x27;</span>, <span class="string">&#x27;rep_103&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>③ hadoop104</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rep2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/table/01/t_order_rep&#x27;</span>, <span class="string">&#x27;rep_104&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>在 ReplicatedMergeTree 中，</p>
<p><strong>第一个参数</strong>是分片的 zk_path 一般按照：&#x2F;clickhouse&#x2F;table&#x2F;{shard}&#x2F;{table_name} 的格式写，如果只有一个分片就写 01 即可。</p>
<p><strong>第二个参数</strong>是副本名称，<strong>相同的分片副本名称不能相同。</strong></p>
<p>（7）在 hadoop102 上执行 insert 语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_rep2 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">103</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">104</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">105</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（8）在 hadoop103 上执行 select，可以查询出结果，说明副本配置正确</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_rep2;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912195219517.png" alt="image-20220912195219517"> </p>
<h2 id="第-7-章-分片集群"><a href="#第-7-章-分片集群" class="headerlink" title="第 7 章 分片集群"></a><strong>第</strong> <strong>7</strong> <strong>章 分片集群</strong></h2><p>副本虽然能够提高数据的可用性，降低丢失风险，但是每台服务器实际上必须容纳全量数据，对数据的<strong>横向扩容</strong>没有解决。</p>
<p>要解决数据水平切分的问题，需要引入分片的概念。通过分片把一份完整的数据进行切分，不同的分片分布到不同的节点上，再通过 Distributed 表引擎把数据拼接起来一同使用。</p>
<p><strong>Distributed 表引擎本身不存储数据，</strong>有点类似于 MyCat 之于 MySql，成为一种中间件，通过分布式逻辑表来写入、分发、路由来操作多台节点不同分片的分布式数据。</p>
<blockquote>
<p>注意：ClickHouse 的集群是表级别的，实际企业中，大部分做了高可用，但是没有用分片，避免降低查询性能以及操作集群的复杂性。</p>
</blockquote>
<h3 id="7-1-集群写入流程（3-分片-2-副本共-6-个节点）"><a href="#7-1-集群写入流程（3-分片-2-副本共-6-个节点）" class="headerlink" title="7.1 集群写入流程（3 分片 2 副本共 6 个节点）"></a><strong>7.1 集群写入流程（3 分片 2 副本共 6 个节点）</strong></h3><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912205654322.png" alt="image-20220912205654322"> </p>
<h3 id="7-2-集群读取流程（3-分片-2-副本共-6-个节点）"><a href="#7-2-集群读取流程（3-分片-2-副本共-6-个节点）" class="headerlink" title="7.2 集群读取流程（3 分片 2 副本共 6 个节点）"></a><strong>7.2 集群读取流程（3 分片 2 副本共 6 个节点）</strong></h3><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912205722974.png" alt="image-20220912205722974"> </p>
<h3 id="7-3-3-分片-2-副本共-6-个节点集群配置（供参考）"><a href="#7-3-3-分片-2-副本共-6-个节点集群配置（供参考）" class="headerlink" title="7.3 3 分片 2 副本共 6 个节点集群配置（供参考）"></a>7.3 3 分片 2 副本共 6 个节点集群配置（供参考）</h3><p>配置的位置还是在之前的&#x2F;etc&#x2F;clickhouse-server&#x2F;config.d&#x2F;metrika.xml，内容如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remote_servers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 集群名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第一个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop101<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第二个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第三个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop105<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop106<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">remote_servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：也可以不创建外部文件，直接在 config.xml 的 <code>&lt;remote_servers&gt;</code> 中指定</p>
</blockquote>
<h3 id="7-4-配置三节点版本集群及副本"><a href="#7-4-配置三节点版本集群及副本" class="headerlink" title="7.4 配置三节点版本集群及副本"></a><strong>7.4</strong> <strong>配置三节点版本集群及副本</strong></h3><h4 id="7-4-1-集群及副本规划（2-个分片，只有第一个分片有副本）"><a href="#7-4-1-集群及副本规划（2-个分片，只有第一个分片有副本）" class="headerlink" title="7.4.1 集群及副本规划（2 个分片，只有第一个分片有副本）"></a><strong>7.4.1 集群及副本规划（2 个分片，只有第一个分片有副本）</strong></h4><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912210332486.png" alt="image-20220912210332486"> </p>
<table>
<thead>
<tr>
<th align="left">hadoop102</th>
<th align="left">hadoop103</th>
<th align="left">hadoop104</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><macros><br>    <shard>01</shard><br><replica>rep_1_1</replica><br></macros></td>
<td align="left"><macros><br>    <shard>01</shard><br><replica>rep_1_2</replica><br></macros></td>
<td align="left"><macros><br>    <shard>02</shard><br><replica>rep_2_1</replica><br></macros></td>
</tr>
</tbody></table>
<h4 id="7-4-2-配置步骤"><a href="#7-4-2-配置步骤" class="headerlink" title="7.4.2 配置步骤"></a><strong>7.4.2</strong> <strong>配置步骤</strong></h4><p><strong>1）在 hadoop102 的 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.d 目录下创建 metrika-shard.xml 文件</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remote_servers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 集群名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第一个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第二个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">remote_servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">macros</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不同机器放的分片数不一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shard</span>&gt;</span>01<span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不同机器放的副本数不一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">replica</span>&gt;</span>rep_1_1<span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">macros</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：也可以不创建外部文件，直接在 config.xml 的 <code>&lt;remote_servers&gt;</code> 中指定</p>
</blockquote>
<p><strong>2）将 hadoop102 的 metrika-shard.xml 同步到 103 和 104</strong></p>
<p><strong>3）修改 103 和 104 中 metrika-shard.xml 宏的配置</strong></p>
<p>（1）103</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912211209173.png" alt="image-20220912211209173"> </p>
<p>（2）104</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912211350373.png" alt="image-20220912211350373"> </p>
<p><strong>4）在 hadoop102 上修改 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml</strong></p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912211517131.png" alt="image-20220912211517131"> </p>
<p><strong>5）同步 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml 到 103 和 104</strong></p>
<p><strong>6）重启三台服务器上的 ClickHouse 服务</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure>

<p><strong>7）在 hadoop102 上执行建表语句</strong></p>
<ul>
<li>会自动同步到 hadoop103 和 hadoop104 上</li>
<li>集群名字要和配置文件中的一致</li>
<li>分片和副本名称从配置文件的宏定义中获取</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> st_order_mt <span class="keyword">ON</span> CLUSTER gmall_cluster</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/tables/&#123;shard&#125;/st_order_mt&#x27;</span>, <span class="string">&#x27;&#123;replica&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>可以到 hadoop103 和 hadoop104 上查看表是否创建成功</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912214352072.png" alt="image-20220912214352072"> </p>
<p><strong>8）在 hadoop102 上创建 Distribute 分布式表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> st_order_mt_all2 <span class="keyword">ON</span> CLUSTER gmall_cluster</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> Distributed(gmall_cluster, <span class="keyword">default</span>, st_order_mt, hiveHash(sku_id));</span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong></p>
<p>Distributed（集群名称，库名，本地表名，分片键）</p>
<p>分片键必须是整型数字，所以用 hiveHash 函数转换，也可以 rand()</p>
<p><strong>9）在 hadoop102 上插入测试数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> st_order_mt_all2 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">201</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">202</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">203</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">204</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">205</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>10）通过查询分布式表和本地表观察输出结果</strong></p>
<blockquote>
<p>注意：分布式表管理不同分片时需要知道用户名和密码，如果 clickhouse 的用户设置了密码，则需要在分片配置中添加上密码。</p>
<p>错误信息：DB::Exception: Received from hadoop104:9000. DB::Exception: default: Authentication failed: password is incorrect or there is no user with such name.                     </p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span>default<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（1）分布式表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> st_order_mt_all2;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215138964.png" alt="image-20220912215138964"> </p>
<p>（2）本地表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> st_order_mt;</span><br></pre></td></tr></table></figure>

<p>① hadoop102</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215214139.png" alt="image-20220912215214139"> </p>
<p>② hadoop103</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215231777.png" alt="image-20220912215231777"> </p>
<p>③ hadoop104</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215308837.png" alt="image-20220912215308837"> </p>
<h1 id="第二部分-高级篇"><a href="#第二部分-高级篇" class="headerlink" title="第二部分 高级篇"></a>第二部分 高级篇</h1><h2 id="第-1-章-Explain-查看执行计划"><a href="#第-1-章-Explain-查看执行计划" class="headerlink" title="第 1 章 Explain 查看执行计划"></a><strong>第</strong> <strong>1</strong> <strong>章</strong> <strong>Explain</strong> <strong>查看执行计划</strong></h2><p>在 clickhouse 20.6 版本之前要查看 SQL 语句的执行计划需要设置日志级别为 trace 才能可以看到，并且只能真正执行 sql，在执行日志里面查看。在 20.6 版本引入了原生的执行计划的语法。在 20.6.3 版本成为正式版本的功能。</p>
<h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a><strong>1.1</strong> <strong>基本语法</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN [AST <span class="operator">|</span> SYNTAX <span class="operator">|</span> PLAN <span class="operator">|</span> PIPELINE] [setting <span class="operator">=</span> <span class="keyword">value</span>, ...] </span><br><span class="line"><span class="keyword">SELECT</span> ... [FORMAT ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>PLAN：用于查看执行计划，默认值。<ul>
<li>header：打印计划中各个步骤的 head 说明，默认关闭，默认值 0;</li>
<li>description：打印计划中各个步骤的描述，默认开启，默认值 1；</li>
<li>actions：打印计划中各个步骤的详细信息，默认关闭，默认值 0。</li>
</ul>
</li>
<li>AST：用于查看语法树; </li>
<li>SYNTAX：用于查看优化语法; </li>
<li>PIPELINE：用于查看 PIPELINE 计划。 <ul>
<li>header：打印计划中各个步骤的 head 说明，默认关闭; </li>
<li>graph：用 DOT 图形语言描述管道图，默认关闭，需要查看相关的图形需要配合 graphviz 查看；</li>
<li>actions：如果开启了 graph，紧凑打印打，默认开启。</li>
</ul>
</li>
</ul>
<h3 id="1-2-案例实操"><a href="#1-2-案例实操" class="headerlink" title="1.2 案例实操"></a><strong>1.2</strong> <strong>案例实操</strong></h3><h4 id="1-2-1-使用-EXPLAIN"><a href="#1-2-1-使用-EXPLAIN" class="headerlink" title="1.2.1 使用 EXPLAIN"></a><strong>1.2.1</strong> <strong>使用</strong> <strong>EXPLAIN</strong></h4><p>1）查看 PLAN</p>
<p>简单查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PLAN <span class="keyword">SELECT</span> arrayJoin([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>]);</span><br></pre></td></tr></table></figure>

<p>复杂 SQL 的执行计划</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> database, <span class="keyword">table</span>, <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> system.parts <span class="keyword">WHERE</span> database <span class="keyword">IN</span> (<span class="string">&#x27;datasets&#x27;</span>, <span class="string">&#x27;system&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> database, <span class="keyword">table</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> database <span class="keyword">ASC</span>, cnt <span class="keyword">DESC</span> LIMIT <span class="number">2</span> <span class="keyword">BY</span> database;</span><br></pre></td></tr></table></figure>

<p>打开全部的参数的执行计划</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN header <span class="operator">=</span> <span class="number">1</span>, actions <span class="operator">=</span> <span class="number">1</span>, description <span class="operator">=</span> <span class="number">1</span> <span class="keyword">SELECT</span> number <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>2）AST 语法树</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN AST <span class="keyword">SELECT</span> number <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>3）SYNTAX 语法优化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先做一次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 查看语法优化</span></span><br><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 开启三元运算符优化</span></span><br><span class="line"><span class="keyword">SET</span> optimize_if_chain_to_multiif <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 再次查看语法优化</span></span><br><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918101624402.png" alt="image-20220918101624402"> </p>
<p>4）查看 PIPELINE</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE <span class="keyword">SELECT</span> <span class="built_in">sum</span>(number) <span class="keyword">FROM</span> numbers_mt(<span class="number">100000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> number <span class="operator">%</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 打开其他参数</span></span><br><span class="line">EXPLAIN PIPELINE header <span class="operator">=</span> <span class="number">1</span>, graph <span class="operator">=</span> <span class="number">1</span> <span class="keyword">SELECT</span> <span class="built_in">sum</span>(number) <span class="keyword">FROM</span> numbers_mt(<span class="number">10000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> number <span class="operator">%</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第-2-章-建表优化"><a href="#第-2-章-建表优化" class="headerlink" title="第 2 章 建表优化"></a><strong>第</strong> <strong>2</strong> <strong>章 建表优化</strong></h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a><strong>2.1</strong> <strong>数据类型</strong></h3><h4 id="2-1-1-时间字段的类型"><a href="#2-1-1-时间字段的类型" class="headerlink" title="2.1.1 时间字段的类型"></a><strong>2.1.1</strong> <strong>时间字段的类型</strong></h4><p>建表时能用数值型或日期时间型表示的字段就不要用字符串，全 String 类型在以 Hive 为中心的数仓建设中常见，但 ClickHouse 环境不应受此影响。</p>
<p>虽然 ClickHouse 底层将 DateTime 存储为时间戳 Long 类型，但不建议存储 Long 类型，<strong>因为 DateTime 不需要经过函数转换处理，执行效率高、可读性好。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_type2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Int32</span><br><span class="line">) ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(toDate(create_time)) <span class="comment">-- 需要转换一次，否则报错</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-空值存储类型"><a href="#2-1-2-空值存储类型" class="headerlink" title="2.1.2 空值存储类型"></a><strong>2.1.2</strong> <strong>空值存储类型</strong></h4><p>官方已经指出 <strong>Nullable</strong> <strong>类型几乎总是会拖累性能</strong>，因为存储 Nullable 列时需要创建一个额外的文件来存储 NULL 的标记，并且 Nullable 列无法被索引。因此除非极特殊情况，应直接使用字段默认值表示空，或者自行指定一个在业务中无意义的值（例如用-1 表示没有商品ID）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_null</span><br><span class="line">(</span><br><span class="line">    `x` Int8,</span><br><span class="line">    `y` Nullable(Int8)</span><br><span class="line">) ENGINE <span class="operator">=</span> TinyLog;</span><br><span class="line"><span class="comment">-- 插入语句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_null <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="keyword">NULL</span>), (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 查询语句</span></span><br><span class="line"><span class="keyword">SELECT</span> x <span class="operator">+</span> y <span class="keyword">FROM</span> t_null;</span><br></pre></td></tr></table></figure>

<p>查看存储的文件：（没有权限就用 root 用户）</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918103851762.png" alt="image-20220918103851762"> </p>
<p>官方说明：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/">https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/</a></p>
<h3 id="2-2-分区和索引"><a href="#2-2-分区和索引" class="headerlink" title="2.2 分区和索引"></a><strong>2.2</strong> <strong>分区和索引</strong></h3><p>分区粒度根据业务特点决定，不宜过粗或过细。一般选择<strong>按天分区</strong>，也可以指定为 Tuple()，以单表一亿数据为例，分区大小控制在 10-30 个为最佳。</p>
<p>必须指定索引列，ClickHouse 中的<strong>索引列即排序列</strong>，通过 <strong>order by</strong> 指定，一般在查询条件中经常被用来充当筛选条件的属性被纳入进来；可以是单一维度，也可以是组合维度的索引；通常需要满足高级列在前、查询频率大的在前原则；还有基数特别大的不适合做索引列，如用户表的 userid 字段；通常<strong>筛选后的数据满足在百万以内为最佳</strong>。</p>
<blockquote>
<p><strong>问题：为什么基数特别大的不适合做索引列？</strong></p>
<p>官方文档：</p>
<p>When a query is filtering on at least one column that is part of a compound key, and is the first key column, <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#the-primary-index-is-used-for-selecting-granules">then ClickHouse is running the binary search algorithm over the key column’s index marks</a>.</p>
<p>When a query is filtering (only) on a column that is part of a compound key, but is not the first key column, <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple#secondary-key-columns-can-not-be-inefficient">then ClickHouse is using the generic exclusion search algorithm over the key column’s index marks</a>.</p>
<p>官方文档：</p>
<p>We discussed that because <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#data-is-stored-on-disk-ordered-by-primary-key-columns">a ClickHouse table’s row data is stored on disk ordered by primary key column(s)</a>, having a very high cardinality column (like a UUID column) in a primary key or in a compound primary key before columns with lower cardinality <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-cardinality#optimal-compression-ratio-of-data-files">is detrimental for the compression ratio of other table columns</a>.</p>
<p>A compromise between fastest retrieval and optimal data compression is to use a compound primary key where the UUID is the last key column, after low(er) cardinality key columns that are used to ensure a good compression ratio for some of the table’s columns.</p>
<p>结论：并不是基数特别大的不适合做索引列，而是基数特别大的不适合作为第一个索引列。因为如果查询条件不包含第一个索引时，这会使得通用排除搜索算法的效率变差。一个折中的做法是，索引列按照基数大小进行升序排列，基数特别大的作为索引的最后一列。</p>
</blockquote>
<p>比如官方案例的 hits_v1 表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>visits_v1 表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="2-3-表参数"><a href="#2-3-表参数" class="headerlink" title="2.3 表参数"></a><strong>2.3</strong> <strong>表参数</strong></h3><p>Index_granularity 是用来控制索引粒度的，默认是 8192，如非必须不建议调整。</p>
<p>如果表中不是必须保留全量历史数据，建议指定 TTL（生存时间值），可以免去手动清除过期历史数据的麻烦，TTL 也可以通过 alter table 语句随时修改。</p>
<h3 id="2-4-写入和删除优化"><a href="#2-4-写入和删除优化" class="headerlink" title="2.4 写入和删除优化"></a><strong>2.4</strong> <strong>写入和删除优化</strong></h3><p>（1）尽量不要执行单条或小批量删除和插入操作，这样会产生小分区文件，给后台 Merge 任务带来巨大压力</p>
<p>（2）不要一次写入太多分区，或数据写入太快，数据写入太快会导致 Merge 速度跟不上而报错，一般建议每秒钟发起 2-3 次写入操作，每次操作写入 2w~5w 条数据（依服务器性能而定）</p>
<p>写入过快报错，报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Code: 252, e.displayText() = DB::Exception: Too many parts(304). Merges are processing significantly slower than inserts</span><br><span class="line">2. Code: 241, e.displayText() = DB::Exception: Memory limit (for query) exceeded:would use 9.37 GiB (attempt to allocate chunk of 301989888 bytes), maximum: 9.31 GiB</span><br></pre></td></tr></table></figure>

<p>处理方式：</p>
<p>“ Too many parts 处理 ” ：使用 WAL 预写日志，提高写入性能。</p>
<p>in_memory_parts_enable_wal 默认为 true</p>
<p>在服务器内存充裕的情况下增加内存配额，一般通过 max_memory_usage 来实现</p>
<p>在服务器内存不充裕的情况下，建议将超出部分内容分配到系统硬盘上，但会降低执行速度，一般通过 max_bytes_before_external_group_by、max_bytes_before_external_sort 参数来实现。</p>
<h3 id="2-5-常见配置"><a href="#2-5-常见配置" class="headerlink" title="2.5 常见配置"></a><strong>2.5</strong> <strong>常见配置</strong></h3><p>配置项主要在 config.xml 或 users.xml 中， 基本上都在 users.xml 里 </p>
<ul>
<li>config.xml 的配置项<ul>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/">https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/</a></li>
</ul>
</li>
<li>users.xml 的配置项<ul>
<li><a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/settings/settings/">https://clickhouse.com/docs/en/operations/settings/settings/</a></li>
</ul>
</li>
</ul>
<h4 id="2-5-1-CPU-资源"><a href="#2-5-1-CPU-资源" class="headerlink" title="2.5.1 CPU 资源"></a><strong>2.5.1 CPU</strong> <strong>资源</strong></h4><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background_pool_size</td>
<td>后台线程池的大小，merge 线程就是在该线程池中执行，该线程池不仅仅是给 merge 线程用的，默认值 16，允许的前提下建议改成 <strong>cpu 个数的 2 倍（线程数）</strong>。</td>
</tr>
<tr>
<td>background_schedule_pool_size</td>
<td>执行后台任务（复制表、Kafka 流、DNS 缓存更新）的线程数。默认 128，<strong>建议改成 cpu 个数的 2 倍（线程数）</strong>。</td>
</tr>
<tr>
<td>background_distributed_schedule_pool_size</td>
<td>设置为分布式发送执行后台任务的线程数，默认 16，<strong>建议改成 cpu 个数的 2 倍（线程数）</strong>。</td>
</tr>
<tr>
<td>max_concurrent_queries</td>
<td>最大并发处理的请求数(包含 select,insert 等)，默认值 100，<strong>推荐 150(不够再加)~300</strong>。</td>
</tr>
<tr>
<td>max_threads</td>
<td>设置单个查询所能使用的最大 cpu 个数，默认是 cpu 核数</td>
</tr>
</tbody></table>
<h4 id="2-5-2-内存资源"><a href="#2-5-2-内存资源" class="headerlink" title="2.5.2 内存资源"></a><strong>2.5.2</strong> <strong>内存资源</strong></h4><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>max_memory_usage</td>
<td>此参数在 users.xml 中，表示单次 Query 占用内存最大值，该值可以设置的比较大，这样可以提升集群查询的上限。<strong>保留一点给 OS，比如 128G 内存的机器，设置为 100GB</strong>。</td>
</tr>
<tr>
<td>max_bytes_before_external_group_by</td>
<td>一般按照 max_memory_usage 的一半设置内存，当 group 使用内存超过阈值后会刷新到磁盘进行。因为 clickhouse 聚合分两个阶段：查询并及建立中间数据、合并中间数据，<strong>结合上一项，建议 50GB</strong>。</td>
</tr>
<tr>
<td>max_bytes_before_external_sort</td>
<td>一般按照 max_memory_usage 的一半设置内存，如果不设置该值，那么当内存不够时直接抛错，设置了该值 order by 可以正常完成，但是速度相对存内存来说肯定要慢点(实测慢的非常多，无法接受)。</td>
</tr>
<tr>
<td>max_table_size_to_drop</td>
<td>此参数在 config.xml 中，应用于需要删除表或分区的情况，默认是50GB，意思是如果删除 50GB 以上的分区表会失败。<strong>建议修改为 0</strong>，这样不管多大的分区表都可以删除。</td>
</tr>
</tbody></table>
<h4 id="2-5-3-存储"><a href="#2-5-3-存储" class="headerlink" title="2.5.3 存储"></a><strong>2.5.3</strong> <strong>存储</strong></h4><p>ClickHouse 不支持设置多数据目录，为了提升数据 io 性能，可以挂载虚拟券组，一个券组绑定多块物理磁盘提升读写性能，多数据查询场景 SSD 会比普通机械硬盘快 2-3 倍。</p>
<h2 id="第-3-章-ClickHouse-语法优化规则"><a href="#第-3-章-ClickHouse-语法优化规则" class="headerlink" title="第 3 章 ClickHouse 语法优化规则"></a><strong>第</strong> <strong>3</strong> <strong>章</strong> <strong>ClickHouse</strong> <strong>语法优化规则</strong></h2><p>ClickHouse 的 SQL 优化规则是基于 RBO(Rule Based Optimization)，下面是一些优化规则</p>
<h3 id="3-1-准备测试用表"><a href="#3-1-准备测试用表" class="headerlink" title="3.1 准备测试用表"></a><strong>3.1</strong> <strong>准备测试用表</strong></h3><p><strong>1）下载并导入官方的数据集</strong></p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/getting-started/example-datasets/metrica">https://clickhouse.com/docs/en/getting-started/example-datasets/metrica</a></p>
<p><strong>下载 hits 压缩 TSV 文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl https://datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz | unxz --threads=`nproc` &gt; hits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Validate the checksum</span></span><br><span class="line">md5sum hits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Checksum should be equal to: f3631b6295bf06989c1437491f7592cb</span></span><br></pre></td></tr></table></figure>

<p><strong>创建数据库和表：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;CREATE DATABASE IF NOT EXISTS datasets&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;CREATE TABLE datasets.hits_v1 ( WatchID UInt64,  JavaEnable UInt8,  Title String,  GoodEvent Int16,  EventTime DateTime,  EventDate Date,  CounterID UInt32,  ClientIP UInt32,  ClientIP6 FixedString(16),  RegionID UInt32,  UserID UInt64,  CounterClass Int8,  OS UInt8,  UserAgent UInt8,  URL String,  Referer String,  URLDomain String,  RefererDomain String,  Refresh UInt8,  IsRobot UInt8,  RefererCategories Array(UInt16),  URLCategories Array(UInt16), URLRegions Array(UInt32),  RefererRegions Array(UInt32),  ResolutionWidth UInt16,  ResolutionHeight UInt16,  ResolutionDepth UInt8,  FlashMajor UInt8, FlashMinor UInt8,  FlashMinor2 String,  NetMajor UInt8,  NetMinor UInt8, UserAgentMajor UInt16,  UserAgentMinor FixedString(2),  CookieEnable UInt8, JavascriptEnable UInt8,  IsMobile UInt8,  MobilePhone UInt8,  MobilePhoneModel String,  Params String,  IPNetworkID UInt32,  TraficSourceID Int8, SearchEngineID UInt16,  SearchPhrase String,  AdvEngineID UInt8,  IsArtifical UInt8,  WindowClientWidth UInt16,  WindowClientHeight UInt16,  ClientTimeZone Int16,  ClientEventTime DateTime,  SilverlightVersion1 UInt8, SilverlightVersion2 UInt8,  SilverlightVersion3 UInt32,  SilverlightVersion4 UInt16,  PageCharset String,  CodeVersion UInt32,  IsLink UInt8,  IsDownload UInt8,  IsNotBounce UInt8,  FUniqID UInt64,  HID UInt32,  IsOldCounter UInt8, IsEvent UInt8,  IsParameter UInt8,  DontCountHits UInt8,  WithHash UInt8, HitColor FixedString(1),  UTCEventTime DateTime,  Age UInt8,  Sex UInt8,  Income UInt8,  Interests UInt16,  Robotness UInt8,  GeneralInterests Array(UInt16), RemoteIP UInt32,  RemoteIP6 FixedString(16),  WindowName Int32,  OpenerName Int32,  HistoryLength Int16,  BrowserLanguage FixedString(2),  BrowserCountry FixedString(2),  SocialNetwork String,  SocialAction String,  HTTPError UInt16, SendTiming Int32,  DNSTiming Int32,  ConnectTiming Int32,  ResponseStartTiming Int32,  ResponseEndTiming Int32,  FetchTiming Int32,  RedirectTiming Int32, DOMInteractiveTiming Int32,  DOMContentLoadedTiming Int32,  DOMCompleteTiming Int32,  LoadEventStartTiming Int32,  LoadEventEndTiming Int32, NSToDOMContentLoadedTiming Int32,  FirstPaintTiming Int32,  RedirectCount Int8, SocialSourceNetworkID UInt8,  SocialSourcePage String,  ParamPrice Int64, ParamOrderID String,  ParamCurrency FixedString(3),  ParamCurrencyID UInt16, GoalsReached Array(UInt32),  OpenstatServiceName String,  OpenstatCampaignID String,  OpenstatAdID String,  OpenstatSourceID String,  UTMSource String, UTMMedium String,  UTMCampaign String,  UTMContent String,  UTMTerm String, FromTag String,  HasGCLID UInt8,  RefererHash UInt64,  URLHash UInt64,  CLID UInt32,  YCLID UInt64,  ShareService String,  ShareURL String,  ShareTitle String,  ParsedParams Nested(Key1 String,  Key2 String, Key3 String, Key4 String, Key5 String,  ValueDouble Float64),  IslandID FixedString(16),  RequestNum UInt32,  RequestTry UInt8) ENGINE = MergeTree() PARTITION BY toYYYYMM(EventDate) ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID) SETTINGS index_granularity = 8192&quot;</span><br></pre></td></tr></table></figure>

<p><strong>导入 hits 数据：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hits_v1.tsv | clickhouse-client [--password] --query &quot;INSERT INTO datasets.hits_v1 FORMAT TSV&quot; --max_insert_block_size=100000</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;SELECT COUNT(*) FROM datasets.hits_v1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918212056904.png" alt="image-20220918212056904"> </p>
<p><strong>下载 visits 压缩 TSV 文件：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl https://datasets.clickhouse.com/visits/tsv/visits_v1.tsv.xz | unxz --threads=`nproc` &gt; visits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Validate the checksum</span></span><br><span class="line">md5sum visits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Checksum should be equal to: 6dafe1a0f24e59e3fc2d0fed85601de6</span></span><br></pre></td></tr></table></figure>

<p><strong>创建表：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;CREATE TABLE datasets.visits_v1 ( CounterID UInt32,  StartDate Date,  Sign Int8,  IsNew UInt8,  VisitID UInt64,  UserID UInt64,  StartTime DateTime,  Duration UInt32,  UTCStartTime DateTime,  PageViews Int32,  Hits Int32,  IsBounce UInt8,  Referer String,  StartURL String,  RefererDomain String,  StartURLDomain String,  EndURL String,  LinkURL String,  IsDownload UInt8,  TraficSourceID Int8,  SearchEngineID UInt16,  SearchPhrase String,  AdvEngineID UInt8,  PlaceID Int32,  RefererCategories Array(UInt16),  URLCategories Array(UInt16),  URLRegions Array(UInt32),  RefererRegions Array(UInt32),  IsYandex UInt8,  GoalReachesDepth Int32,  GoalReachesURL Int32,  GoalReachesAny Int32,  SocialSourceNetworkID UInt8,  SocialSourcePage String,  MobilePhoneModel String,  ClientEventTime DateTime,  RegionID UInt32,  ClientIP UInt32,  ClientIP6 FixedString(16),  RemoteIP UInt32,  RemoteIP6 FixedString(16),  IPNetworkID UInt32,  SilverlightVersion3 UInt32,  CodeVersion UInt32,  ResolutionWidth UInt16,  ResolutionHeight UInt16,  UserAgentMajor UInt16,  UserAgentMinor UInt16,  WindowClientWidth UInt16,  WindowClientHeight UInt16,  SilverlightVersion2 UInt8,  SilverlightVersion4 UInt16,  FlashVersion3 UInt16,  FlashVersion4 UInt16,  ClientTimeZone Int16,  OS UInt8,  UserAgent UInt8,  ResolutionDepth UInt8,  FlashMajor UInt8,  FlashMinor UInt8,  NetMajor UInt8,  NetMinor UInt8,  MobilePhone UInt8,  SilverlightVersion1 UInt8,  Age UInt8,  Sex UInt8,  Income UInt8,  JavaEnable UInt8,  CookieEnable UInt8,  JavascriptEnable UInt8,  IsMobile UInt8,  BrowserLanguage UInt16,  BrowserCountry UInt16,  Interests UInt16,  Robotness UInt8,  GeneralInterests Array(UInt16),  Params Array(String),  Goals Nested(ID UInt32, Serial UInt32, EventTime DateTime,  Price Int64,  OrderID String, CurrencyID UInt32),  WatchIDs Array(UInt64),  ParamSumPrice Int64,  ParamCurrency FixedString(3),  ParamCurrencyID UInt16,  ClickLogID UInt64,  ClickEventID Int32,  ClickGoodEvent Int32,  ClickEventTime DateTime,  ClickPriorityID Int32,  ClickPhraseID Int32,  ClickPageID Int32,  ClickPlaceID Int32,  ClickTypeID Int32,  ClickResourceID Int32,  ClickCost UInt32,  ClickClientIP UInt32,  ClickDomainID UInt32,  ClickURL String,  ClickAttempt UInt8,  ClickOrderID UInt32,  ClickBannerID UInt32,  ClickMarketCategoryID UInt32,  ClickMarketPP UInt32,  ClickMarketCategoryName String,  ClickMarketPPName String,  ClickAWAPSCampaignName String,  ClickPageName String,  ClickTargetType UInt16,  ClickTargetPhraseID UInt64,  ClickContextType UInt8,  ClickSelectType Int8,  ClickOptions String,  ClickGroupBannerID Int32,  OpenstatServiceName String,  OpenstatCampaignID String,  OpenstatAdID String,  OpenstatSourceID String,  UTMSource String,  UTMMedium String,  UTMCampaign String,  UTMContent String,  UTMTerm String,  FromTag String,  HasGCLID UInt8,  FirstVisit DateTime,  PredLastVisit Date,  LastVisit Date,  TotalVisits UInt32,  TraficSource    Nested(ID Int8,  SearchEngineID UInt16, AdvEngineID UInt8, PlaceID UInt16, SocialSourceNetworkID UInt8, Domain String, SearchPhrase String, SocialSourcePage String),  Attendance FixedString(16),  CLID UInt32,  YCLID UInt64,  NormalizedRefererHash UInt64,  SearchPhraseHash UInt64,  RefererDomainHash UInt64,  NormalizedStartURLHash UInt64,  StartURLDomainHash UInt64,  NormalizedEndURLHash UInt64,  TopLevelDomain UInt64,  URLScheme UInt64,  OpenstatServiceNameHash UInt64,  OpenstatCampaignIDHash UInt64,  OpenstatAdIDHash UInt64,  OpenstatSourceIDHash UInt64,  UTMSourceHash UInt64,  UTMMediumHash UInt64,  UTMCampaignHash UInt64,  UTMContentHash UInt64,  UTMTermHash UInt64,  FromHash UInt64,  WebVisorEnabled UInt8,  WebVisorActivity UInt32,  ParsedParams    Nested(Key1 String,  Key2 String,  Key3 String,  Key4 String, Key5 String, ValueDouble    Float64),  Market Nested(Type UInt8, GoalID UInt32, OrderID String,  OrderPrice Int64,  PP UInt32,  DirectPlaceID UInt32,  DirectOrderID  UInt32,  DirectBannerID UInt32,  GoodID String, GoodName String, GoodQuantity Int32,  GoodPrice Int64),  IslandID FixedString(16)) ENGINE = CollapsingMergeTree(Sign) PARTITION BY toYYYYMM(StartDate) ORDER BY (CounterID, StartDate, intHash32(UserID), VisitID) SAMPLE BY intHash32(UserID) SETTINGS index_granularity = 8192&quot;</span><br></pre></td></tr></table></figure>

<p><strong>导入 visits 数据：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat visits_v1.tsv | clickhouse-client [--password] --query &quot;INSERT INTO datasets.visits_v1 FORMAT TSV&quot; --max_insert_block_size=100000</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;SELECT COUNT(*) FROM datasets.visits_v1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918211502836.png" alt="image-20220918211502836"> </p>
<h3 id="3-2-COUNT-优化"><a href="#3-2-COUNT-优化" class="headerlink" title="3.2 COUNT 优化"></a><strong>3.2 COUNT</strong> <strong>优化</strong></h3><p>在调用 count 函数时，如果使用的是 count() 或者 count(*)，且没有 where 条件，则会直接使用 system.tables 的 total_rows，例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">count</span>() <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918212520617.png" alt="image-20220918212520617"> </p>
<p>注意 Optimized trivial count ，这是对 count 的优化。</p>
<p>如果 count 具体的列字段，则不会使用此项优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">count</span>(CounterID) <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918212624192.png" alt="image-20220918212624192"> </p>
<h3 id="3-3-消除子查询重复字段"><a href="#3-3-消除子查询重复字段" class="headerlink" title="3.3 消除子查询重复字段"></a><strong>3.3</strong> <strong>消除子查询重复字段</strong></h3><p>下面语句子查询中有两个重复的 id 字段，会被去重:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.UserID,</span><br><span class="line">    b.VisitID,</span><br><span class="line">    a.URL,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        UserID,</span><br><span class="line">        UserID <span class="keyword">AS</span> HaHa,</span><br><span class="line">        VisitID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">) <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID)</span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213307849.png" alt="image-20220918213307849"> </p>
<h3 id="3-4-谓词下推"><a href="#3-4-谓词下推" class="headerlink" title="3.4 谓词下推"></a><strong>3.4</strong> <strong>谓词下推</strong></h3><p>当 group by 有 having 子句，但是没有 with cube、with rollup 或者 with totals 修饰的时候，having 过滤会下推到 where 提前过滤。例如下面的查询，HAVING name 变成了 WHERE name，在 group by 之前过滤：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">HAVING</span> UserID <span class="operator">=</span> <span class="string">&#x27;8585742290196126178&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213532475.png" alt="image-20220918213532475"> </p>
<p>子查询也支持谓词下推：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> UserID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="string">&#x27;8585742290196126178&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213712676.png" alt="image-20220918213712676"> </p>
<p>再来一个复杂例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> UserID</span><br><span class="line">        <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> UserID</span><br><span class="line">        <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="string">&#x27;8585742290196126178&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213856857.png" alt="image-20220918213856857"> </p>
<h3 id="3-5-聚合计算外推"><a href="#3-5-聚合计算外推" class="headerlink" title="3.5 聚合计算外推"></a><strong>3.5</strong> <strong>聚合计算外推</strong></h3><p>聚合函数内的计算，会外推，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(UserID <span class="operator">*</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214011204.png" alt="image-20220918214011204"> </p>
<h3 id="3-6-聚合函数消除"><a href="#3-6-聚合函数消除" class="headerlink" title="3.6 聚合函数消除"></a><strong>3.6</strong> <strong>聚合函数消除</strong></h3><p>如果对聚合键，也就是 group by key 使用 min、max、any 聚合函数，则将函数消除，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">sum</span>(UserID <span class="operator">*</span> <span class="number">2</span>),</span><br><span class="line">    <span class="built_in">max</span>(VisitID),</span><br><span class="line">    <span class="built_in">max</span>(UserID)</span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214136336.png" alt="image-20220918214136336">  </p>
<h3 id="3-7-删除重复的-order-by-key"><a href="#3-7-删除重复的-order-by-key" class="headerlink" title="3.7 删除重复的 order by key"></a><strong>3.7</strong> <strong>删除重复的</strong> <strong>order by key</strong></h3><p>例如下面的语句，重复的聚合键 id 字段会被去重：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214619369.png" alt="image-20220918214619369"> </p>
<h3 id="3-8-删除重复的-limit-by-key"><a href="#3-8-删除重复的-limit-by-key" class="headerlink" title="3.8 删除重复的 limit by key"></a><strong>3.8</strong> <strong>删除重复的</strong> <strong>limit by key</strong></h3><p>例如下面的语句，重复声明的 name 字段会被去重：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">BY</span></span><br><span class="line">    VisitID,</span><br><span class="line">    VisitID</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214726919.png" alt="image-20220918214726919"> </p>
<h3 id="3-9-删除重复的-USING-Key"><a href="#3-9-删除重复的-USING-Key" class="headerlink" title="3.9 删除重复的 USING Key"></a><strong>3.9</strong> <strong>删除重复的</strong> <strong>USING Key</strong></h3><p>例如下面的语句，重复的关联键 id 字段会被去重：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.UserID,</span><br><span class="line">    a.UserID,</span><br><span class="line">    b.VisitID,</span><br><span class="line">    a.URL,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID, UserID);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214918761.png" alt="image-20220918214918761"> </p>
<h3 id="3-10-标量替换"><a href="#3-10-标量替换" class="headerlink" title="3.10 标量替换"></a><strong>3.10</strong> <strong>标量替换</strong></h3><p>如果子查询只返回一行数据，在被引用的时候用标量替换，例如下面语句中的 total_disk_usage 字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">WITH</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">sum</span>(bytes)</span><br><span class="line">        <span class="keyword">FROM</span> system.parts</span><br><span class="line">        <span class="keyword">WHERE</span> active</span><br><span class="line">    ) <span class="keyword">AS</span> total_disk_usage</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    (<span class="built_in">sum</span>(bytes) <span class="operator">/</span> total_disk_usage) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> table_disk_usage,</span><br><span class="line">    <span class="keyword">table</span></span><br><span class="line"><span class="keyword">FROM</span> system.parts</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> table_disk_usage <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918215026462.png" alt="image-20220918215026462"> </p>
<h3 id="3-11-三元运算优化"><a href="#3-11-三元运算优化" class="headerlink" title="3.11 三元运算优化"></a><strong>3.11</strong> <strong>三元运算优化</strong></h3><p>如果开启了 optimize_if_chain_to_multiif 参数，三元运算符会被替换成 multiIf 函数，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX </span><br><span class="line"><span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) </span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10</span>) </span><br><span class="line">settings optimize_if_chain_to_multiif <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918215233545.png" alt="image-20220918215233545"> </p>
<h2 id="第-4-章-查询优化"><a href="#第-4-章-查询优化" class="headerlink" title="第 4 章 查询优化"></a><strong>第</strong> <strong>4</strong> <strong>章 查询优化</strong></h2><h3 id="4-1-单表查询"><a href="#4-1-单表查询" class="headerlink" title="4.1 单表查询"></a><strong>4.1</strong> <strong>单表查询</strong></h3><h4 id="4-1-1-Prewhere-替代-where"><a href="#4-1-1-Prewhere-替代-where" class="headerlink" title="4.1.1 Prewhere 替代 where"></a><strong>4.1.1 Prewhere</strong> <strong>替代</strong> <strong>where</strong></h4><p>Prewhere 和 where 语句的作用相同，用来过滤数据。不同之处在于 prewhere 只支持 *MergeTree 族系列引擎的表，首先会读取指定的列数据，来判断数据过滤，等待数据过滤之后再读取 select 声明的列字段来补全其余属性。</p>
<p>当查询列明显多于筛选列时使用 Prewhere 可十倍提升查询性能，Prewhere 会自动优化执行过滤阶段的数据读取方式，降低 io 操作。</p>
<p>在某些场合下，prewhere 语句比 where 语句处理的数据量更少性能更高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭 where 自动转 prewhere(默认情况下， where 条件会自动优化成 prewhere)</span></span><br><span class="line"><span class="keyword">set</span> optimize_move_to_prewhere <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 where</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID,</span><br><span class="line">    CounterClass,</span><br><span class="line">    OS,</span><br><span class="line">    UserAgent,</span><br><span class="line">    URL,</span><br><span class="line">    Referer,</span><br><span class="line">    URLDomain,</span><br><span class="line">    RefererDomain,</span><br><span class="line">    Refresh,</span><br><span class="line">    IsRobot,</span><br><span class="line">    RefererCategories,</span><br><span class="line">    URLCategories,</span><br><span class="line">    URLRegions,</span><br><span class="line">    RefererRegions,</span><br><span class="line">    ResolutionWidth,</span><br><span class="line">    ResolutionHeight,</span><br><span class="line">    ResolutionDepth,</span><br><span class="line">    FlashMajor,</span><br><span class="line">    FlashMinor,</span><br><span class="line">    FlashMinor2</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="string">&#x27;3198390223272470366&#x27;</span>;</span><br><span class="line"><span class="comment">-- 152 rows in set. Elapsed: 0.897 sec. Processed 8.87 million rows, 3.86 GB (9.89 million rows/s., 4.30 GB/s.)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 prewhere 关键字</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID,</span><br><span class="line">    CounterClass,</span><br><span class="line">    OS,</span><br><span class="line">    UserAgent,</span><br><span class="line">    URL,</span><br><span class="line">    Referer,</span><br><span class="line">    URLDomain,</span><br><span class="line">    RefererDomain,</span><br><span class="line">    Refresh,</span><br><span class="line">    IsRobot,</span><br><span class="line">    RefererCategories,</span><br><span class="line">    URLCategories,</span><br><span class="line">    URLRegions,</span><br><span class="line">    RefererRegions,</span><br><span class="line">    ResolutionWidth,</span><br><span class="line">    ResolutionHeight,</span><br><span class="line">    ResolutionDepth,</span><br><span class="line">    FlashMajor,</span><br><span class="line">    FlashMinor,</span><br><span class="line">    FlashMinor2</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">PREWHERE UserID <span class="operator">=</span> <span class="string">&#x27;3198390223272470366&#x27;</span>;</span><br><span class="line"><span class="comment">-- 152 rows in set. Elapsed: 0.083 sec. Processed 8.87 million rows, 116.54 MB (106.55 million rows/s., 1.40 GB/s.)</span></span><br></pre></td></tr></table></figure>

<p>默认情况，我们肯定不会关闭 where 自动优化成 prewhere，但是某些场景即使开启优化，也不会自动转换成 prewhere，需要手动指定 prewhere：</p>
<ul>
<li>使用常量表达式</li>
<li>使用默认值为 alias 类型的字段</li>
<li>包含了 arrayJOIN，globalIn，globalNotIn 或者 indexHint 的查询</li>
<li>select 查询的列字段和 where 的谓词相同</li>
<li>使用了主键字段</li>
</ul>
<h4 id="4-1-2-数据采样"><a href="#4-1-2-数据采样" class="headerlink" title="4.1.2 数据采样"></a><strong>4.1.2</strong> <strong>数据采样</strong></h4><p>通过采样运算可极大提升数据分析的性能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Title,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> PageViews</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">SAMPLE <span class="number">1</span> <span class="operator">/</span> <span class="number">10</span> <span class="comment">-- 代表采样10%的数据,也可以是具体的条数</span></span><br><span class="line"><span class="keyword">WHERE</span> CounterID <span class="operator">=</span> <span class="number">57</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> PageViews <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>采样修饰符只有在 MergeTree engine 表中才有效，且在创建表时需要指定采样策略。</p>
<h4 id="4-1-3-列裁剪与分区裁剪"><a href="#4-1-3-列裁剪与分区裁剪" class="headerlink" title="4.1.3 列裁剪与分区裁剪"></a><strong>4.1.3</strong> <strong>列裁剪与分区裁剪</strong></h4><p>数据量太大时应避免使用 select * 操作，查询的性能会与查询的字段大小和数量成线性表换，字段越少，消耗的 io 资源越少，性能就会越高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"><span class="comment">-- 正例</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID, </span><br><span class="line">    JavaEnable, </span><br><span class="line">    Title, </span><br><span class="line">    GoodEvent, </span><br><span class="line">    EventTime, </span><br><span class="line">    EventDate, </span><br><span class="line">    CounterID, </span><br><span class="line">    ClientIP, </span><br><span class="line">    ClientIP6, </span><br><span class="line">    RegionID, </span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<p>分区裁剪就是只读取需要的分区，在过滤条件中指定。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID, </span><br><span class="line">    JavaEnable, </span><br><span class="line">    Title, </span><br><span class="line">    GoodEvent, </span><br><span class="line">    EventTime, </span><br><span class="line">    EventDate, </span><br><span class="line">    CounterID, </span><br><span class="line">    ClientIP, </span><br><span class="line">    ClientIP6, </span><br><span class="line">    RegionID, </span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-23&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-4-orderby-结合-where、limit"><a href="#4-1-4-orderby-结合-where、limit" class="headerlink" title="4.1.4 orderby 结合 where、limit"></a><strong>4.1.4 orderby 结合 where、limit</strong></h4><p>千万以上数据集进行 order by 查询时需要搭配 where 条件和 limit 语句一起使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正例：</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    Age</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> CounterID <span class="operator">=</span> <span class="number">57</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 反例：</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    Age</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-5-避免构建虚拟列"><a href="#4-1-5-避免构建虚拟列" class="headerlink" title="4.1.5 避免构建虚拟列"></a><strong>4.1.5</strong> <strong>避免构建虚拟列</strong></h4><p>如非必须，不要在结果集上构建虚拟列，虚拟列非常消耗资源浪费性能，可以考虑在前端进行处理，或者在表中构造实际字段进行额外存储。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例：</span></span><br><span class="line"><span class="keyword">SELECT</span> Income, Age, Income<span class="operator">/</span>Age <span class="keyword">as</span> IncRate <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"><span class="comment">-- 正例：拿到 Income 和 Age 后，考虑在前端进行处理，或者在表中构造实际字段进行额外存储</span></span><br><span class="line"><span class="keyword">SELECT</span> Income, Age <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-6-uniqCombined-替代-distinct"><a href="#4-1-6-uniqCombined-替代-distinct" class="headerlink" title="4.1.6 uniqCombined 替代 distinct"></a><strong>4.1.6 uniqCombined</strong> <strong>替代</strong> <strong>distinct</strong></h4><p>性能可提升 10 倍以上，uniqCombined 底层采用类似 HyperLogLog 算法实现，能接受 2% 左右的数据误差，可直接使用这种去重方式提升查询性能。Count(distinct)会使用 uniqExact 精确去重。</p>
<p>不建议在千万级不同数据上执行 distinct 去重查询，改为近似去重 uniqCombined</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> rand()) <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"><span class="comment">-- 正例：</span></span><br><span class="line"><span class="keyword">SELECT</span> uniqCombined(rand()) <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-7-使用物化视图"><a href="#4-1-7-使用物化视图" class="headerlink" title="4.1.7 使用物化视图"></a><strong>4.1.7</strong> <strong>使用物化视图</strong></h4><p>参考第 6 章。</p>
<h4 id="4-1-8-其他注意事项"><a href="#4-1-8-其他注意事项" class="headerlink" title="4.1.8 其他注意事项"></a><strong>4.1.8</strong> <strong>其他注意事项</strong></h4><p><strong>（1）查询熔断</strong></p>
<p>为了避免因个别慢查询引起的服务雪崩的问题，除了可以为单个查询设置超时以外，还可以配置周期熔断，在一个查询周期内，如果用户频繁进行慢查询操作超出规定阈值后将无法继续进行查询操作。</p>
<p><strong>（2）关闭虚拟内存</strong></p>
<p>物理内存和虚拟内存的数据交换，会导致查询变慢，资源允许的情况下关闭虚拟内存。</p>
<p><strong>（3）配置 join_use_nulls</strong></p>
<p>为每一个账户添加 join_use_nulls 配置，左表中的一条记录在右表中不存在，右表的相应字段会返回该字段相应数据类型的默认值，而不是标准 SQL 中的 Null 值。</p>
<p><strong>（4）批量写入时先排序</strong></p>
<p>批量写入数据时，必须控制每个批次的数据中涉及到的分区的数量，在写入之前最好对需要导入的数据进行排序。无序的数据或者涉及的分区太多，会导致 ClickHouse 无法及时对新导入的数据进行合并，从而影响查询性能。</p>
<p><strong>（5）关注 CPU</strong></p>
<p>cpu 一般在 50%左右会出现查询波动，达到 70%会出现大范围的查询超时，cpu 是最关键的指标，要非常关注。</p>
<h3 id="4-2-多表关联"><a href="#4-2-多表关联" class="headerlink" title="4.2 多表关联"></a><strong>4.2</strong> <strong>多表关联</strong></h3><h4 id="4-2-1-准备表和数据"><a href="#4-2-1-准备表和数据" class="headerlink" title="4.2.1 准备表和数据"></a><strong>4.2.1</strong> <strong>准备表和数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建小表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.visits_v2</span><br><span class="line">ENGINE <span class="operator">=</span> CollapsingMergeTree(Sign)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span> <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">LIMIT <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 join 结果表：避免控制台疯狂打印数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.hits_v2</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span> <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-用-IN-代替-JOIN"><a href="#4-2-2-用-IN-代替-JOIN" class="headerlink" title="4.2.2 用 IN 代替 JOIN"></a><strong>4.2.2</strong> <strong>用</strong> <strong>IN</strong> <strong>代替</strong> <strong>JOIN</strong></h4><p>当多表联查时，查询的数据仅从其中一张表出时，可考虑用 IN 操作而不是 JOIN</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> a.CounterID <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> CounterID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 1.595 sec. Processed 6.19 million rows, 5.86 GB (3.88 million rows/s., 3.68 GB/s.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 反例：使用 join</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 25.152 sec. Processed 10.55 million rows, 8.47 GB (419.58 thousand rows/s., 336.60 MB/s.)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-大小表-JOIN"><a href="#4-2-3-大小表-JOIN" class="headerlink" title="4.2.3 大小表 JOIN"></a><strong>4.2.3</strong> <strong>大小表</strong> <strong>JOIN</strong></h4><p>多表 join 时要满足小表在右的原则，右表关联时被加载到内存中与左表进行比较，ClickHouse 中无论是 Left join 、Right join 还是 Inner join 永远都是拿着右表中的每一条记录到左表中查找该记录是否存在，所以右表必须是小表。</p>
<p><strong>（1）小表在右</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 23.745 sec. Processed 8.88 million rows, 8.46 GB (374.11 thousand rows/s., 356.28 MB/s.)</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）大表在右</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v2 <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.hits_v1 <span class="keyword">AS</span> a <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- Code: 241. DB::Exception: Received from localhost:9000. DB::Exception: Memory limit (total) exceeded: would use 3.31 GiB (attempt to allocate chunk of 4202528 bytes), maximum: 3.31 GiB: (while reading column UTMMedium): (while reading from part /var/lib/clickhouse/store/f5f/f5f00661-967a-4a35-b5f0-0661967afa35/201403_25_30_1/ from mark 0 with max_rows_to_read = 8192): While executing MergeTreeThread.</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-注意谓词下推（版本差异）"><a href="#4-2-4-注意谓词下推（版本差异）" class="headerlink" title="4.2.4 注意谓词下推（版本差异）"></a><strong>4.2.4</strong> <strong>注意谓词下推（版本差异）</strong></h4><p>ClickHouse 在 join 查询时不会主动发起谓词下推的操作，需要每个子查询提前完成过滤操作，需要注意的是，是否执行谓词下推，对性能影响差别很大（新版本中已经不存在此问题，但是需要注意谓词的位置的不同依然有性能的差异）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID</span><br><span class="line"><span class="keyword">HAVING</span> a.EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918230221445.png" alt="image-20220918230221445"> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID</span><br><span class="line"><span class="keyword">HAVING</span> b.StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918230335644.png" alt="image-20220918230335644"> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID</span><br><span class="line"><span class="keyword">WHERE</span> a.EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 5.113 sec. Processed 6.70 million rows, 5.66 GB (1.31 million rows/s., 1.11 GB/s.)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">    <span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 5.204 sec. Processed 6.70 million rows, 5.66 GB (1.29 million rows/s., 1.09 GB/s.)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-分布式表使用-GLOBAL"><a href="#4-2-5-分布式表使用-GLOBAL" class="headerlink" title="4.2.5 分布式表使用 GLOBAL"></a><strong>4.2.5</strong> <strong>分布式表使用</strong> <strong>GLOBAL</strong></h4><p>两张<strong>分布式表</strong>上的 IN 和 JOIN 之前必须加上 <strong>GLOBAL</strong> 关键字，右表只会在接收查询请求的那个节点查询一次，并将其分发到其他节点上。如果不加 GLOBAL 关键字的话，每个节点都会单独发起一次对右表的查询，而右表又是分布式表，就导致右表一共会被查询 N²次（N是该分布式表的分片数量），这就是<strong>查询放大</strong>，会带来很大开销。</p>
<h4 id="4-2-6-使用字典表"><a href="#4-2-6-使用字典表" class="headerlink" title="4.2.6 使用字典表"></a><strong>4.2.6</strong> <strong>使用字典表</strong></h4><p>将一些需要关联分析的业务创建成字典表进行 join 操作，前提是字典表不宜太大，因为字典表会常驻内存</p>
<h4 id="4-2-7-提前过滤"><a href="#4-2-7-提前过滤" class="headerlink" title="4.2.7 提前过滤"></a><strong>4.2.7</strong> <strong>提前过滤</strong></h4><p>通过增加逻辑过滤可以减少数据扫描，达到提高执行速度及降低内存消耗的目的</p>
<h2 id="第-5-章-数据一致性（重点）"><a href="#第-5-章-数据一致性（重点）" class="headerlink" title="第 5 章 数据一致性（重点）"></a><strong>第</strong> <strong>5</strong> <strong>章 数据一致性（重点）</strong></h2><p>查询 CK 手册发现，即便对数据一致性支持最好的 Mergetree，也只是保证<strong>最终一致性</strong>：</p>
<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918231654892.png" alt="image-20220918231654892"> </p>
<p>我们在使用 ReplacingMergeTree、SummingMergeTree 这类表引擎的时候，会出现短暂数据不一致的情况。</p>
<p>在某些对一致性非常敏感的场景，通常有以下几种解决方案。</p>
<h3 id="5-1-准备测试表和数据"><a href="#5-1-准备测试表和数据" class="headerlink" title="5.1 准备测试表和数据"></a><strong>5.1</strong> <strong>准备测试表和数据</strong></h3><p><strong>（1）创建表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_a</span><br><span class="line">(</span><br><span class="line">    `user_id` UInt64,</span><br><span class="line">    `score` String,</span><br><span class="line">    `deleted` UInt8 <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    `create_time` DateTime <span class="keyword">DEFAULT</span> toDateTime(<span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>user_id 是数据去重更新的标识；</p>
<p>create_time 是版本号字段，每组数据中 create_time 最大的一行表示最新的数据；</p>
<p>deleted 是自定的一个标记位，比如 0 代表未删除，1 代表删除数据。</p>
<p><strong>（2）写入 1000 万 测试数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score) <span class="keyword">WITH</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>]</span><br><span class="line">    ) <span class="keyword">AS</span> dict</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    number <span class="keyword">AS</span> user_id,</span><br><span class="line">    dict[(number <span class="operator">%</span> <span class="number">7</span>) <span class="operator">+</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10000000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（3）修改前 50 万 行数据，修改内容包括 name 字段和 create_time 版本号字段</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score, create_time) <span class="keyword">WITH</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> [<span class="string">&#x27;AA&#x27;</span>, <span class="string">&#x27;BB&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;DD&#x27;</span>, <span class="string">&#x27;EE&#x27;</span>, <span class="string">&#x27;FF&#x27;</span>, <span class="string">&#x27;GG&#x27;</span>]</span><br><span class="line">    ) <span class="keyword">AS</span> dict</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    number <span class="keyword">AS</span> user_id,</span><br><span class="line">    dict[(number <span class="operator">%</span> <span class="number">7</span>) <span class="operator">+</span> <span class="number">1</span>],</span><br><span class="line">    now() <span class="keyword">AS</span> create_time</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">500000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（4）统计总数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>() <span class="keyword">FROM</span> test_a;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918232130909.png" alt="image-20220918232130909"> </p>
<p>还未触发分区合并，所以还未去重。</p>
<h3 id="5-2-手动-OPTIMIZE"><a href="#5-2-手动-OPTIMIZE" class="headerlink" title="5.2 手动 OPTIMIZE"></a><strong>5.2</strong> <strong>手动</strong> <strong>OPTIMIZE</strong></h3><p>在写入数据后，立刻执行 OPTIMIZE 强制触发新写入分区的合并动作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> test_a <span class="keyword">FINAL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法：OPTIMIZE TABLE [db.]name [ON CLUSTER cluster] [PARTITION partition | PARTITION ID &#x27;partition_id&#x27;] [FINAL] [DEDUPLICATE [BY expression]]</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-通过-Group-by-去重"><a href="#5-3-通过-Group-by-去重" class="headerlink" title="5.3 通过 Group by 去重"></a><strong>5.3</strong> <strong>通过</strong> <strong>Group by</strong> <strong>去重</strong></h3><p><strong>（1）执行去重的查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id,</span><br><span class="line">    argMax(score, create_time) <span class="keyword">AS</span> score,</span><br><span class="line">    argMax(deleted, create_time) <span class="keyword">AS</span> deleted,</span><br><span class="line">    <span class="built_in">max</span>(create_time) <span class="keyword">AS</span> ctime</span><br><span class="line"><span class="keyword">FROM</span> test_a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> deleted <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<ul>
<li>argMax(field1，field2)：按照 field2 的最大值取 field1 的值。</li>
</ul>
<p>当我们更新数据时，会写入一行新的数据，例如上面语句中，通过查询最大的 create_time 得到修改后的 score 字段值。</p>
<p><strong>（2）创建视图，方便测试</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_test_a <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id,</span><br><span class="line">    argMax(score, create_time) <span class="keyword">AS</span> score,</span><br><span class="line">    argMax(deleted, create_time) <span class="keyword">AS</span> deleted,</span><br><span class="line">    <span class="built_in">max</span>(create_time) <span class="keyword">AS</span> ctime</span><br><span class="line"><span class="keyword">FROM</span> test_a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> deleted <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（3）插入重复数据，再次查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 再次插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score, create_time) <span class="keyword">VALUES</span>(<span class="number">0</span>, <span class="string">&#x27;AAAA&#x27;</span>, now());</span><br><span class="line"><span class="comment">-- 再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> view_test_a</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918232722893.png" alt="image-20220918232722893"> </p>
<p><strong>（4）删除数据测试</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 再次插入一条标记为删除的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score, deleted, create_time) <span class="keyword">VALUES</span>(<span class="number">0</span>, <span class="string">&#x27;AAAA&#x27;</span>, <span class="number">1</span>, now()); </span><br><span class="line"><span class="comment">-- 再次查询，刚才那条数据看不到了</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> view_test_a</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918232843982.png" alt="image-20220918232843982"> </p>
<p>这行数据并没有被真正的删除，而是被过滤掉了。在一些合适的场景下，可以结合表级别的 TTL 最终将物理数据删除。</p>
<h3 id="5-4-通过-FINAL-查询"><a href="#5-4-通过-FINAL-查询" class="headerlink" title="5.4 通过 FINAL 查询"></a><strong>5.4</strong> <strong>通过</strong> <strong>FINAL</strong> <strong>查询</strong></h3><p>在查询语句后增加 FINAL 修饰符，这样在查询的过程中将会执行 Merge 的特殊逻辑（例如数据去重，预聚合等）。</p>
<p>但是这种方法在早期版本基本没有人使用，因为在增加 FINAL 之后，我们的查询将会变成一个单线程的执行过程，查询速度非常慢。</p>
<p>在 <strong>v20.5.2.7-stable</strong> 版本中，FINAL 查询支持多线程执行，并且可以通过 <strong>max_final_threads 参数</strong>控制单个查询的线程数。但是目前读取 part 部分的动作依然是串行的。</p>
<p>FINAL 查询最终的性能和很多因素相关，列字段的大小、分区的数量等等都会影响到最终的查询时间，所以还要结合实际场景取舍。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/pull/10463">https://github.com/ClickHouse/ClickHouse/pull/10463</a></p>
<h4 id="5-4-1-测试"><a href="#5-4-1-测试" class="headerlink" title="5.4.1 测试"></a><strong>5.4.1</strong> <strong>测试</strong></h4><p><strong>（1）普通语句查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>查看执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918233420942.png" alt="image-20220918233420942"> </p>
<p>明显将由 2 个线程并行读取 part 查询。</p>
<p><strong>（2）FINAL 查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">FINAL</span></span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_final_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>查询速度没有普通的查询快，但是相比之前已经有了一些提升,查看 FINAL 查询的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">FINAL</span></span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_final_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918233706434.png" alt="image-20220918233706434"> </p>
<p>从 CollapsingSortedTransform 这一步开始已经是多线程执行，但是读取 part 部分的动作还是串行。</p>
<h2 id="第-6-章-物化视图"><a href="#第-6-章-物化视图" class="headerlink" title="第 6 章 物化视图"></a><strong>第</strong> <strong>6</strong> <strong>章 物化视图</strong></h2><p>ClickHouse 的物化视图是一种查询结果的持久化，它确实是给我们带来了查询效率的提升。用户查起来跟表没有区别，它就是一张表，它也像是一张时刻在预计算的表，创建的过程它是用了一个特殊引擎，加上后来 as select，就是 create 一个 table as select 的写法。</p>
<p>“查询结果集”的范围很宽泛，可以是基础表中部分数据的一份简单拷贝，也可以是多表 join 之后产生的结果或其子集，或者原始数据的聚合指标等等。所以，物化视图不会随着基础表的变化而变化，所以它也称为快照（snapshot）</p>
<h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a><strong>6.1</strong> <strong>概述</strong></h3><h4 id="6-1-1-物化视图与普通视图的区别"><a href="#6-1-1-物化视图与普通视图的区别" class="headerlink" title="6.1.1 物化视图与普通视图的区别"></a><strong>6.1.1</strong> <strong>物化视图与普通视图的区别</strong></h4><p><strong>普通视图不保存数据，保存的仅仅是查询语句</strong>，查询的时候还是从原表读取数据，可以将普通视图理解为是个子查询。<strong>物化视图则是把查询的结果根据相应的引擎存入到了磁盘或内存中</strong>，对数据重新进行了组织，你可以理解物化视图是完全的一张新表。</p>
<h4 id="6-1-2-优缺点"><a href="#6-1-2-优缺点" class="headerlink" title="6.1.2 优缺点"></a><strong>6.1.2</strong> <strong>优缺点</strong></h4><p>优点：查询速度<strong>快</strong>，要是把物化视图这些规则全部写好，它比原数据查询快了很多，总的行数少了，因为都预计算好了。</p>
<p>缺点：它的本质是一个流式数据的使用场景，是累加式的技术，所以要用历史数据做去重、去核这样的分析，在物化视图里面是不太好用的。在某些场景的使用也是有限的。而且如果一张表加了好多物化视图，在写这张表的时候，就会消耗很多机器的资源，比如数据带宽占满、存储一下子增加了很多。</p>
<h4 id="6-1-3-基本语法"><a href="#6-1-3-基本语法" class="headerlink" title="6.1.3 基本语法"></a><strong>6.1.3</strong> <strong>基本语法</strong></h4><p>也是 create 语法，会创建一个隐藏的目标表来保存视图数据。也可以 TO 表名，保存到一张显式的表。没有加 TO 表名，表名默认就是 .inner.物化视图名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [MATERIALIZED] <span class="keyword">VIEW</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">TO</span>[db.]name] [ENGINE <span class="operator">=</span> engine] [POPULATE] <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>1）创建物化视图的限制</strong></p>
<p>1.必须指定物化视图的 engine 用于数据存储</p>
<p>2.TO [db].[table]语法的时候，不得使用 POPULATE。</p>
<p>3.查询语句(select）可以包含下面的子句： DISTINCT, GROUP BY, ORDER BY, LIMIT…</p>
<p>4.物化视图的 alter 操作有些限制，操作起来不大方便。</p>
<p>5.若物化视图的定义使用了 TO [db.]name 子语句，则可以将目标表的视图 卸载 DETACH 再装载 ATTACH</p>
<p><strong>2）物化视图的数据更新</strong></p>
<p>（1）物化视图创建好之后，若源表被写入新数据则物化视图也会同步更新</p>
<p>（2）POPULATE 关键字决定了物化视图的更新策略：</p>
<ul>
<li>若有 POPULATE 则在创建视图的过程会将源表已经存在的数据一并导入，类似于 create table … as</li>
<li>若无 POPULATE 则物化视图在创建之后没有数据，只会同步之后写入源表的数据</li>
<li>clickhouse 官方并不推荐使用 POPULATE，因为在创建物化视图的过程中同时写入的数据不能被插入物化视图。</li>
</ul>
<p>（3）物化视图不支持同步删除，若源表的数据不存在（删除了）则物化视图的数据仍然保留</p>
<p>（4）物化视图是一种特殊的数据表，可以用 show tables 查看</p>
<h3 id="6-2-案例实操"><a href="#6-2-案例实操" class="headerlink" title="6.2 案例实操"></a><strong>6.2</strong> <strong>案例实操</strong></h3><p>对于一些确定的数据模型，可将统计指标通过物化视图的方式进行构建，这样可避免查询时重复计算的过程，物化视图会在有新数据插入时进行更新。</p>
<h4 id="6-2-1-准备测试用表和数据"><a href="#6-2-1-准备测试用表和数据" class="headerlink" title="6.2.1 准备测试用表和数据"></a><strong>6.2.1</strong> <strong>准备测试用表和数据</strong></h4><p>1）建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.hits_test</span><br><span class="line">(</span><br><span class="line">    `EventDate` <span class="type">Date</span>,</span><br><span class="line">    `CounterID` UInt32,</span><br><span class="line">    `UserID` UInt64,</span><br><span class="line">    `URL` String,</span><br><span class="line">    `Income` UInt8</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span>;</span><br></pre></td></tr></table></figure>

<p>2）导入一些数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_test <span class="keyword">SELECT</span></span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    UserID,</span><br><span class="line">    URL,</span><br><span class="line">    Income</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">LIMIT <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-创建物化视图"><a href="#6-2-2-创建物化视图" class="headerlink" title="6.2.2 创建物化视图"></a><strong>6.2.2</strong> <strong>创建物化视图</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> datasets.hits_mv</span><br><span class="line">ENGINE <span class="operator">=</span> SummingMergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (EventDate, intHash32(UserID)) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate,</span><br><span class="line">    <span class="built_in">count</span>(URL) <span class="keyword">AS</span> ClickCount,</span><br><span class="line">    <span class="built_in">sum</span>(Income) <span class="keyword">AS</span> IncomeSum</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_test</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&gt;=</span> <span class="string">&#x27;2014-03-20&#x27;</span> <span class="comment">-- 设置更新点,该时间点之前的数据可以另外通过 insert into select …… 的方式进行插入</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 或者可以用下列语法，表 A 可以是一张 mergetree 表</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> 物化视图名 <span class="keyword">TO</span> 表 A</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">FROM</span> 表 B; <span class="comment">-- 不建议添加 populate 关键字进行全量更新</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-3-导入增量数据"><a href="#6-3-3-导入增量数据" class="headerlink" title="6.3.3 导入增量数据"></a><strong>6.3.3</strong> <strong>导入增量数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入增量数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_test <span class="keyword">SELECT</span></span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    UserID,</span><br><span class="line">    URL,</span><br><span class="line">    Income</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&gt;=</span> <span class="string">&#x27;2014-03-23&#x27;</span></span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_mv;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918235343145.png" alt="image-20220918235343145"> </p>
<h4 id="6-3-4-导入历史数据"><a href="#6-3-4-导入历史数据" class="headerlink" title="6.3.4 导入历史数据"></a><strong>6.3.4</strong> <strong>导入历史数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入增量数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_mv <span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate,</span><br><span class="line">    <span class="built_in">count</span>(URL) <span class="keyword">AS</span> ClickCount,</span><br><span class="line">    <span class="built_in">sum</span>(Income) <span class="keyword">AS</span> IncomeSum</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_test</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-20&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate;</span><br><span class="line"><span class="comment">-- 查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_mv;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918235440748.png" alt="image-20220918235440748"> </p>
<h2 id="第-7-章-MaterializeMySQL-引擎"><a href="#第-7-章-MaterializeMySQL-引擎" class="headerlink" title="第 7 章 MaterializeMySQL 引擎"></a><strong>第</strong> <strong>7</strong> <strong>章</strong> <strong>MaterializeMySQL</strong> <strong>引擎</strong></h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a><strong>7.1</strong> <strong>概述</strong></h3><p>MySQL 的用户群体很大，为了能够增强数据的实时性，很多解决方案会利用 binlog 将数据写入到 ClickHouse。为了能够监听 binlog 事件，我们需要用到类似 canal 这样的第三方中间件，这无疑增加了系统的复杂度。</p>
<p>ClickHouse 20.8.2.3 版本新增加了 MaterializeMySQL 的 database 引擎，该 database 能映射到 MySQL 中的某个 database ，并自动在 ClickHouse 中创建对应的ReplacingMergeTree。ClickHouse 服务做为 MySQL 副本，读取 Binlog 并执行 DDL 和 DML 请求，实现了基于 MySQL Binlog 机制的业务数据库实时同步功能。</p>
<h4 id="7-1-1-特点"><a href="#7-1-1-特点" class="headerlink" title="7.1.1 特点"></a><strong>7.1.1</strong> <strong>特点</strong></h4><p>（1）MaterializeMySQL 同时支持<strong>全量</strong>和<strong>增量</strong>同步，在 database 创建之初会全量同步 MySQL 中的表和数据，之后则会通过 binlog 进行增量同步。</p>
<p>（2）MaterializeMySQL database 为其所创建的每张 ReplacingMergeTree 自动增加了 _sign 和 _version 字段。</p>
<p>其中，_version 用作 ReplacingMergeTree 的 ver 版本参数，每当监听到 insert、update 和 delete 事件时，在 databse 内全局自增。而 _sign 则用于标记是否被删除，取值 1 或者 -1。</p>
<p>目前 MaterializeMySQL 支持如下几种 binlog 事件：</p>
<ul>
<li>MYSQL_WRITE_ROWS_EVENT： _sign &#x3D; 1，_version ++</li>
<li>MYSQL_DELETE_ROWS_EVENT： _sign &#x3D; -1，_version ++</li>
<li>MYSQL_UPDATE_ROWS_EVENT：新数据 _sign &#x3D; 1</li>
<li>MYSQL_QUERY_EVENT：支持 CREATE TABLE 、DROP TABLE 、RENAME TABLE 等。</li>
</ul>
<h4 id="7-1-2-使用细则"><a href="#7-1-2-使用细则" class="headerlink" title="7.1.2 使用细则"></a><strong>7.1.2</strong> <strong>使用细则</strong></h4><p><strong>（1）DDL 查询</strong></p>
<p>MySQL DDL 查询被转换成相应的 ClickHouse DDL 查询（ALTER, CREATE, DROP, RENAME）。如果 ClickHouse 不能解析某些 DDL 查询，该查询将被忽略。</p>
<p><strong>（2）数据复制</strong></p>
<p>MaterializeMySQL 不支持直接插入、删除和更新查询，而是将 DDL 语句进行相应转换：</p>
<p>MySQL INSERT 查询被转换为 INSERT with _sign&#x3D;1。</p>
<p>MySQL DELETE 查询被转换为 INSERT with _sign&#x3D;-1。</p>
<p>MySQL UPDATE 查询被转换成 INSERT with _sign&#x3D;1 和 INSERT with _sign&#x3D;-1。</p>
<p><strong>（3）SELECT 查询</strong></p>
<p>如果在 SELECT 查询中没有指定_version，则使用 FINAL 修饰符，返回_version 的最大值对应的数据，即最新版本的数据。</p>
<p>如果在 SELECT 查询中没有指定_sign，则默认使用 WHERE _sign&#x3D;1，即返回未删除状态（_sign&#x3D;1)的数据。</p>
<p><strong>（4）索引转换</strong></p>
<p>ClickHouse 数据库表会自动将 MySQL 主键和索引子句转换为 ORDER BY 元组。</p>
<p>ClickHouse 只有一个物理顺序，由 ORDER BY 子句决定。如果需要创建新的物理顺序，请使用物化视图。</p>
<h3 id="7-2-案例实操"><a href="#7-2-案例实操" class="headerlink" title="7.2 案例实操"></a><strong>7.2</strong> <strong>案例实操</strong></h3><h4 id="7-2-1-MySQL-开启-binlog-和-GTID-模式"><a href="#7-2-1-MySQL-开启-binlog-和-GTID-模式" class="headerlink" title="7.2.1 MySQL 开启 binlog 和 GTID 模式"></a><strong>7.2.1 MySQL</strong> <strong>开启</strong> <strong>binlog</strong> <strong>和</strong> <strong>GTID</strong> <strong>模式</strong></h4><p><strong>（1）确保 MySQL 开启了 binlog 功能，且格式为 ROW</strong></p>
<p>打开&#x2F;etc&#x2F;my.cnf，在[mysqld]下添加：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id=1 </span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure>

<p><strong>（2）开启 GTID 模式</strong></p>
<p>如果如果 clickhouse 使用的是 20.8 prestable 之后发布的版本，那么 MySQL 还需要配置开启 GTID 模式, 这种方式在 mysql 主从模式下可以确保数据同步的一致性(主从切换时)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=1 # 设置为主从强一致性</span><br><span class="line">log-slave-updates=1 # 记录日志</span><br></pre></td></tr></table></figure>

<p>GTID 是 MySQL 复制增强版，从 MySQL 5.6 版本开始支持，目前已经是 MySQL 主流复制模式。它为每个 event 分配一个全局唯一 ID 和序号，我们可以不用关心 MySQL 集群主从拓扑结构，直接告知 MySQL 这个 GTID 即可。</p>
<p><strong>（3）启用旧的加密方式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_authentication_plugin=mysql_native_password</span><br></pre></td></tr></table></figure>

<p><strong>（4）重启 MySQL</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-准备-MySQL-表和数据"><a href="#7-2-2-准备-MySQL-表和数据" class="headerlink" title="7.2.2 准备 MySQL 表和数据"></a><strong>7.2.2</strong> <strong>准备</strong> <strong>MySQL</strong> <strong>表和数据</strong></h4><p><strong>（1）在 MySQL 中创建数据表并写入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE testck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `testck`.`t_organization` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `code` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `name` text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `updatetime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> <span class="keyword">UNIQUE</span> KEY (`code`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, name,updatetime) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1000</span>,<span class="string">&#x27;Realinsight&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, name,updatetime) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;Realindex&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, name,updatetime) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1002</span>,<span class="string">&#x27;EDT&#x27;</span>,NOW());</span><br></pre></td></tr></table></figure>

<p><strong>（2）创建第二张表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `testck`.`t_user` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `code` <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_user (code) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="7-2-3-开启-ClickHouse-物化引擎"><a href="#7-2-3-开启-ClickHouse-物化引擎" class="headerlink" title="7.2.3 开启 ClickHouse 物化引擎"></a><strong>7.2.3</strong> <strong>开启</strong> <strong>ClickHouse</strong> <strong>物化引擎</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> allow_experimental_database_materialize_mysql <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-4-创建复制管道"><a href="#7-2-4-创建复制管道" class="headerlink" title="7.2.4 创建复制管道"></a><strong>7.2.4</strong> <strong>创建复制管道</strong></h4><p>（1）ClickHouse 中创建 MaterializeMySQL 数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_binlog</span><br><span class="line">ENGINE <span class="operator">=</span> MaterializeMySQL(<span class="string">&#x27;hadoop102:3306&#x27;</span>, <span class="string">&#x27;testck&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;abc123&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其中 4 个参数分别是 MySQL 地址、databse、username 和 password。 </p>
<p>（2）查看 ClickHouse 的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE test_binlog;</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919012323650.png" alt="image-20220919012323650"> </p>
<h4 id="7-2-5-修改数据"><a href="#7-2-5-修改数据" class="headerlink" title="7.2.5 修改数据"></a><strong>7.2.5</strong> <strong>修改数据</strong></h4><p>（1）在 MySQL 中修改数据:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_organization <span class="keyword">SET</span> name <span class="operator">=</span> CONCAT(name,<span class="string">&#x27;-v1&#x27;</span>) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>（2）查看 clickhouse 日志可以看到 binlog 监听事件，查询 clickhouse</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919015123209.png" alt="image-20220919015123209"> </p>
<h4 id="7-2-6-删除数据"><a href="#7-2-6-删除数据" class="headerlink" title="7.2.6 删除数据"></a><strong>7.2.6</strong> <strong>删除数据</strong></h4><p>（1）MySQL 删除数据:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_organization <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>（2）ClicKHouse，日志有 DeleteRows 的 binlog 监听事件，查看数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br></pre></td></tr></table></figure>

<p>（3）在刚才的查询中增加 _sign 和 _version 虚拟字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">*</span>,</span><br><span class="line">    _sign,</span><br><span class="line">    _version</span><br><span class="line"><span class="keyword">FROM</span> t_organization</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    _sign <span class="keyword">DESC</span>,</span><br><span class="line">    _version <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919015340982.png" alt="image-20220919015340982"> </p>
<p>在查询时，对于已经被删除的数据，_sign&#x3D;-1，ClickHouse 会自动重写 SQL，将 _sign &#x3D; -1 的数据过滤掉;</p>
<p>对于修改的数据，则自动重写 SQL，为其增加 FINAL 修饰符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br><span class="line"><span class="comment">-- 等同于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization <span class="keyword">FINAL</span> <span class="keyword">WHERE</span> _sign <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-7-删除表"><a href="#7-2-7-删除表" class="headerlink" title="7.2.7 删除表"></a><strong>7.2.7</strong> <strong>删除表</strong></h4><p>（1）在 mysql 执行删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t_user;</span><br></pre></td></tr></table></figure>

<p>（2）此时在 clickhouse 处会同步删除对应表，如果查询会报错</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user;</span><br><span class="line"><span class="comment">-- Code: 60. DB::Exception: Received from localhost:9000. DB::Exception: Table test_binlog.t_user doesn&#x27;t exist. </span></span><br></pre></td></tr></table></figure>

<p>（3）mysql 新建表，clickhouse 可以查询到</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `testck`.`t_user` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `code` <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_user (code) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ClickHouse 查询</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user;</span><br></pre></td></tr></table></figure>

<h2 id="第-8-章-常见问题排查"><a href="#第-8-章-常见问题排查" class="headerlink" title="第 8 章 常见问题排查"></a><strong>第</strong> <strong>8</strong> <strong>章 常见问题排查</strong></h2><h3 id="8-1-分布式-DDL-某数据节点的副本不执行"><a href="#8-1-分布式-DDL-某数据节点的副本不执行" class="headerlink" title="8.1 分布式 DDL 某数据节点的副本不执行"></a><strong>8.1</strong> <strong>分布式</strong> <strong>DDL</strong> <strong>某数据节点的副本不执行</strong></h3><p><strong>（1）问题：</strong>使用分布式 ddl 执行命令 create table on cluster xxxx 某个节点上没有创建表，但是 client 返回正常，查看日志有如下报错。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Error&gt; xxx.xxx: Retrying createReplica(), because some other replicas were created at the same time</span><br></pre></td></tr></table></figure>

<p><strong>（2）解决办法：</strong>重启该不执行的节点。</p>
<h3 id="8-2-数据副本表和数据不一致"><a href="#8-2-数据副本表和数据不一致" class="headerlink" title="8.2 数据副本表和数据不一致"></a><strong>8.2</strong> <strong>数据副本表和数据不一致</strong></h3><p><strong>（1）问题：</strong>由于某个数据节点副本异常，导致两数据副本表不一致，某个数据副本缺少表，需要将两个数据副本调整一致。</p>
<p><strong>（2）解决办法：</strong></p>
<p>在缺少表的数据副本节点上创建缺少的表，创建为本地表，表结构可以在其他数据副本通过 show crete table xxxx 获取。</p>
<p>表结构创建后，clickhouse 会自动从其他副本同步该表数据，验证数据量是否一致即可。</p>
<h3 id="8-3-副本节点全量恢复"><a href="#8-3-副本节点全量恢复" class="headerlink" title="8.3 副本节点全量恢复"></a><strong>8.3</strong> <strong>副本节点全量恢复</strong></h3><p><strong>（1）问题：</strong>某个数据副本异常无法启动，需要重新搭建副本。</p>
<p><strong>（2）解决办法：</strong></p>
<p>清空异常副本节点的 metadata 和 data 目录。</p>
<p>从另一个正常副本将 metadata 目录拷贝过来（这一步之后可以启动数据库，但是只有表结构没有数据）。</p>
<p>执行<code>sudo -u clickhouse touch /data/clickhouse/flags/force_restore_data</code></p>
<p>启动数据库。</p>
<h3 id="8-4-数据副本启动缺少-zk-表"><a href="#8-4-数据副本启动缺少-zk-表" class="headerlink" title="8.4 数据副本启动缺少 zk 表"></a><strong>8.4</strong> <strong>数据副本启动缺少</strong> <strong>zk</strong> <strong>表</strong></h3><p><strong>（1）问题：</strong>某个数据副本表在 zk 上丢失数据，或者不存在，但是 metadata 元数据里存在，导致启动异常，报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can’t get data for node /clickhouse/tables/01-02/xxxxx/xxxxxxx/replicas/xxx/metadata: node doesn’t exist (No node): Cannot attach table xxxxxxx</span><br></pre></td></tr></table></figure>

<p><strong>（2）解决办法：</strong></p>
<p>metadata 中移除该表的结构文件，如果多个表报错都移除</p>
<p>mv metadata&#x2F;xxxxxx&#x2F;xxxxxxxx.sql &#x2F;tmp&#x2F;</p>
<p>启动数据库</p>
<p>手工创建缺少的表，表结构从其他节点 show create table 获取。</p>
<p>创建后会自动同步数据，验证数据是否一致。</p>
<h3 id="8-5-ZK-table-replicas-数据未删除，导致重建表报错"><a href="#8-5-ZK-table-replicas-数据未删除，导致重建表报错" class="headerlink" title="8.5 ZK table replicas 数据未删除，导致重建表报错"></a><strong>8.5 ZK table replicas 数据未删除，导致重建表报错</strong></h3><p><strong>（1）问题：</strong>重建表过程中，先使用 drop table xxx on cluster xxx，各节点在 clickhouse 上 table 已物理删除，但是 zk 里面针对某个 clickhouse 节点的 table meta 信息未被删除（低概率事件），因 zk 里仍存在该表的 meta 信息，导致再次创建该表 create table xxx on cluster, 该节点无法创建表(其他节点创建表成功)，报错：</p>
<p>Replica &#x2F;clickhouse&#x2F;tables&#x2F;01-03&#x2F;xxxxxx&#x2F;xxx&#x2F;replicas&#x2F;xxx already exists..</p>
<p><strong>（2）解决办法：</strong></p>
<p>从其他数据副本 cp 该 table 的 metadata sql 过来。</p>
<p>重启节点。</p>
<h3 id="8-6-Clickhouse-节点意外关闭"><a href="#8-6-Clickhouse-节点意外关闭" class="headerlink" title="8.6 Clickhouse 节点意外关闭"></a><strong>8.6 Clickhouse</strong> <strong>节点意外关闭</strong></h3><p><strong>（1）问题：</strong>模拟其中一个节点意外宕机，在大量 insert 数据的情况下，关闭某个节点。</p>
<p><strong>（2）现象：</strong>数据写入不受影响、数据查询不受影响、建表 DDL 执行到异常节点会卡住，报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code: 159. DB::Exception: Received from localhost:9000. DB::Exception: Watching task /clickhouse/task_queue/ddl/query-0000565925 is executing longer than distributed_ddl_task_timeout (=180) seconds. There are 1 unfinished hosts (0 of them are currently active), they are going to execute the query in background.</span><br></pre></td></tr></table></figure>

<p><strong>（3）解决办法：</strong>启动异常节点，期间其他副本写入数据会自动同步过来，其他副本的建表 DDL 也会同步。</p>
<h3 id="8-7-其他问题参考"><a href="#8-7-其他问题参考" class="headerlink" title="8.7 其他问题参考"></a><strong>8.7</strong> <strong>其他问题参考</strong></h3><p><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/162815.html?spm=a2c4g.11186623.6.652.312e79bd17U8IO">https://help.aliyun.com/document_detail/162815.html?spm=a2c4g.11186623.6.652.312e79bd17U8IO</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yh411z7os?spm_id_from=333.999.0.0">一套上手ClickHouse-OLAP分析引擎，囊括Prometheus与Grafana</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/intro/">ClickHouse 官方文档</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://peninsula1.gitee.io">jiangnan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://peninsula1.gitee.io/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/">http://peninsula1.gitee.io/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ClickHouse/">ClickHouse</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/12/hive/" title="hive入门学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">hive入门学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/11/HDFS%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/" title="HDFS入门学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">HDFS入门学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jiangnan</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B-ClickHouse"><span class="toc-number">1.</span> <span class="toc-text">大数据技术之 ClickHouse</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%85%A5%E9%97%A8%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">第一部分 入门篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-ClickHouse-%E5%85%A5%E9%97%A8"><span class="toc-number">2.1.</span> <span class="toc-text">第 1 章 ClickHouse 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-ClickHouse-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 ClickHouse 的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1.1.1 列式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-DBMS-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">1.1.2 DBMS 的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E5%A4%9A%E6%A0%B7%E5%8C%96%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">1.1.3 多样化引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E9%AB%98%E5%90%9E%E5%90%90%E5%86%99%E5%85%A5%E8%83%BD%E5%8A%9B"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">1.1.4 高吞吐写入能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">1.1.5 数据分区与线程级并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-6-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">1.1.6 性能对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-ClickHouse-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">第 2 章 ClickHouse 的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E7%A1%AE%E5%AE%9A%E9%98%B2%E7%81%AB%E5%A2%99%E5%A4%84%E4%BA%8E%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2.1.1 确定防火墙处于关闭状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-CentOS-%E5%8F%96%E6%B6%88%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2.1.2 CentOS 取消打开文件数限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">2.1.3 安装依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-CentOS-%E5%8F%96%E6%B6%88-SELINUX"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">2.1.4 CentOS 取消 SELINUX</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 单机安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%9C%A8-x2F-opt-x2F-software-%E4%B8%8B%E5%88%9B%E5%BB%BA-clickhouse-%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.2.1 在 &#x2F;opt&#x2F;software 下创建 clickhouse 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%B0%86-ClickHouse-%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0-clickhouse-%E7%9B%AE%E5%BD%95%E4%B8%8B"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2.2 将 ClickHouse 安装文件上传到 clickhouse 目录下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.2.3 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">2.2.4 修改配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E5%90%AF%E5%8A%A8-Server"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">2.2.5 启动 Server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E5%85%B3%E9%97%AD%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">2.2.6 关闭开机自启（可选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-%E4%BD%BF%E7%94%A8-client-%E8%BF%9E%E6%8E%A5-server"><span class="toc-number">2.2.2.7.</span> <span class="toc-text">2.2.7 使用 client 连接 server</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">第 3 章 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B4%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 布尔型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Decimal-%E5%9E%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 Decimal 型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.6.</span> <span class="toc-text">3.6 枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.7.</span> <span class="toc-text">3.7 时间类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.8.</span> <span class="toc-text">3.8 数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E8%A1%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.4.</span> <span class="toc-text">第 4 章 表引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%A1%A8%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 表引擎的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-TinyLog"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 TinyLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Memory"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-MergeTree"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.4 MergeTree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-partition-by-%E5%88%86%E5%8C%BA-%E5%8F%AF%E9%80%89"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">4.4.1 partition by 分区(可选)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-primary-key-%E4%B8%BB%E9%94%AE-%E5%8F%AF%E9%80%89"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">4.4.2 primary key 主键(可选)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-order-by%EF%BC%88%E5%BF%85%E9%80%89%EF%BC%89"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">4.4.3 order by（必选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">4.4.4 二级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-%E6%95%B0%E6%8D%AE-TTL"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">4.4.5 数据 TTL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-ReplacingMergeTree"><span class="toc-number">2.4.5.</span> <span class="toc-text">4.5 ReplacingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-SummingMergeTree"><span class="toc-number">2.4.6.</span> <span class="toc-text">4.6 SummingMergeTree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-SQL-%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.</span> <span class="toc-text">第 5 章 SQL 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Insert"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 Insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Update-%E5%92%8C-Delete"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 Update 和 Delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3 查询操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-alter-%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.4.</span> <span class="toc-text">5.4 alter 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.5.5.</span> <span class="toc-text">5.5 导出数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E5%89%AF%E6%9C%AC"><span class="toc-number">2.6.</span> <span class="toc-text">第 6 章 副本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%89%AF%E6%9C%AC%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1 副本写入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2 配置步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">2.7.</span> <span class="toc-text">第 7 章 分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%9B%86%E7%BE%A4%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%EF%BC%883-%E5%88%86%E7%89%87-2-%E5%89%AF%E6%9C%AC%E5%85%B1-6-%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">2.7.1.</span> <span class="toc-text">7.1 集群写入流程（3 分片 2 副本共 6 个节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%EF%BC%883-%E5%88%86%E7%89%87-2-%E5%89%AF%E6%9C%AC%E5%85%B1-6-%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">2.7.2.</span> <span class="toc-text">7.2 集群读取流程（3 分片 2 副本共 6 个节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E5%88%86%E7%89%87-2-%E5%89%AF%E6%9C%AC%E5%85%B1-6-%E4%B8%AA%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BE%9B%E5%8F%82%E8%80%83%EF%BC%89"><span class="toc-number">2.7.3.</span> <span class="toc-text">7.3 3 分片 2 副本共 6 个节点集群配置（供参考）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%85%8D%E7%BD%AE%E4%B8%89%E8%8A%82%E7%82%B9%E7%89%88%E6%9C%AC%E9%9B%86%E7%BE%A4%E5%8F%8A%E5%89%AF%E6%9C%AC"><span class="toc-number">2.7.4.</span> <span class="toc-text">7.4 配置三节点版本集群及副本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E9%9B%86%E7%BE%A4%E5%8F%8A%E5%89%AF%E6%9C%AC%E8%A7%84%E5%88%92%EF%BC%882-%E4%B8%AA%E5%88%86%E7%89%87%EF%BC%8C%E5%8F%AA%E6%9C%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%88%86%E7%89%87%E6%9C%89%E5%89%AF%E6%9C%AC%EF%BC%89"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">7.4.1 集群及副本规划（2 个分片，只有第一个分片有副本）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">7.4.2 配置步骤</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">第二部分 高级篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-Explain-%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">3.1.</span> <span class="toc-text">第 1 章 Explain 查看执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 案例实操</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%BD%BF%E7%94%A8-EXPLAIN"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1.2.1 使用 EXPLAIN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E5%BB%BA%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">第 2 章 建表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%97%B6%E9%97%B4%E5%AD%97%E6%AE%B5%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">2.1.1 时间字段的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E7%A9%BA%E5%80%BC%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">2.1.2 空值存储类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%86%E5%8C%BA%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 分区和索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%A1%A8%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 表参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 写入和删除优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.5 常见配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-CPU-%E8%B5%84%E6%BA%90"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">2.5.1 CPU 资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">2.5.2 内存资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">2.5.3 存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-ClickHouse-%E8%AF%AD%E6%B3%95%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">第 3 章 ClickHouse 语法优化规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E6%B5%8B%E8%AF%95%E7%94%A8%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 准备测试用表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-COUNT-%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 COUNT 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B6%88%E9%99%A4%E5%AD%90%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 消除子查询重复字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%B0%93%E8%AF%8D%E4%B8%8B%E6%8E%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 谓词下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%81%9A%E5%90%88%E8%AE%A1%E7%AE%97%E5%A4%96%E6%8E%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.5 聚合计算外推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%B6%88%E9%99%A4"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.6 聚合函数消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-order-by-key"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.7 删除重复的 order by key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-limit-by-key"><span class="toc-number">3.3.8.</span> <span class="toc-text">3.8 删除重复的 limit by key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-USING-Key"><span class="toc-number">3.3.9.</span> <span class="toc-text">3.9 删除重复的 USING Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.3.10.</span> <span class="toc-text">3.10 标量替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.11.</span> <span class="toc-text">3.11 三元运算优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">第 4 章 查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 单表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-Prewhere-%E6%9B%BF%E4%BB%A3-where"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">4.1.1 Prewhere 替代 where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">4.1.2 数据采样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E5%88%97%E8%A3%81%E5%89%AA%E4%B8%8E%E5%88%86%E5%8C%BA%E8%A3%81%E5%89%AA"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">4.1.3 列裁剪与分区裁剪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-orderby-%E7%BB%93%E5%90%88-where%E3%80%81limit"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">4.1.4 orderby 结合 where、limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-%E9%81%BF%E5%85%8D%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%88%97"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">4.1.5 避免构建虚拟列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6-uniqCombined-%E6%9B%BF%E4%BB%A3-distinct"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">4.1.6 uniqCombined 替代 distinct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-7-%E4%BD%BF%E7%94%A8%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">3.4.1.7.</span> <span class="toc-text">4.1.7 使用物化视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-8-%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.1.8.</span> <span class="toc-text">4.1.8 其他注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2 多表关联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%87%86%E5%A4%87%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">4.2.1 准备表和数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%94%A8-IN-%E4%BB%A3%E6%9B%BF-JOIN"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">4.2.2 用 IN 代替 JOIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%A4%A7%E5%B0%8F%E8%A1%A8-JOIN"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">4.2.3 大小表 JOIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%B3%A8%E6%84%8F%E8%B0%93%E8%AF%8D%E4%B8%8B%E6%8E%A8%EF%BC%88%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%EF%BC%89"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">4.2.4 注意谓词下推（版本差异）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E4%BD%BF%E7%94%A8-GLOBAL"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">4.2.5 分布式表使用 GLOBAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E8%A1%A8"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">4.2.6 使用字典表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-%E6%8F%90%E5%89%8D%E8%BF%87%E6%BB%A4"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">4.2.7 提前过滤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">第 5 章 数据一致性（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%87%86%E5%A4%87%E6%B5%8B%E8%AF%95%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1 准备测试表和数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%89%8B%E5%8A%A8-OPTIMIZE"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2 手动 OPTIMIZE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%9A%E8%BF%87-Group-by-%E5%8E%BB%E9%87%8D"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3 通过 Group by 去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E9%80%9A%E8%BF%87-FINAL-%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.4.</span> <span class="toc-text">5.4 通过 FINAL 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E6%B5%8B%E8%AF%95"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">5.4.1 测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.</span> <span class="toc-text">第 6 章 物化视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">6.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%99%AE%E9%80%9A%E8%A7%86%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">6.1.1 物化视图与普通视图的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">6.1.2 优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">6.1.3 基本语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">3.6.2.</span> <span class="toc-text">6.2 案例实操</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E5%87%86%E5%A4%87%E6%B5%8B%E8%AF%95%E7%94%A8%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">6.2.1 准备测试用表和数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%88%9B%E5%BB%BA%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">6.2.2 创建物化视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%AF%BC%E5%85%A5%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">6.3.3 导入增量数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E5%AF%BC%E5%85%A5%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">6.3.4 导入历史数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-MaterializeMySQL-%E5%BC%95%E6%93%8E"><span class="toc-number">3.7.</span> <span class="toc-text">第 7 章 MaterializeMySQL 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">7.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E7%89%B9%E7%82%B9"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">7.1.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E4%BD%BF%E7%94%A8%E7%BB%86%E5%88%99"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">7.1.2 使用细则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">3.7.2.</span> <span class="toc-text">7.2 案例实操</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-MySQL-%E5%BC%80%E5%90%AF-binlog-%E5%92%8C-GTID-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">7.2.1 MySQL 开启 binlog 和 GTID 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E5%87%86%E5%A4%87-MySQL-%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">7.2.2 准备 MySQL 表和数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E5%BC%80%E5%90%AF-ClickHouse-%E7%89%A9%E5%8C%96%E5%BC%95%E6%93%8E"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">7.2.3 开启 ClickHouse 物化引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-%E5%88%9B%E5%BB%BA%E5%A4%8D%E5%88%B6%E7%AE%A1%E9%81%93"><span class="toc-number">3.7.2.4.</span> <span class="toc-text">7.2.4 创建复制管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.7.2.5.</span> <span class="toc-text">7.2.5 修改数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-6-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">3.7.2.6.</span> <span class="toc-text">7.2.6 删除数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-7-%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="toc-number">3.7.2.7.</span> <span class="toc-text">7.2.7 删除表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">3.8.</span> <span class="toc-text">第 8 章 常见问题排查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%88%86%E5%B8%83%E5%BC%8F-DDL-%E6%9F%90%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E7%9A%84%E5%89%AF%E6%9C%AC%E4%B8%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">3.8.1.</span> <span class="toc-text">8.1 分布式 DDL 某数据节点的副本不执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">3.8.2.</span> <span class="toc-text">8.2 数据副本表和数据不一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%89%AF%E6%9C%AC%E8%8A%82%E7%82%B9%E5%85%A8%E9%87%8F%E6%81%A2%E5%A4%8D"><span class="toc-number">3.8.3.</span> <span class="toc-text">8.3 副本节点全量恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC%E5%90%AF%E5%8A%A8%E7%BC%BA%E5%B0%91-zk-%E8%A1%A8"><span class="toc-number">3.8.4.</span> <span class="toc-text">8.4 数据副本启动缺少 zk 表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-ZK-table-replicas-%E6%95%B0%E6%8D%AE%E6%9C%AA%E5%88%A0%E9%99%A4%EF%BC%8C%E5%AF%BC%E8%87%B4%E9%87%8D%E5%BB%BA%E8%A1%A8%E6%8A%A5%E9%94%99"><span class="toc-number">3.8.5.</span> <span class="toc-text">8.5 ZK table replicas 数据未删除，导致重建表报错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-Clickhouse-%E8%8A%82%E7%82%B9%E6%84%8F%E5%A4%96%E5%85%B3%E9%97%AD"><span class="toc-number">3.8.6.</span> <span class="toc-text">8.6 Clickhouse 节点意外关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E5%8F%82%E8%80%83"><span class="toc-number">3.8.7.</span> <span class="toc-text">8.7 其他问题参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/25/clickHouse%E5%88%86%E5%B8%83%E5%BC%8Fin%E5%92%8Cjoin/" title="ck的global in和join">ck的global in和join</a><time datetime="2023-02-25T04:53:42.000Z" title="Created 2023-02-25 12:53:42">2023-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/12/hive/" title="hive入门学习">hive入门学习</a><time datetime="2023-02-11T16:11:46.000Z" title="Created 2023-02-12 00:11:46">2023-02-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/" title="大数据技术之ClickHouse">大数据技术之ClickHouse</a><time datetime="2023-02-11T03:00:57.000Z" title="Created 2023-02-11 11:00:57">2023-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/11/HDFS%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/" title="HDFS入门学习">HDFS入门学习</a><time datetime="2023-02-10T16:11:46.000Z" title="Created 2023-02-11 00:11:46">2023-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/11/YARN%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/" title="YARN入门学习">YARN入门学习</a><time datetime="2023-02-10T16:11:46.000Z" title="Created 2023-02-11 00:11:46">2023-02-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By jiangnan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>