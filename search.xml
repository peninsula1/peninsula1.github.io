<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hive入门学习</title>
      <link href="/2023/02/12/hive/"/>
      <url>/2023/02/12/hive/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive简介"><a href="#Hive简介" class="headerlink" title="Hive简介"></a>Hive简介</h1><ul><li>Hive是什么？其体系结构简介</li><li>Hive的安装与管理</li><li>HiveQL数据类型，表以及表的操作</li><li>HiveQL查询数据</li></ul><h3 id="一、什么是Hive"><a href="#一、什么是Hive" class="headerlink" title="一、什么是Hive"></a>一、什么是Hive</h3><ul><li>Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL ），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 QL ，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。</li><li>Hive是SQL解析引擎，它将SQL语句转译成M&#x2F;R Job然后在Hadoop执行。</li><li>Hive的表其实就是HDFS的目录&#x2F;文件夹，按表名把文件夹分开。如果是分区表，则分区值是子文件夹，可以直接在M&#x2F;R Job里使用这些数据。</li><li>总结：<strong>Hive的表对应HDFS的目录（或文件夹）；Hive表中的数据对应HDFS的文件</strong>。</li></ul><h3 id="二、Hive的系统架构-一"><a href="#二、Hive的系统架构-一" class="headerlink" title="二、Hive的系统架构(一)"></a>二、Hive的系统架构(一)</h3><ul><li><img src="https://img-blog.csdnimg.cn/20210618230340710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Nob2NrYW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">用户接口，包括 CLI，JDBC&#x2F;ODBC，WebUI</li><li>元数据存储，通常是存储在关系数据库如 mysql, derby 中</li><li>解释器、编译器、优化器、执行器</li><li>Hadoop：用 HDFS 进行存储，利用 MapReduce 进行计算</li></ul><h3 id="三、Hive的系统架构（二）"><a href="#三、Hive的系统架构（二）" class="headerlink" title="三、Hive的系统架构（二）"></a>三、Hive的系统架构（二）</h3><ul><li>用户接口主要有三个：CLI，JDBC&#x2F;ODBC和 WebUI<ul><li>CLI，即Shell命令行</li><li>JDBC&#x2F;ODBC 是 Hive 的Java，与使用传统数据库JDBC的方式类似</li><li>WebGUI是通过浏览器访问 Hive</li></ul></li><li>Hive 将元数据存储在数据库中(metastore)，目前只支持 mysql、oracle、derby。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等</li><li>解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划（plan）的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行</li><li>Hive 的数据存储在 HDFS 中，大部分的查询由 MapReduce 完成（包含 * 的查询，比如 select * from table 不会生成 MapRedcue 任务）</li></ul><h3 id="四、Hive的运行模式"><a href="#四、Hive的运行模式" class="headerlink" title="四、Hive的运行模式"></a>四、Hive的运行模式</h3><ul><li><p>Hive的运行模式即任务的执行环境</p></li><li><p>分为本地与集群两种</p><ul><li><p>我们可以通过mapred.job.tracker 来指明</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置方式：</span><br><span class="line">hive &gt; SET mapred.job.tracker=<span class="built_in">local</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="五、Hive的启动方式"><a href="#五、Hive的启动方式" class="headerlink" title="五、Hive的启动方式"></a>五、Hive的启动方式</h3><ul><li><p>1、hive 命令行模式，直接输入#&#x2F;hive&#x2F;bin&#x2F;hive的执行程序，或者输入 #hive –service cli</p></li><li><p>2、 hive web界面的 (端口号9999) 启动方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hive --service hwi &amp;</span></span><br><span class="line">用于通过浏览器来访问hive</span><br><span class="line">http://hadoop0:9999/hwi/</span><br></pre></td></tr></table></figure></li><li><p>3、 hive 远程服务 (端口号10000) 启动方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hive --service hiveserver &amp;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="六、Hive与传统数据库"><a href="#六、Hive与传统数据库" class="headerlink" title="六、Hive与传统数据库"></a>六、Hive与传统数据库</h3><table><thead><tr><th>查询语言</th><th>HiveQL</th><th>SQL</th></tr></thead><tbody><tr><td>数据存储位置</td><td>HDFS</td><td>Raw Device or 本地FS</td></tr><tr><td>数据格式</td><td>用户定义</td><td>系统决定</td></tr><tr><td>数据更新</td><td>不支持</td><td>支持</td></tr><tr><td>索引</td><td>新版本有，但弱</td><td>有</td></tr><tr><td>执行</td><td>MapReduce</td><td>Executor</td></tr><tr><td>执行延迟</td><td>高</td><td>低</td></tr><tr><td>可扩展性</td><td>高</td><td>低</td></tr><tr><td>数据规模</td><td>大</td><td>小</td></tr></tbody></table><h3 id="七、Hive的数据类型"><a href="#七、Hive的数据类型" class="headerlink" title="七、Hive的数据类型"></a>七、Hive的数据类型</h3><ul><li><p>基本数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tinyint/smallint/int/bigint</span><br><span class="line">float/double</span><br><span class="line">boolean</span><br><span class="line">string</span><br></pre></td></tr></table></figure></li><li><p>复杂数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array/Map/Struct</span><br><span class="line">日期只有date和timestamp</span><br></pre></td></tr></table></figure></li></ul><h3 id="八、Hive的数据存储"><a href="#八、Hive的数据存储" class="headerlink" title="八、Hive的数据存储"></a>八、Hive的数据存储</h3><ul><li>Hive的数据存储基于Hadoop HDFS</li><li>Hive没有专门的数据存储格式</li><li>存储结构主要包括：数据库、文件、表、视图</li><li>Hive默认可以直接加载文本文件（TextFile），还支持sequence file 、RC file</li><li>创建表时，指定Hive数据的列分隔符与行分隔符，Hive即可解析数据</li></ul><h3 id="九、Hive的数据模型-数据库"><a href="#九、Hive的数据模型-数据库" class="headerlink" title="九、Hive的数据模型-数据库"></a>九、Hive的数据模型-数据库</h3><ul><li><p>类似传统数据库的DataBase</p></li><li><p>默认数据库”default”</p><ul><li>使用#hive命令后，不使用hive&gt;use &lt;数据库名&gt;，系统默认的数据库。可以显式使用hive&gt; use default;</li></ul></li><li><p>创建一个新库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive &gt; create database test_dw;</span><br></pre></td></tr></table></figure></li></ul><h3 id="十、Hive的数据模型-表"><a href="#十、Hive的数据模型-表" class="headerlink" title="十、Hive的数据模型-表"></a>十、Hive的数据模型-表</h3><ul><li>Table 内部表</li><li>Partition 分区表</li><li>External Table 外部表</li><li>Bucket Table 桶表</li></ul><h3 id="十一、Hive的数据模型-内部表"><a href="#十一、Hive的数据模型-内部表" class="headerlink" title="十一、Hive的数据模型-内部表"></a>十一、Hive的数据模型-内部表</h3><ul><li><p>与数据库中的 Table 在概念上是类似</p></li><li><p>每一个 Table 在 Hive 中都有一个相应的目录存储数据。例如，一个表 test，它在 HDFS 中的路径为：&#x2F; warehouse&#x2F;test。 warehouse是在 hive-site.xml 中由 ${hive.metastore.warehouse.dir} 指定的数据仓库的目录</p></li><li><p>所有的 Table 数据（不包括 External Table）都保存在这个目录中。</p></li><li><p>删除表时，元数据与数据都会被删除</p></li><li><p>内部表的使用</p><ul><li><p>创建数据文件inner_table.dat</p></li><li><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;create table inner_table (key string);</span><br></pre></td></tr></table></figure></li><li><p>加载数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;load data local inpath &#x27;/root/inner_table.dat&#x27; into table inner_table;</span><br></pre></td></tr></table></figure></li><li><p>查看数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from inner_table</span><br><span class="line">select count(*) from inner_table</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table inner_table</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="十二、Hive的数据模型-分区表"><a href="#十二、Hive的数据模型-分区表" class="headerlink" title="十二、Hive的数据模型-分区表"></a>十二、Hive的数据模型-分区表</h3><ul><li><p>Partition 对应于数据库的 Partition 列的密集索引</p></li><li><p>在 Hive 中，表中的一个 Partition 对应于表下的一个目录，所有的 Partition 的数据都存储在对应的目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：test表中包含 date 和 city 两个 Partition，</span><br><span class="line">则对应于date=20180729, city = bj 的 HDFS 子目录为：</span><br><span class="line">/warehouse/test/date=20130201/city=bj</span><br><span class="line">对应于date=20180729, city=sh 的HDFS 子目录为；</span><br><span class="line">/warehouse/test/date=20180729/city=sh</span><br></pre></td></tr></table></figure></li><li><p>分区表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp_table #表名</span><br><span class="line">(</span><br><span class="line">title   string, # 字段名称 字段类型</span><br><span class="line">minimum_bid     double,</span><br><span class="line">quantity        bigint,</span><br><span class="line">have_invoice    bigint</span><br><span class="line">)COMMENT &#x27;注释：XXX&#x27; #表注释</span><br><span class="line"> PARTITIONED BY(pt STRING) #分区表字段（如果你文件非常之大的话，采用分区表可以快过滤出按分区字段划分的数据）</span><br><span class="line"> ROW FORMAT DELIMITED </span><br><span class="line">   FIELDS TERMINATED BY &#x27;\001&#x27;   # 字段是用什么分割开的</span><br><span class="line">STORED AS SEQUENCEFILE; #用哪种方式存储数据，SEQUENCEFILE是hadoop自带的文件压缩格式</span><br></pre></td></tr></table></figure></li><li><p>一些相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES; # 查看所有的表</span><br><span class="line">SHOW TABLES &#x27;*TMP*&#x27;; #支持模糊查询</span><br><span class="line">SHOW PARTITIONS TMP_TABLE; #查看表有哪些分区</span><br><span class="line">DESCRIBE TMP_TABLE; #查看表结构</span><br></pre></td></tr></table></figure></li><li><p>分区表的使用</p><ul><li><p>创建数据文件partition_table.dat</p></li><li><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table partition_table(rectime string,msisdn string) partitioned by(daytime string,city string)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27; stored as TEXTFILE;</span><br></pre></td></tr></table></figure></li><li><p>加载数据到分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &#x27;/home/partition_table.dat&#x27; into table partition_table partition</span><br><span class="line">(daytime=&#x27;2013-02-01&#x27;,city=&#x27;bj&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>查看数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from partition_table</span><br><span class="line">select count(*) from partition_table</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table partition_table</span><br></pre></td></tr></table></figure></li><li><p>通过load data 加载数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table partition_table add partition (daytime=&#x27;2018-07-29&#x27;,city=&#x27;bj&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>元数据，数据文件删除，但目录daytime&#x3D;2013-02-04还在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table partition_table drop partition (daytime=&#x27;2018-07-29&#x27;,city=&#x27;bj&#x27;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="十三、Hive的数据模型—桶表"><a href="#十三、Hive的数据模型—桶表" class="headerlink" title="十三、Hive的数据模型—桶表"></a>十三、Hive的数据模型—桶表</h3><ul><li><p>桶表是对数据进行哈希取值，然后放到不同文件中存储。</p></li><li><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table bucket_table(id string) clustered by(id) into 4 buckets;</span><br></pre></td></tr></table></figure></li><li><p>加载数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set hive.enforce.bucketing = true;</span><br><span class="line">insert into table bucket_table select name from stu;</span><br><span class="line">insert overwrite table bucket_table select name from stu;</span><br></pre></td></tr></table></figure></li><li><p>数据加载到桶表时，会对字段取hash值，然后与桶的数量取模。把数据放到对应的文件中。</p></li><li><p>抽样查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from bucket_table tablesample(bucket 1 out of 4 on id);</span><br></pre></td></tr></table></figure></li></ul><h3 id="十四、Hive的数据模型-外部表"><a href="#十四、Hive的数据模型-外部表" class="headerlink" title="十四、Hive的数据模型-外部表"></a>十四、Hive的数据模型-外部表</h3><ul><li><p>指向已经在 HDFS 中存在的数据，可以创建 Partition</p></li><li><p>它和 内部表 在元数据的组织上是相同的，而实际数据的存储则有较大的差异</p></li><li><p>内部表 的创建过程和数据加载过程（这两个过程可以在同一个语句中完成），在加载数据的过程中，实际数据会被移动到数据仓库目录中；之后对数据对访问将会直接在数据仓库目录中完成。删除表时，表中的数据和元数据将会被同时删除</p></li><li><p>外部表 只有一个过程，加载数据和创建表同时完成，并不会移动到数据仓库目录中，只是与外部数据建立一个链接。当删除一个 外部表 时，仅删除该链接</p></li><li><p>外部表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE page_view</span><br><span class="line">( viewTime INT, </span><br><span class="line">  userid BIGINT,</span><br><span class="line">  page_url STRING, </span><br><span class="line"> referrer_url STRING, </span><br><span class="line">  ip STRING COMMENT &#x27;IP Address of the User&#x27;,</span><br><span class="line">  country STRING COMMENT &#x27;country of origination‘</span><br><span class="line">)</span><br><span class="line">    COMMENT &#x27;This is the staging page view table&#x27;</span><br><span class="line">    ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;44&#x27; LINES TERMINATED BY &#x27;12&#x27;</span><br><span class="line">    STORED AS TEXTFILE</span><br><span class="line">    LOCATION &#x27;hdfs://centos:9000/user/data/staging/page_view&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>外部表的使用</p><ul><li><p>创建数据文件external_table.dat</p></li><li><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;create external table external_table1 (key string) ROW FORMAT DELIMITED </span><br><span class="line">                       FIELDS TERMINATED BY &#x27;\t&#x27; location &#x27;/home/external&#x27;;</span><br><span class="line">在HDFS创建目录/home/external</span><br><span class="line">#hadoop fs -put /home/external_table.dat /home/external</span><br></pre></td></tr></table></figure></li><li><p>加载数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INPATH &#x27;/home/external_table1.dat&#x27; INTO TABLE external_table1;</span><br></pre></td></tr></table></figure></li><li><p>查看数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from external_table</span><br><span class="line">select count(*) from external_table</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table external_table</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="十五、视图操作"><a href="#十五、视图操作" class="headerlink" title="十五、视图操作"></a>十五、视图操作</h3><ul><li><p>视图的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW v1 AS select * from t1;</span><br></pre></td></tr></table></figure></li></ul><h3 id="十六、表的操作"><a href="#十六、表的操作" class="headerlink" title="十六、表的操作"></a>十六、表的操作</h3><ul><li><p>表的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table target_tab add columns (cols,string)</span><br></pre></td></tr></table></figure></li><li><p>表的删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table</span><br></pre></td></tr></table></figure></li></ul><h3 id="十七、导入数据"><a href="#十七、导入数据" class="headerlink" title="十七、导入数据"></a>十七、导入数据</h3><ul><li><p>当数据被加载至表中时，不会对数据进行任何转换。Load 操作只是将数据复制&#x2F;移动至 Hive 表对应的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#x27;filepath&#x27; [OVERWRITE]   </span><br><span class="line">      INTO TABLE tablename    </span><br><span class="line">      [PARTITION (partcol1=val1, partcol2=val2 ...)]</span><br></pre></td></tr></table></figure></li><li><p>把一个Hive表导入到另一个已建Hive表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT OVERWRITE TABLE tablename [PARTITION (partcol1=val1, </span><br><span class="line">      partcol2=val2 ...)] select_statement FROM from_statement</span><br></pre></td></tr></table></figure></li><li><p>CTAS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name </span><br><span class="line">   (col_name data_type, ...)…</span><br><span class="line">   AS SELECT …</span><br></pre></td></tr></table></figure></li><li><p>例：create table new_external_test as select * from external_table1;</p></li></ul><h3 id="十八、查询（select）"><a href="#十八、查询（select）" class="headerlink" title="十八、查询（select）"></a>十八、查询（select）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</span><br><span class="line">   FROM table_reference </span><br><span class="line">   [WHERE where_condition] </span><br><span class="line">   [GROUP BY col_list] </span><br><span class="line">   [ CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list] | [ORDER BY col_list] ]</span><br><span class="line">   [LIMIT number]</span><br></pre></td></tr></table></figure><ul><li><p>注：DISTRIBUTE BY 指定分发器（Partitioner）,多Reducer可用</p></li><li><p>基于Partition的查询</p><ul><li><p>一般 SELECT 查询是全表扫描。但如果是分区表，查询就可以利用分区剪枝（input pruning）的特性，类似“分区索引“”，只扫描一个表中它关心的那一部分。Hive 当前的实现是，只有分区断言（Partitioned by）出现在离 FROM 子句最近的那个WHERE 子句中，才会启用分区剪枝。例如，如果 page_views 表（按天分区）使用 date 列分区，以下语句只会读取分区为‘2018-03-01’的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT page_views.*  FROM page_views  WHERE page_views.date &gt;= &#x27;2018-03-01&#x27; </span><br><span class="line">       AND page_views.date &lt;= &#x27;2018-03-01&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>LIMIT Clause</p><ul><li><p>Limit 可以限制查询的记录数。查询的结果是随机选择的。下面的查询语句从 t1 表中随机查询5条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LIMIT 5</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Top N查询</p><ul><li><p>下面的查询语句查询销售记录最大的 5 个销售代表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET mapred.reduce.tasks = 1  </span><br><span class="line">    SELECT * FROM sales SORT BY amount DESC LIMIT 5</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="十九、表连接"><a href="#十九、表连接" class="headerlink" title="十九、表连接"></a>十九、表连接</h3><ul><li><p>导入ac信息表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table acinfo (name string,acip string)  row format </span><br><span class="line">delimited fields terminated by &#x27;\t&#x27; stored as TEXTFILE;</span><br><span class="line">hive&gt; load data local inpath &#x27;/home/acinfo/ac.dat&#x27; into table acinfo; </span><br></pre></td></tr></table></figure></li><li><p>内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select b.name,a.* from dim_ac a join acinfo b on (a.ac=b.acip) limit 10;</span><br></pre></td></tr></table></figure></li><li><p>左外连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select b.name,a.* from dim_ac a left outer join acinfo b on a.ac=b.acip limit 10;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据技术之ClickHouse</title>
      <link href="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/"/>
      <url>/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据技术之-ClickHouse"><a href="#大数据技术之-ClickHouse" class="headerlink" title="大数据技术之 ClickHouse"></a>大数据技术之 ClickHouse</h1><h1 id="第一部分-入门篇"><a href="#第一部分-入门篇" class="headerlink" title="第一部分 入门篇"></a>第一部分 入门篇</h1><h2 id="第-1-章-ClickHouse-入门"><a href="#第-1-章-ClickHouse-入门" class="headerlink" title="第 1 章 ClickHouse 入门"></a>第 1 章 ClickHouse 入门</h2><p>ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的<strong>列式存储数据库</strong>（DBMS），使用 C++ 语言编写，主要用于<strong>在线分析处理查询（OLAP）</strong>，能够使用 SQL 查询实时生成分析数据报告。</p><h3 id="1-1-ClickHouse-的特点"><a href="#1-1-ClickHouse-的特点" class="headerlink" title="1.1 ClickHouse 的特点"></a>1.1 ClickHouse 的特点</h3><h4 id="1-1-1-列式存储"><a href="#1-1-1-列式存储" class="headerlink" title="1.1.1 列式存储"></a>1.1.1 列式存储</h4><p>以下面的表为例：</p><table><thead><tr><th>Id</th><th>Name</th><th>Age</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td></tr><tr><td>2</td><td>李四</td><td>22</td></tr><tr><td>3</td><td>王五</td><td>34</td></tr></tbody></table><p><strong>1）采用行式存储时，数据在磁盘上的组织结构为：</strong></p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906230720766.png" alt="image-20220906230720766"> </p><p>好处是想查某个人所有的属性时，可以通过一次磁盘查找加顺序读取就可以。但是当想查所有人的年龄时，需要不停的查找，或者全表扫描才行，遍历的很多数据都是不需要的。</p><p><strong>2）采用列式存储时，数据在磁盘上的组织结构为：</strong></p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906231304721.png" alt="image-20220906231304721"> </p><p>这时想查所有人的年龄只需把年龄那一列拿出来就可以了</p><p><strong>3）列式储存的好处：</strong></p><ul><li>对于列的聚合，计数，求和等统计操作优于行式存储。</li><li>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列选择更优的数据压缩算法，大大提高了数据的压缩比重。</li><li>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的发挥空间。</li></ul><h4 id="1-1-2-DBMS-的功能"><a href="#1-1-2-DBMS-的功能" class="headerlink" title="1.1.2 DBMS 的功能"></a>1.1.2 DBMS 的功能</h4><p>几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管理及权限管理，数据的备份与恢复。 </p><h4 id="1-1-3-多样化引擎"><a href="#1-1-3-多样化引擎" class="headerlink" title="1.1.3 多样化引擎"></a>1.1.3 多样化引擎</h4><p>ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎。</p><h4 id="1-1-4-高吞吐写入能力"><a href="#1-1-4-高吞吐写入能力" class="headerlink" title="1.1.4 高吞吐写入能力"></a>1.1.4 高吞吐写入能力</h4><p>ClickHouse 采用类 <strong>LSM Tree</strong> 的结构，数据写入后定期在后台 Compaction。通过类 LSM tree 的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台 compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。</p><p>官方公开 benchmark 测试显示能够达到 50MB-200MB&#x2F;s 的写入吞吐能力，按照每行100Byte 估算，大约相当于 50W-200W 条&#x2F;s 的写入速度。</p><h4 id="1-1-5-数据分区与线程级并行"><a href="#1-1-5-数据分区与线程级并行" class="headerlink" title="1.1.5 数据分区与线程级并行"></a>1.1.5 数据分区与线程级并行</h4><p>ClickHouse 将数据划分为多个 partition，每个 partition 再进一步划分为多个 index granularity(索引粒度)，然后通过多个 CPU 核心分别处理其中的一部分来实现并行数据处理。在这种设计下，<strong>单条 Query 就能利用整机所有 CPU。</strong>极致的并行处理能力，极大的降低了查询延时。</p><p>所以，ClickHouse 即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端就是对于单条查询使用较多 cpu，就不利于同时并发多条查询。所以对于高 qps 的查询业务，ClickHouse 并不是强项。</p><h4 id="1-1-6-性能对比"><a href="#1-1-6-性能对比" class="headerlink" title="1.1.6 性能对比"></a>1.1.6 性能对比</h4><p><strong>1）单表查询</strong></p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906232235037.png" alt="image-20220906232235037"> </p><p><strong>2）关联查询</strong></p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906232310852.png" alt="image-20220906232310852"> </p><p>结论: ClickHouse 像很多 OLAP 数据库一样，单表查询速度优于关联查询，而且 ClickHouse 的两者差距更为明显。</p><h2 id="第-2-章-ClickHouse-的安装"><a href="#第-2-章-ClickHouse-的安装" class="headerlink" title="第 2 章 ClickHouse 的安装"></a>第 2 章 ClickHouse 的安装</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-确定防火墙处于关闭状态"><a href="#2-1-1-确定防火墙处于关闭状态" class="headerlink" title="2.1.1 确定防火墙处于关闭状态"></a>2.1.1 确定防火墙处于关闭状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><blockquote><p>注意：生产环境不建议关闭</p></blockquote><h4 id="2-1-2-CentOS-取消打开文件数限制"><a href="#2-1-2-CentOS-取消打开文件数限制" class="headerlink" title="2.1.2 CentOS 取消打开文件数限制"></a>2.1.2 CentOS 取消打开文件数限制</h4><p>（1）查看文件数限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220906234741765.png" alt="image-20220906234741765"> </p><p>（2）在 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件的末尾加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">soft指当前数值，hard指最大数值</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure><p>（3）在 &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nproc.conf 文件的末尾加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure><p>（4）在 &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nofile.conf 文件的末尾加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure><p>（5）重新登录即可生效</p><h4 id="2-1-3-安装依赖"><a href="#2-1-3-安装依赖" class="headerlink" title="2.1.3 安装依赖"></a>2.1.3 安装依赖</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y libtool</span><br><span class="line">sudo yum install -y *unixODBC*</span><br></pre></td></tr></table></figure><h4 id="2-1-4-CentOS-取消-SELINUX"><a href="#2-1-4-CentOS-取消-SELINUX" class="headerlink" title="2.1.4 CentOS 取消 SELINUX"></a>2.1.4 CentOS 取消 SELINUX</h4><p>（1）修改&#x2F;etc&#x2F;selinux&#x2F;config 中的 SELINUX&#x3D;disabled</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>（2）临时关闭 SELINUX</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看SELINUX状态</span></span><br><span class="line">getenforce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭SELINUX</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h3 id="2-2-单机安装"><a href="#2-2-单机安装" class="headerlink" title="2.2 单机安装"></a>2.2 单机安装</h3><p>官方网址：<a href="https://clickhouse.com/">https://clickhouse.com/</a></p><p>下载地址：<a href="https://packages.clickhouse.com/rpm/stable/">https://packages.clickhouse.com/rpm/stable/</a></p><h4 id="2-2-1-在-x2F-opt-x2F-software-下创建-clickhouse-目录"><a href="#2-2-1-在-x2F-opt-x2F-software-下创建-clickhouse-目录" class="headerlink" title="2.2.1 在 &#x2F;opt&#x2F;software 下创建 clickhouse 目录"></a>2.2.1 在 &#x2F;opt&#x2F;software 下创建 clickhouse 目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/software/</span><br><span class="line">mkdir clickhouse</span><br></pre></td></tr></table></figure><h4 id="2-2-2-将-ClickHouse-安装文件上传到-clickhouse-目录下"><a href="#2-2-2-将-ClickHouse-安装文件上传到-clickhouse-目录下" class="headerlink" title="2.2.2 将 ClickHouse 安装文件上传到 clickhouse 目录下"></a>2.2.2 将 ClickHouse 安装文件上传到 clickhouse 目录下</h4><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220907010745802.png" alt="image-20220907010745802"> </p><h4 id="2-2-3-安装"><a href="#2-2-3-安装" class="headerlink" title="2.2.3 安装"></a>2.2.3 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">sudo rpm -ivh *.rpm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看安装情况</span></span><br><span class="line">sudo rpm -qa|grep clickhouse</span><br></pre></td></tr></table></figure><h4 id="2-2-4-修改配置文件"><a href="#2-2-4-修改配置文件" class="headerlink" title="2.2.4 修改配置文件"></a>2.2.4 修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/clickhouse-server/config.xml</span><br></pre></td></tr></table></figure><p>（1）把 <strong><listen_host>::</listen_host></strong> 的注释打开，这样的话才能让 ClickHouse 被除本机以外的服务器访问</p><blockquote><p>注意：生产环境可以配置指定的IP进行访问</p></blockquote><p>（2）默认的路径配置</p><p>数据文件路径：<code>&lt;path&gt;/&lt;/path&gt;</code></p><p>日志文件路径：<code>&lt;log&gt;/var/log/clickhouse-server/clickhouse-server.log&lt;/log&gt;</code></p><h4 id="2-2-5-启动-Server"><a href="#2-2-5-启动-Server" class="headerlink" title="2.2.5 启动 Server"></a>2.2.5 启动 Server</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start clickhouse-server</span><br></pre></td></tr></table></figure><h4 id="2-2-6-关闭开机自启（可选）"><a href="#2-2-6-关闭开机自启（可选）" class="headerlink" title="2.2.6 关闭开机自启（可选）"></a>2.2.6 关闭开机自启（可选）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable clickhouse-server</span><br></pre></td></tr></table></figure><h4 id="2-2-7-使用-client-连接-server"><a href="#2-2-7-使用-client-连接-server" class="headerlink" title="2.2.7 使用 client 连接 server"></a><strong>2.2.7</strong> <strong>使用</strong> <strong>client</strong> <strong>连接</strong> <strong>server</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client -m [--password]</span><br></pre></td></tr></table></figure><h2 id="第-3-章-数据类型"><a href="#第-3-章-数据类型" class="headerlink" title="第 3 章 数据类型"></a><strong>第</strong> <strong>3</strong> <strong>章 数据类型</strong></h2><h3 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a><strong>3.1</strong> <strong>整型</strong></h3><p>固定长度的整型，包括有符号整型或无符号整型。</p><p>整型范围（-2n-1~2n-1-1）：</p><p>Int8 - [-128 : 127]</p><p>Int16 - [-32768 : 32767]</p><p>Int32 - [-2147483648 : 2147483647]</p><p>Int64 - [-9223372036854775808 : 9223372036854775807]</p><p>无符号整型范围（0~2n-1）：</p><p>UInt8 - [0 : 255]</p><p>UInt16 - [0 : 65535]</p><p>UInt32 - [0 : 4294967295]</p><p>UInt64 - [0 : 18446744073709551615]</p><h3 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a><strong>3.2</strong> <strong>浮点型</strong></h3><p>Float32 - float</p><p>Float64 – double</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908212753988.png" alt="image-20220908212753988"> </p><blockquote><p>注意：浮点型在进行计算时可能会引起四舍五入的误差。</p></blockquote><h3 id="3-3-布尔型"><a href="#3-3-布尔型" class="headerlink" title="3.3 布尔型"></a><strong>3.3</strong> <strong>布尔型</strong></h3><p>没有单独的类型来存储布尔值。可以使用 UInt8 类型，取值限制为 0 或 1。</p><h3 id="3-4-Decimal-型"><a href="#3-4-Decimal-型" class="headerlink" title="3.4 Decimal 型"></a><strong>3.4 Decimal</strong> <strong>型</strong></h3><p>有符号的浮点数，可在加、减和乘法运算过程中保持精度。对于除法，最低有效数字会被丢弃（不舍入）。</p><p>有三种声明：</p><ul><li>Decimal32(s)，相当于 Decimal(9-s, s)，有效位数为 1~9</li><li>Decimal64(s)，相当于 Decimal(18-s, s)，有效位数为 1~18</li><li>Decimal128(s)，相当于 Decimal(38-s, s)，有效位数为 1~38</li></ul><p><strong>s 标识小数位</strong></p><h3 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a><strong>3.5</strong> <strong>字符串</strong></h3><p><strong>1）String</strong></p><p>字符串可以任意长度的。它可以包含任意的字节集，包含空字节。</p><p><strong>2）FixedString(N)</strong></p><p>固定长度 N 的字符串，N 必须是严格的正自然数。当服务端读取长度小于 N 的字符串时候，通过在字符串末尾添加空字节来达到 N 字节长度。 当服务端读取长度大于 N 的字符串时候，将返回错误消息。</p><p>与 String 相比，极少会使用 FixedString，因为使用起来不是很方便。</p><h3 id="3-6-枚举类型"><a href="#3-6-枚举类型" class="headerlink" title="3.6 枚举类型"></a><strong>3.6</strong> <strong>枚举类型</strong></h3><p>包括 Enum8 和 Enum16 类型。Enum 保存 ‘string’&#x3D; integer 的对应关系。</p><p>Enum8 用 ‘String’&#x3D; Int8 对描述。</p><p>Enum16 用 ‘String’&#x3D; Int16 对描述。</p><p><strong>1）用法演示</strong></p><p>创建一个带有一个枚举 Enum8(‘hello’ &#x3D; 1, ‘world’ &#x3D; 2) 类型的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_enum</span><br><span class="line">(</span><br><span class="line">    `x` Enum8(<span class="string">&#x27;hello&#x27;</span> <span class="operator">=</span> <span class="number">1</span>, <span class="string">&#x27;world&#x27;</span> <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> TinyLog;</span><br></pre></td></tr></table></figure><p><strong>2）这个 x 列只能存储类型定义中列出的值：’hello’或’world’</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_enum <span class="keyword">VALUES</span> (<span class="string">&#x27;hello&#x27;</span>), (<span class="string">&#x27;world&#x27;</span>), (<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908213812152.png" alt="image-20220908213812152"> </p><p><strong>3）如果尝试保存任何其他值，ClickHouse 抛出异常</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_enum <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214102455.png" alt="image-20220908214102455"> </p><p><strong>4）如果需要看到对应行的数值，则必须将 Enum 值转换为整数类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(x, <span class="string">&#x27;Int8&#x27;</span>) <span class="keyword">FROM</span> t_enum;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214245932.png" alt="image-20220908214245932"> </p><h3 id="3-7-时间类型"><a href="#3-7-时间类型" class="headerlink" title="3.7 时间类型"></a><strong>3.7</strong> <strong>时间类型</strong></h3><p>目前 ClickHouse 有三种时间类型</p><ul><li>Date 接受<strong>年-月-日</strong>的字符串比如 ‘2019-12-16’</li><li>Datetime 接受<strong>年-月-日 时:分:秒</strong>的字符串比如 ‘2019-12-16 20:50:10’ </li><li>Datetime64 接受<strong>年-月-日 时:分:秒.亚秒</strong>的字符串比如 ‘2019-12-16 20:50:10.66’</li></ul><p>日期类型，用两个字节存储，表示从 1970-01-01 (无符号) 到当前的日期值。</p><h3 id="3-8-数组"><a href="#3-8-数组" class="headerlink" title="3.8 数组"></a><strong>3.8</strong> <strong>数组</strong></h3><p><strong>Array(T)：</strong>由 T 类型元素组成的数组。</p><p>T 可以是任意类型，包含数组类型。但不推荐使用多维数组，ClickHouse 对多维数组的支持有限。例如，不能在 MergeTree 表中存储多维数组。</p><p>（1）创建数组方式 1，使用 array 函数</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214714506.png" alt="image-20220908214714506"> </p><p>（2）创建数组方式 2：使用方括号</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908214753599.png" alt="image-20220908214753599"> </p><h2 id="第-4-章-表引擎"><a href="#第-4-章-表引擎" class="headerlink" title="第 4 章 表引擎"></a><strong>第</strong> <strong>4</strong> <strong>章 表引擎</strong></h2><h3 id="4-1-表引擎的使用"><a href="#4-1-表引擎的使用" class="headerlink" title="4.1 表引擎的使用"></a><strong>4.1</strong> <strong>表引擎的使用</strong></h3><p>表引擎是 ClickHouse 的一大特色。可以说，表引擎决定了如何存储表的数据。包括：</p><ul><li>数据的存储方式和位置，写到哪里以及从哪里读取数据。</li><li>支持哪些查询以及如何支持。</li><li>并发数据访问。</li><li>索引的使用（如果存在）。</li><li>是否可以执行多线程请求。</li><li>数据复制参数。</li></ul><p>表引擎的使用方式就是必须显式在创建表时定义该表使用的引擎，以及引擎使用的相关参数。</p><blockquote><p>特别注意：引擎的名称大小写敏感</p></blockquote><h3 id="4-2-TinyLog"><a href="#4-2-TinyLog" class="headerlink" title="4.2 TinyLog"></a><strong>4.2 TinyLog</strong></h3><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表，生产环境上作用有限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_tinylog</span><br><span class="line">(</span><br><span class="line">    `id` String,</span><br><span class="line">    `name` String</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> TinyLog;</span><br></pre></td></tr></table></figure><h3 id="4-3-Memory"><a href="#4-3-Memory" class="headerlink" title="4.3 Memory"></a><strong>4.3 Memory</strong></h3><p>内存引擎，数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失。读写操作不会相互阻塞，不支持索引。简单查询下有非常非常高的性能表现（<strong>超过 10G&#x2F;s</strong>）。</p><h3 id="4-4-MergeTree"><a href="#4-4-MergeTree" class="headerlink" title="4.4 MergeTree"></a><strong>4.4 MergeTree</strong></h3><p>ClickHouse 中<strong>最强大的表引擎</strong>当属 MergeTree（合并树）引擎及该系列（*MergeTree）中的其他引擎，<strong>支持索引和分区</strong>，地位可以相当于 innodb 之于 Mysql。</p><p><strong>1）建表语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p><strong>2）插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">12000.00</span>,<span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>MergeTree 其实还有很多参数(绝大多数用默认值即可)，但是这三个参数是更加重要的，也涉及了关于 MergeTree 的很多概念。</p><h4 id="4-4-1-partition-by-分区-可选"><a href="#4-4-1-partition-by-分区-可选" class="headerlink" title="4.4.1 partition by 分区(可选)"></a><strong>4.4.1 partition by</strong> <strong>分区(可选)</strong></h4><p><strong>1）作用</strong></p><p>分区的目的主要是降低扫描的范围，优化查询速度</p><p><strong>2）如果不填</strong></p><p>只会使用一个分区。</p><p><strong>3）分区目录</strong></p><p>MergeTree 是以列文件+索引文件+表定义文件组成的，但是如果设定了分区那么这些文件就会保存到不同的分区目录中。</p><p>分区目录文件命名规则：PartitionId_MinBlockNum_MaxBlockNum_Level（分区值_最小分区_最大分区块编号_合并层级）</p><ul><li>PartitionId：<ul><li>数据分区 ID 生成规则</li><li>数据分区规则由分区 ID 决定，分区ID由 PARTITION BY 分区键决定。根据分区键字段类型，ID生成规则可以分为：<ul><li>未定义分区键：没有定义 PARTITION BY ，默认生成一个目录名为 all 的数据分区，所有数据均存放在 all 目录下。</li><li>整型分区键：分区键为整型，那么直接用该整型值的字符串形式作为分区ID。</li><li>日期类分区键：分区键为日期类型，或者可以转化成日期类型。</li><li>其他类型分区键：String、Float 类型等，通过128位的 Hash 算法取其 Hash 值作为分区ID。</li></ul></li></ul></li><li>MinBlockNum：最小分区块编号，自增类型，从1开始向上递增。每产生一个新的目录分区就向上递增一个数字。</li><li>MaxBlockNum：最大分区块编号，新创建的分区 MinBlockNum 等于 MaxBlockNum 的编号。</li><li>Level：合并的层级，被合并的次数。合并次数越多，层级值越大。</li></ul><p><strong>4）并行</strong></p><p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p><p><strong>5）数据写入与分区合并</strong></p><p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作（等不及也可以手动通过 optimize 执行），把临时分区的数据，合并到已有分区中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> xxxx <span class="keyword">FINAL</span>;</span><br><span class="line"># 只针对某一个分区做合并操作</span><br><span class="line">OPTIMIZE <span class="keyword">TABLE</span> xxxx <span class="keyword">PARTITION</span> <span class="string">&#x27;yyyy&#x27;</span> <span class="keyword">FINAL</span>;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-primary-key-主键-可选"><a href="#4-4-2-primary-key-主键-可选" class="headerlink" title="4.4.2 primary key 主键(可选)"></a>4.4.2 primary key 主键(可选)</h4><p>ClickHouse 中的主键，和其他数据库不太一样，<strong>它只提供了数据的一级索引，但是却不是唯一约束。</strong>这就意味着是可以存在相同 primary key 的数据的。</p><p>主键的设定主要依据是查询语句中的 where 条件。</p><p>根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity，避免了全表扫描。</p><p>index granularity：直接翻译的话就是索引粒度，指在<strong>稀疏索引</strong>中两个相邻索引对应数据的间隔。ClickHouse 中的 MergeTree 默认是 8192。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p><p><strong>稀疏索引：</strong></p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220908224603867.png" alt="image-20220908224603867"> </p><p>稀疏索引的好处就是可以用很少的索引数据，定位更多的数据，代价就是只能定位到索引粒度的第一行，然后再进行进行一点扫描。</p><h4 id="4-4-3-order-by（必选）"><a href="#4-4-3-order-by（必选）" class="headerlink" title="4.4.3 order by（必选）"></a><strong>4.4.3 order by（必选）</strong></h4><p>order by 设定了<strong>分区内</strong>的数据按照哪些字段顺序进行有序保存。</p><p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不设置主键的情况，很多处理会依照 order by 的字段进行处理。</p><p><strong>要求：主键必须是 order by 字段的前缀字段。</strong></p><p>比如 order by 字段是 (id, sku_id) 那么主键必须是 id 或者(id, sku_id)</p><h4 id="4-4-4-二级索引"><a href="#4-4-4-二级索引" class="headerlink" title="4.4.4 二级索引"></a><strong>4.4.4</strong> <strong>二级索引</strong></h4><p>目前在 ClickHouse 的官网上二级索引的功能在 <strong>v20.1.2.4</strong> 之前是被标注为实验性的，在这个版本之后默认是开启的。 </p><p><strong>1）老版本使用二级索引前需要增加设置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set allow_experimental_data_skipping_indices=1;</span><br></pre></td></tr></table></figure><p><strong>2）创建测试表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime,</span><br><span class="line">    INDEX a total_amount TYPE minmax GRANULARITY <span class="number">5</span></span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>其中 GRANULARITY N 是设定二级索引对于一级索引粒度的粒度。</p><p><strong>3）插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt2 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_004&#x27;</span>, <span class="number">2500.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">12000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">600.00</span>, <span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>4）对比效果</strong></p><p>使用下面语句进行测试，可以看出二级索引能够为非主键字段的查询发挥作用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --send_logs_level=trace &lt;&lt;&lt; &#x27;select * from t_order_mt2 where total_amount &gt; toDecimal32(900., 2)&#x27;;</span><br></pre></td></tr></table></figure><h4 id="4-4-5-数据-TTL"><a href="#4-4-5-数据-TTL" class="headerlink" title="4.4.5 数据 TTL"></a>4.4.5 数据 TTL</h4><p>TTL 即 Time To Live，MergeTree 提供了可以管理数据表或者列的<strong>生命周期</strong>的功能。</p><p><strong>1）列级别 TTL</strong></p><p>（1）创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt3</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>) TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>,</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>（2）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt3 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">106</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, NOW()),</span><br><span class="line">(<span class="number">107</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, NOW()),</span><br><span class="line">(<span class="number">110</span>, <span class="string">&#x27;sku_003&#x27;</span>, <span class="number">600.00</span>, NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>);</span><br></pre></td></tr></table></figure><p>（3）<strong>手动合并</strong>，查看效果，到期后，指定的字段数据将变为默认值</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909002325459.png" alt="image-20220909002325459"> </p><blockquote><p>官方文档：When the values in the column expire, ClickHouse replaces them with the default values for the column data type. If all the column values in the data part expire, ClickHouse deletes this column from the data part in a filesystem.</p><p>但是实际测试下来，每个分区的最新的一条或多条数据不会被删除，原因未知。</p></blockquote><p><strong>2）表级 TTL</strong></p><p>下面的这条语句是数据会在 create_time 之后 10 秒丢失</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_mt3 MODIFY TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span>;</span><br></pre></td></tr></table></figure><p>涉及判断的字段必须是 Date 或者 Datetime 类型，推荐使用分区的日期字段。</p><p>能够使用的时间周期：</p><ul><li>SECOND</li><li>MINUTE</li><li>HOUR</li><li>DAY</li><li>WEEK</li><li>MONTH</li><li>QUARTER</li><li>YEAR</li></ul><h3 id="4-5-ReplacingMergeTree"><a href="#4-5-ReplacingMergeTree" class="headerlink" title="4.5 ReplacingMergeTree"></a>4.5 ReplacingMergeTree</h3><p>ReplacingMergeTree 是 MergeTree 的一个变种，它存储特性完全继承 MergeTree，只是多了一个去重的功能。 尽管 MergeTree 可以设置主键，但是 primary key 其实没有唯一约束的功能。如果你想处理掉重复的数据，可以借助这个 ReplacingMergeTree。</p><p><strong>1）去重时机</strong></p><p><strong>数据的去重只会在合并的过程中出现。</strong>合并会在未知的时间在后台进行，所以你无法预先作出计划。有一些数据可能仍未被处理。</p><p><strong>2）去重范围</strong></p><p><strong>如果表经过了分区，去重只会在分区内部进行去重，不能执行跨分区的去重。</strong></p><p>所以 ReplacingMergeTree 能力有限， ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</p><p><strong>3）案例演示</strong></p><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rmt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p><strong>ReplacingMergeTree() 填入的参数为版本字段，重复数据保留版本字段值最大的。</strong></p><p><strong>如果不填版本字段，默认按照插入顺序保留最后一条。</strong> </p><p>（2）向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_rmt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_004&#x27;</span>, <span class="number">2500.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">12000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">600.00</span>, <span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（3）重复再插入一次，执行第一次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_rmt;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909003504730.png" alt="image-20220909003504730"> </p><p>（4）手动合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> t_order_rmt <span class="keyword">FINAL</span>;</span><br></pre></td></tr></table></figure><p>（5）再执行一次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_rmt;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909003530398.png" alt="image-20220909003530398"> </p><p><strong>4）通过测试得到结论</strong></p><ul><li>实际上是使用 order by 字段作为唯一键</li><li>去重不能跨分区</li><li>只有同一批插入（新版本）或合并分区时才会进行去重</li><li>认定重复的数据保留，取版本字段值最大的</li><li>如果版本字段相同则按插入顺序保留最后一笔</li></ul><h3 id="4-6-SummingMergeTree"><a href="#4-6-SummingMergeTree" class="headerlink" title="4.6 SummingMergeTree"></a><strong>4.6 SummingMergeTree</strong></h3><p>对于不查询明细，只关心以维度进行汇总聚合结果的场景。如果只使用普通的MergeTree的话，无论是存储空间的开销，还是查询时临时聚合的开销都比较大。</p><p>ClickHouse 为了这种场景，提供了一种能够“预聚合”的引擎 SummingMergeTree</p><p><strong>1）案例演示</strong></p><p>（1）创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_smt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> SummingMergeTree(total_amount)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>（2）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_smt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;sku_001&#x27;</span>, <span class="number">1000.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_004&#x27;</span>, <span class="number">2500.00</span>, <span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">2000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">12000.00</span>, <span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;sku_002&#x27;</span>, <span class="number">600.00</span>, <span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（3）重复再插入一次，执行第一次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_smt;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909004038208.png" alt="image-20220909004038208">  </p><p>（4）手动合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> t_order_smt <span class="keyword">FINAL</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220909004121096.png" alt="image-20220909004121096"> </p><p><strong>2）通过结果可以得到以下结论</strong></p><ul><li>以 SummingMergeTree（）中指定的列作为汇总数据列 </li><li>可以填写多列必须数字列，如果不填，以所有非维度列且为数字列的字段为汇总数据列</li><li>以 order by 的列为准，作为维度列</li><li>其他的列按插入顺序保留第一行</li><li>不在一个分区的数据不会被聚合</li><li>只有在同一批次插入（新版本）或分片合并时才会进行聚合</li></ul><p><strong>3）开发建议</strong></p><p>设计聚合表的话，唯一键值、流水号可以去掉，所有字段全部是维度、度量或者时间戳。</p><p><strong>4）问题</strong></p><p>能不能直接执行以下 SQL 得到汇总值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> total_amount <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> province_name <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">AND</span> create_date <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><p>不行，<strong>可能会包含一些还没来得及聚合的临时明细</strong></p><p>如果要是获取汇总值，还是需要使用 sum 进行聚合，这样效率会有一定的提高，但本身 ClickHouse 是列式存储的，效率提升有限，不会特别明显。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total_amount) <span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> province_name <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">AND</span> create_date <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="第-5-章-SQL-操作"><a href="#第-5-章-SQL-操作" class="headerlink" title="第 5 章 SQL 操作"></a><strong>第</strong> <strong>5</strong> <strong>章</strong> <strong>SQL</strong> <strong>操作</strong></h2><p>基本上来说传统关系型数据库（以 MySQL 为例）的 SQL 语句，ClickHouse 基本都支持，这里只介绍 ClickHouse 与标准 SQL（MySQL）不一致的地方。</p><h3 id="5-1-Insert"><a href="#5-1-Insert" class="headerlink" title="5.1 Insert"></a><strong>5.1 Insert</strong></h3><p>与标准 SQL（MySQL）基本一致</p><p>（1）标准</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [table_name] <span class="keyword">VALUES</span> (...), (...)</span><br></pre></td></tr></table></figure><p>（2）从表到表的插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [table_name] <span class="keyword">SELECT</span> a,b,c <span class="keyword">FROM</span> [table_name_2]</span><br></pre></td></tr></table></figure><h3 id="5-2-Update-和-Delete"><a href="#5-2-Update-和-Delete" class="headerlink" title="5.2 Update 和 Delete"></a><strong>5.2 Update</strong> <strong>和</strong> <strong>Delete</strong></h3><p>ClickHouse 提供了 Delete 和 Update 的能力，这类操作被称为 Mutation 查询，它可以看做 Alter 的一种。</p><p>虽然可以实现修改和删除，但是和一般的 OLTP 数据库不一样，<strong>Mutation</strong> <strong>语句是一种很“重”的操作，而且不支持事务。</strong></p><p>“重”的原因主要是每次修改或者删除都会导致放弃目标数据的原有分区，重建新分区。所以尽量做批量的变更，不要进行频繁小数据的操作。</p><p>（1）删除操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_smt <span class="keyword">DELETE</span> <span class="keyword">WHERE</span> sku_id <span class="operator">=</span> <span class="string">&#x27;sku_001&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）修改操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_smt <span class="keyword">UPDATE</span> total_amount <span class="operator">=</span> toDecimal32(<span class="number">2000.00</span>, <span class="number">2</span>) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">102</span>;</span><br></pre></td></tr></table></figure><p>由于操作比较“重”，所以 Mutation 语句分两步执行，同步执行的部分其实只是进行新增数据新增分区和并把旧分区打上逻辑上的失效标记。直到触发分区合并的时候，才会删除旧数据释放磁盘空间，一般不会开放这样的功能给用户，由管理员完成。</p><p><strong>问题：如何实现高性能 update 和 delete ？</strong></p><p>回答：在创建表时，添加两个标记字段，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A</span><br><span class="line">(</span><br><span class="line">a xxx,</span><br><span class="line">    b xxx,</span><br><span class="line">    c xxx,</span><br><span class="line">    _sign UInt8,</span><br><span class="line">    _version UInt32</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么，对于更新操作，则相当于是插入一条新的数据，此时 _version + 1，查询的时候加上一个过滤条件（WHERE  _version最大）进行查询。</p><p>对于删除操作，通过 _sign（0表示未删除，1表示已删除），同时 _version + 1，查询的时候加上一个过滤条件（WHERE _sign &#x3D; 0 AND _version最大）进行查询。</p><p><strong>那么如果时间久了，数据膨胀了怎么办？</strong>可以提供类似合并的机制，定期把过期数据进行清除。</p><h3 id="5-3-查询操作"><a href="#5-3-查询操作" class="headerlink" title="5.3 查询操作"></a><strong>5.3</strong> <strong>查询操作</strong></h3><p>ClickHouse 基本上与标准 SQL 差别不大</p><ul><li>支持子查询</li><li>支持 CTE(Common Table Expression 公用表表达式 with 子句) </li><li>支持各种 JOIN，但是 JOIN 操作无法使用缓存，所以即使是两次相同的 JOIN 语句，ClickHouse 也会视为两条新 SQL</li><li>支持窗口函数</li><li>支持自定义函数</li><li>GROUP BY 操作增加了 with rollup\with cube\with total 用来计算小计和总计。</li></ul><p>（1）插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 清空数据</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_order_mt <span class="keyword">DELETE</span> <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_mt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">103</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">104</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">105</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">106</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">107</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">108</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">109</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-04 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">110</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（2）with rollup：<strong>从右至左去掉维度进行小计</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, sku_id, <span class="built_in">sum</span>(total_amount) <span class="keyword">FROM</span> t_order_mt <span class="keyword">GROUP</span> <span class="keyword">BY</span> id, sku_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912165949176.png" alt="image-20220912165949176"> </p><p>（3）with cube : 从右至左去掉维度进行小计，再从左至右去掉维度进行小计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, sku_id, <span class="built_in">sum</span>(total_amount) <span class="keyword">FROM</span> t_order_mt <span class="keyword">GROUP</span> <span class="keyword">BY</span> id, sku_id <span class="keyword">WITH</span> <span class="keyword">CUBE</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912170136379.png" alt="image-20220912170136379"> </p><p>（4）with totals: 只计算合计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, sku_id, <span class="built_in">sum</span>(total_amount) <span class="keyword">FROM</span> t_order_mt <span class="keyword">GROUP</span> <span class="keyword">BY</span> id, sku_id <span class="keyword">WITH</span> TOTALS;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912170328807.png" alt="image-20220912170328807"> </p><h3 id="5-4-alter-操作"><a href="#5-4-alter-操作" class="headerlink" title="5.4 alter 操作"></a><strong>5.4 alter</strong> <strong>操作</strong></h3><p>同 MySQL 的修改字段基本一致</p><p><strong>1）新增字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> newcolname String AFTER col1;</span><br></pre></td></tr></table></figure><p><strong>2）修改字段类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName MODIFY <span class="keyword">COLUMN</span> newcolname String;</span><br></pre></td></tr></table></figure><p><strong>3）删除字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> newcolname;</span><br></pre></td></tr></table></figure><h3 id="5-5-导出数据"><a href="#5-5-导出数据" class="headerlink" title="5.5 导出数据"></a><strong>5.5 导出数据</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse<span class="operator">-</span>client <span class="comment">--query &quot;select * from t_order_mt where create_time=&#x27;2020-06-01 12:00:00&#x27;&quot; --format CSVWithNames&gt; /opt/module/data/rs1.csv</span></span><br></pre></td></tr></table></figure><p>更多支持格式参考：<a href="https://clickhouse.com/docs/en/interfaces/formats/">https://clickhouse.com/docs/en/interfaces/formats/</a></p><h2 id="第-6-章-副本"><a href="#第-6-章-副本" class="headerlink" title="第 6 章 副本"></a><strong>第</strong> <strong>6</strong> <strong>章 副本</strong></h2><p>副本的目的主要是保障数据的高可用性，即使一台 ClickHouse 节点宕机，那么也可以从其他服务器获得相同的数据。</p><h3 id="6-1-副本写入流程"><a href="#6-1-副本写入流程" class="headerlink" title="6.1 副本写入流程"></a><strong>6.1</strong> <strong>副本写入流程</strong></h3><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912192635581.png" alt="image-20220912192635581"> </p><h3 id="6-2-配置步骤"><a href="#6-2-配置步骤" class="headerlink" title="6.2 配置步骤"></a><strong>6.2</strong> <strong>配置步骤</strong></h3><p>（1）启动 zookeeper 集群</p><p>（2）在 hadoop102 的 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.d 目录下创建一个名为 metrika.xml 的配置文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：也可以不创建外部文件，直接在 config.xml 中指定 <code>&lt;zookeeper&gt;</code></p></blockquote><blockquote><p>提示：这里用三台机器作为集群，分别为hadoop102 、hadoop103 和 hadoop104</p></blockquote><p>（3）同步到 hadoop103 和 hadoop104 上</p><p>（4）在 hadoop102 的&#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml 中增加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zookeeper</span> <span class="attr">incl</span>=<span class="string">&quot;zookeeper-servers&quot;</span> <span class="attr">optional</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include_from</span>&gt;</span>/etc/clickhouse-server/config.d/metrika.xml<span class="tag">&lt;/<span class="name">include_from</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912204716940.png" alt="image-20220912204716940"> </p><p>（5）同步到 hadoop103 和 hadoop104 上，然后分别在 hadoop102、hadoop103 和 hadoop104 上重启 ClickHouse 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure><p>（6）在 hadoop102 和 hadoop103 上分别建表</p><p><strong>副本只能同步数据，不能同步表结构，所以我们需要在每台机器上自己手动建表</strong></p><p>① hadoop102</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rep2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/table/01/t_order_rep&#x27;</span>, <span class="string">&#x27;rep_102&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>② hadoop103</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rep2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/table/01/t_order_rep&#x27;</span>, <span class="string">&#x27;rep_103&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>③ hadoop104</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_rep2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/table/01/t_order_rep&#x27;</span>, <span class="string">&#x27;rep_104&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>在 ReplicatedMergeTree 中，</p><p><strong>第一个参数</strong>是分片的 zk_path 一般按照：&#x2F;clickhouse&#x2F;table&#x2F;{shard}&#x2F;{table_name} 的格式写，如果只有一个分片就写 01 即可。</p><p><strong>第二个参数</strong>是副本名称，<strong>相同的分片副本名称不能相同。</strong></p><p>（7）在 hadoop102 上执行 insert 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_rep2 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">103</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">104</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">105</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（8）在 hadoop103 上执行 select，可以查询出结果，说明副本配置正确</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order_rep2;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912195219517.png" alt="image-20220912195219517"> </p><h2 id="第-7-章-分片集群"><a href="#第-7-章-分片集群" class="headerlink" title="第 7 章 分片集群"></a><strong>第</strong> <strong>7</strong> <strong>章 分片集群</strong></h2><p>副本虽然能够提高数据的可用性，降低丢失风险，但是每台服务器实际上必须容纳全量数据，对数据的<strong>横向扩容</strong>没有解决。</p><p>要解决数据水平切分的问题，需要引入分片的概念。通过分片把一份完整的数据进行切分，不同的分片分布到不同的节点上，再通过 Distributed 表引擎把数据拼接起来一同使用。</p><p><strong>Distributed 表引擎本身不存储数据，</strong>有点类似于 MyCat 之于 MySql，成为一种中间件，通过分布式逻辑表来写入、分发、路由来操作多台节点不同分片的分布式数据。</p><blockquote><p>注意：ClickHouse 的集群是表级别的，实际企业中，大部分做了高可用，但是没有用分片，避免降低查询性能以及操作集群的复杂性。</p></blockquote><h3 id="7-1-集群写入流程（3-分片-2-副本共-6-个节点）"><a href="#7-1-集群写入流程（3-分片-2-副本共-6-个节点）" class="headerlink" title="7.1 集群写入流程（3 分片 2 副本共 6 个节点）"></a><strong>7.1 集群写入流程（3 分片 2 副本共 6 个节点）</strong></h3><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912205654322.png" alt="image-20220912205654322"> </p><h3 id="7-2-集群读取流程（3-分片-2-副本共-6-个节点）"><a href="#7-2-集群读取流程（3-分片-2-副本共-6-个节点）" class="headerlink" title="7.2 集群读取流程（3 分片 2 副本共 6 个节点）"></a><strong>7.2 集群读取流程（3 分片 2 副本共 6 个节点）</strong></h3><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912205722974.png" alt="image-20220912205722974"> </p><h3 id="7-3-3-分片-2-副本共-6-个节点集群配置（供参考）"><a href="#7-3-3-分片-2-副本共-6-个节点集群配置（供参考）" class="headerlink" title="7.3 3 分片 2 副本共 6 个节点集群配置（供参考）"></a>7.3 3 分片 2 副本共 6 个节点集群配置（供参考）</h3><p>配置的位置还是在之前的&#x2F;etc&#x2F;clickhouse-server&#x2F;config.d&#x2F;metrika.xml，内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remote_servers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 集群名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第一个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop101<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第二个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第三个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop105<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop106<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">remote_servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：也可以不创建外部文件，直接在 config.xml 的 <code>&lt;remote_servers&gt;</code> 中指定</p></blockquote><h3 id="7-4-配置三节点版本集群及副本"><a href="#7-4-配置三节点版本集群及副本" class="headerlink" title="7.4 配置三节点版本集群及副本"></a><strong>7.4</strong> <strong>配置三节点版本集群及副本</strong></h3><h4 id="7-4-1-集群及副本规划（2-个分片，只有第一个分片有副本）"><a href="#7-4-1-集群及副本规划（2-个分片，只有第一个分片有副本）" class="headerlink" title="7.4.1 集群及副本规划（2 个分片，只有第一个分片有副本）"></a><strong>7.4.1 集群及副本规划（2 个分片，只有第一个分片有副本）</strong></h4><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912210332486.png" alt="image-20220912210332486"> </p><table><thead><tr><th align="left">hadoop102</th><th align="left">hadoop103</th><th align="left">hadoop104</th></tr></thead><tbody><tr><td align="left"><macros><br>    <shard>01</shard><br><replica>rep_1_1</replica><br></macros></td><td align="left"><macros><br>    <shard>01</shard><br><replica>rep_1_2</replica><br></macros></td><td align="left"><macros><br>    <shard>02</shard><br><replica>rep_2_1</replica><br></macros></td></tr></tbody></table><h4 id="7-4-2-配置步骤"><a href="#7-4-2-配置步骤" class="headerlink" title="7.4.2 配置步骤"></a><strong>7.4.2</strong> <strong>配置步骤</strong></h4><p><strong>1）在 hadoop102 的 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.d 目录下创建 metrika-shard.xml 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remote_servers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 集群名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第一个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第二个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--集群的第二个分片--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该分片的第一个副本--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gmall_cluster</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">remote_servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop104<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">macros</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不同机器放的分片数不一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shard</span>&gt;</span>01<span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不同机器放的副本数不一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">replica</span>&gt;</span>rep_1_1<span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">macros</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：也可以不创建外部文件，直接在 config.xml 的 <code>&lt;remote_servers&gt;</code> 中指定</p></blockquote><p><strong>2）将 hadoop102 的 metrika-shard.xml 同步到 103 和 104</strong></p><p><strong>3）修改 103 和 104 中 metrika-shard.xml 宏的配置</strong></p><p>（1）103</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912211209173.png" alt="image-20220912211209173"> </p><p>（2）104</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912211350373.png" alt="image-20220912211350373"> </p><p><strong>4）在 hadoop102 上修改 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml</strong></p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912211517131.png" alt="image-20220912211517131"> </p><p><strong>5）同步 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml 到 103 和 104</strong></p><p><strong>6）重启三台服务器上的 ClickHouse 服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure><p><strong>7）在 hadoop102 上执行建表语句</strong></p><ul><li>会自动同步到 hadoop103 和 hadoop104 上</li><li>集群名字要和配置文件中的一致</li><li>分片和副本名称从配置文件的宏定义中获取</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> st_order_mt <span class="keyword">ON</span> CLUSTER gmall_cluster</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/tables/&#123;shard&#125;/st_order_mt&#x27;</span>, <span class="string">&#x27;&#123;replica&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>可以到 hadoop103 和 hadoop104 上查看表是否创建成功</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912214352072.png" alt="image-20220912214352072"> </p><p><strong>8）在 hadoop102 上创建 Distribute 分布式表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> st_order_mt_all2 <span class="keyword">ON</span> CLUSTER gmall_cluster</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> Distributed(gmall_cluster, <span class="keyword">default</span>, st_order_mt, hiveHash(sku_id));</span><br></pre></td></tr></table></figure><p><strong>参数含义：</strong></p><p>Distributed（集群名称，库名，本地表名，分片键）</p><p>分片键必须是整型数字，所以用 hiveHash 函数转换，也可以 rand()</p><p><strong>9）在 hadoop102 上插入测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> st_order_mt_all2 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">201</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">202</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">203</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">204</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">205</span>,<span class="string">&#x27;sku_003&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>10）通过查询分布式表和本地表观察输出结果</strong></p><blockquote><p>注意：分布式表管理不同分片时需要知道用户名和密码，如果 clickhouse 的用户设置了密码，则需要在分片配置中添加上密码。</p><p>错误信息：DB::Exception: Received from hadoop104:9000. DB::Exception: default: Authentication failed: password is incorrect or there is no user with such name.                     </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span>&gt;</span>hadoop102<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span>default<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（1）分布式表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> st_order_mt_all2;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215138964.png" alt="image-20220912215138964"> </p><p>（2）本地表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> st_order_mt;</span><br></pre></td></tr></table></figure><p>① hadoop102</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215214139.png" alt="image-20220912215214139"> </p><p>② hadoop103</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215231777.png" alt="image-20220912215231777"> </p><p>③ hadoop104</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220912215308837.png" alt="image-20220912215308837"> </p><h1 id="第二部分-高级篇"><a href="#第二部分-高级篇" class="headerlink" title="第二部分 高级篇"></a>第二部分 高级篇</h1><h2 id="第-1-章-Explain-查看执行计划"><a href="#第-1-章-Explain-查看执行计划" class="headerlink" title="第 1 章 Explain 查看执行计划"></a><strong>第</strong> <strong>1</strong> <strong>章</strong> <strong>Explain</strong> <strong>查看执行计划</strong></h2><p>在 clickhouse 20.6 版本之前要查看 SQL 语句的执行计划需要设置日志级别为 trace 才能可以看到，并且只能真正执行 sql，在执行日志里面查看。在 20.6 版本引入了原生的执行计划的语法。在 20.6.3 版本成为正式版本的功能。</p><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a><strong>1.1</strong> <strong>基本语法</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN [AST <span class="operator">|</span> SYNTAX <span class="operator">|</span> PLAN <span class="operator">|</span> PIPELINE] [setting <span class="operator">=</span> <span class="keyword">value</span>, ...] </span><br><span class="line"><span class="keyword">SELECT</span> ... [FORMAT ...]</span><br></pre></td></tr></table></figure><ul><li>PLAN：用于查看执行计划，默认值。<ul><li>header：打印计划中各个步骤的 head 说明，默认关闭，默认值 0;</li><li>description：打印计划中各个步骤的描述，默认开启，默认值 1；</li><li>actions：打印计划中各个步骤的详细信息，默认关闭，默认值 0。</li></ul></li><li>AST：用于查看语法树; </li><li>SYNTAX：用于查看优化语法; </li><li>PIPELINE：用于查看 PIPELINE 计划。 <ul><li>header：打印计划中各个步骤的 head 说明，默认关闭; </li><li>graph：用 DOT 图形语言描述管道图，默认关闭，需要查看相关的图形需要配合 graphviz 查看；</li><li>actions：如果开启了 graph，紧凑打印打，默认开启。</li></ul></li></ul><h3 id="1-2-案例实操"><a href="#1-2-案例实操" class="headerlink" title="1.2 案例实操"></a><strong>1.2</strong> <strong>案例实操</strong></h3><h4 id="1-2-1-使用-EXPLAIN"><a href="#1-2-1-使用-EXPLAIN" class="headerlink" title="1.2.1 使用 EXPLAIN"></a><strong>1.2.1</strong> <strong>使用</strong> <strong>EXPLAIN</strong></h4><p>1）查看 PLAN</p><p>简单查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PLAN <span class="keyword">SELECT</span> arrayJoin([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>]);</span><br></pre></td></tr></table></figure><p>复杂 SQL 的执行计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> database, <span class="keyword">table</span>, <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> system.parts <span class="keyword">WHERE</span> database <span class="keyword">IN</span> (<span class="string">&#x27;datasets&#x27;</span>, <span class="string">&#x27;system&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> database, <span class="keyword">table</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> database <span class="keyword">ASC</span>, cnt <span class="keyword">DESC</span> LIMIT <span class="number">2</span> <span class="keyword">BY</span> database;</span><br></pre></td></tr></table></figure><p>打开全部的参数的执行计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN header <span class="operator">=</span> <span class="number">1</span>, actions <span class="operator">=</span> <span class="number">1</span>, description <span class="operator">=</span> <span class="number">1</span> <span class="keyword">SELECT</span> number <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>2）AST 语法树</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN AST <span class="keyword">SELECT</span> number <span class="keyword">FROM</span> system.numbers LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>3）SYNTAX 语法优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先做一次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 查看语法优化</span></span><br><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 开启三元运算符优化</span></span><br><span class="line"><span class="keyword">SET</span> optimize_if_chain_to_multiif <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 再次查看语法优化</span></span><br><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918101624402.png" alt="image-20220918101624402"> </p><p>4）查看 PIPELINE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE <span class="keyword">SELECT</span> <span class="built_in">sum</span>(number) <span class="keyword">FROM</span> numbers_mt(<span class="number">100000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> number <span class="operator">%</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 打开其他参数</span></span><br><span class="line">EXPLAIN PIPELINE header <span class="operator">=</span> <span class="number">1</span>, graph <span class="operator">=</span> <span class="number">1</span> <span class="keyword">SELECT</span> <span class="built_in">sum</span>(number) <span class="keyword">FROM</span> numbers_mt(<span class="number">10000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> number <span class="operator">%</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h2 id="第-2-章-建表优化"><a href="#第-2-章-建表优化" class="headerlink" title="第 2 章 建表优化"></a><strong>第</strong> <strong>2</strong> <strong>章 建表优化</strong></h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a><strong>2.1</strong> <strong>数据类型</strong></h3><h4 id="2-1-1-时间字段的类型"><a href="#2-1-1-时间字段的类型" class="headerlink" title="2.1.1 时间字段的类型"></a><strong>2.1.1</strong> <strong>时间字段的类型</strong></h4><p>建表时能用数值型或日期时间型表示的字段就不要用字符串，全 String 类型在以 Hive 为中心的数仓建设中常见，但 ClickHouse 环境不应受此影响。</p><p>虽然 ClickHouse 底层将 DateTime 存储为时间戳 Long 类型，但不建议存储 Long 类型，<strong>因为 DateTime 不需要经过函数转换处理，执行效率高、可读性好。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_type2</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Int32</span><br><span class="line">) ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(toDate(create_time)) <span class="comment">-- 需要转换一次，否则报错</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><h4 id="2-1-2-空值存储类型"><a href="#2-1-2-空值存储类型" class="headerlink" title="2.1.2 空值存储类型"></a><strong>2.1.2</strong> <strong>空值存储类型</strong></h4><p>官方已经指出 <strong>Nullable</strong> <strong>类型几乎总是会拖累性能</strong>，因为存储 Nullable 列时需要创建一个额外的文件来存储 NULL 的标记，并且 Nullable 列无法被索引。因此除非极特殊情况，应直接使用字段默认值表示空，或者自行指定一个在业务中无意义的值（例如用-1 表示没有商品ID）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_null</span><br><span class="line">(</span><br><span class="line">    `x` Int8,</span><br><span class="line">    `y` Nullable(Int8)</span><br><span class="line">) ENGINE <span class="operator">=</span> TinyLog;</span><br><span class="line"><span class="comment">-- 插入语句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_null <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="keyword">NULL</span>), (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 查询语句</span></span><br><span class="line"><span class="keyword">SELECT</span> x <span class="operator">+</span> y <span class="keyword">FROM</span> t_null;</span><br></pre></td></tr></table></figure><p>查看存储的文件：（没有权限就用 root 用户）</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918103851762.png" alt="image-20220918103851762"> </p><p>官方说明：<a href="https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/">https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/</a></p><h3 id="2-2-分区和索引"><a href="#2-2-分区和索引" class="headerlink" title="2.2 分区和索引"></a><strong>2.2</strong> <strong>分区和索引</strong></h3><p>分区粒度根据业务特点决定，不宜过粗或过细。一般选择<strong>按天分区</strong>，也可以指定为 Tuple()，以单表一亿数据为例，分区大小控制在 10-30 个为最佳。</p><p>必须指定索引列，ClickHouse 中的<strong>索引列即排序列</strong>，通过 <strong>order by</strong> 指定，一般在查询条件中经常被用来充当筛选条件的属性被纳入进来；可以是单一维度，也可以是组合维度的索引；通常需要满足高级列在前、查询频率大的在前原则；还有基数特别大的不适合做索引列，如用户表的 userid 字段；通常<strong>筛选后的数据满足在百万以内为最佳</strong>。</p><blockquote><p><strong>问题：为什么基数特别大的不适合做索引列？</strong></p><p>官方文档：</p><p>When a query is filtering on at least one column that is part of a compound key, and is the first key column, <a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#the-primary-index-is-used-for-selecting-granules">then ClickHouse is running the binary search algorithm over the key column’s index marks</a>.</p><p>When a query is filtering (only) on a column that is part of a compound key, but is not the first key column, <a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-multiple#secondary-key-columns-can-not-be-inefficient">then ClickHouse is using the generic exclusion search algorithm over the key column’s index marks</a>.</p><p>官方文档：</p><p>We discussed that because <a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-design#data-is-stored-on-disk-ordered-by-primary-key-columns">a ClickHouse table’s row data is stored on disk ordered by primary key column(s)</a>, having a very high cardinality column (like a UUID column) in a primary key or in a compound primary key before columns with lower cardinality <a href="https://clickhouse.com/docs/en/guides/improving-query-performance/sparse-primary-indexes/sparse-primary-indexes-cardinality#optimal-compression-ratio-of-data-files">is detrimental for the compression ratio of other table columns</a>.</p><p>A compromise between fastest retrieval and optimal data compression is to use a compound primary key where the UUID is the last key column, after low(er) cardinality key columns that are used to ensure a good compression ratio for some of the table’s columns.</p><p>结论：并不是基数特别大的不适合做索引列，而是基数特别大的不适合作为第一个索引列。因为如果查询条件不包含第一个索引时，这会使得通用排除搜索算法的效率变差。一个折中的做法是，索引列按照基数大小进行升序排列，基数特别大的作为索引的最后一列。</p></blockquote><p>比如官方案例的 hits_v1 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>visits_v1 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="2-3-表参数"><a href="#2-3-表参数" class="headerlink" title="2.3 表参数"></a><strong>2.3</strong> <strong>表参数</strong></h3><p>Index_granularity 是用来控制索引粒度的，默认是 8192，如非必须不建议调整。</p><p>如果表中不是必须保留全量历史数据，建议指定 TTL（生存时间值），可以免去手动清除过期历史数据的麻烦，TTL 也可以通过 alter table 语句随时修改。</p><h3 id="2-4-写入和删除优化"><a href="#2-4-写入和删除优化" class="headerlink" title="2.4 写入和删除优化"></a><strong>2.4</strong> <strong>写入和删除优化</strong></h3><p>（1）尽量不要执行单条或小批量删除和插入操作，这样会产生小分区文件，给后台 Merge 任务带来巨大压力</p><p>（2）不要一次写入太多分区，或数据写入太快，数据写入太快会导致 Merge 速度跟不上而报错，一般建议每秒钟发起 2-3 次写入操作，每次操作写入 2w~5w 条数据（依服务器性能而定）</p><p>写入过快报错，报错信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Code: 252, e.displayText() = DB::Exception: Too many parts(304). Merges are processing significantly slower than inserts</span><br><span class="line">2. Code: 241, e.displayText() = DB::Exception: Memory limit (for query) exceeded:would use 9.37 GiB (attempt to allocate chunk of 301989888 bytes), maximum: 9.31 GiB</span><br></pre></td></tr></table></figure><p>处理方式：</p><p>“ Too many parts 处理 ” ：使用 WAL 预写日志，提高写入性能。</p><p>in_memory_parts_enable_wal 默认为 true</p><p>在服务器内存充裕的情况下增加内存配额，一般通过 max_memory_usage 来实现</p><p>在服务器内存不充裕的情况下，建议将超出部分内容分配到系统硬盘上，但会降低执行速度，一般通过 max_bytes_before_external_group_by、max_bytes_before_external_sort 参数来实现。</p><h3 id="2-5-常见配置"><a href="#2-5-常见配置" class="headerlink" title="2.5 常见配置"></a><strong>2.5</strong> <strong>常见配置</strong></h3><p>配置项主要在 config.xml 或 users.xml 中， 基本上都在 users.xml 里 </p><ul><li>config.xml 的配置项<ul><li><a href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/">https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/</a></li></ul></li><li>users.xml 的配置项<ul><li><a href="https://clickhouse.com/docs/en/operations/settings/settings/">https://clickhouse.com/docs/en/operations/settings/settings/</a></li></ul></li></ul><h4 id="2-5-1-CPU-资源"><a href="#2-5-1-CPU-资源" class="headerlink" title="2.5.1 CPU 资源"></a><strong>2.5.1 CPU</strong> <strong>资源</strong></h4><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td>background_pool_size</td><td>后台线程池的大小，merge 线程就是在该线程池中执行，该线程池不仅仅是给 merge 线程用的，默认值 16，允许的前提下建议改成 <strong>cpu 个数的 2 倍（线程数）</strong>。</td></tr><tr><td>background_schedule_pool_size</td><td>执行后台任务（复制表、Kafka 流、DNS 缓存更新）的线程数。默认 128，<strong>建议改成 cpu 个数的 2 倍（线程数）</strong>。</td></tr><tr><td>background_distributed_schedule_pool_size</td><td>设置为分布式发送执行后台任务的线程数，默认 16，<strong>建议改成 cpu 个数的 2 倍（线程数）</strong>。</td></tr><tr><td>max_concurrent_queries</td><td>最大并发处理的请求数(包含 select,insert 等)，默认值 100，<strong>推荐 150(不够再加)~300</strong>。</td></tr><tr><td>max_threads</td><td>设置单个查询所能使用的最大 cpu 个数，默认是 cpu 核数</td></tr></tbody></table><h4 id="2-5-2-内存资源"><a href="#2-5-2-内存资源" class="headerlink" title="2.5.2 内存资源"></a><strong>2.5.2</strong> <strong>内存资源</strong></h4><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td>max_memory_usage</td><td>此参数在 users.xml 中，表示单次 Query 占用内存最大值，该值可以设置的比较大，这样可以提升集群查询的上限。<strong>保留一点给 OS，比如 128G 内存的机器，设置为 100GB</strong>。</td></tr><tr><td>max_bytes_before_external_group_by</td><td>一般按照 max_memory_usage 的一半设置内存，当 group 使用内存超过阈值后会刷新到磁盘进行。因为 clickhouse 聚合分两个阶段：查询并及建立中间数据、合并中间数据，<strong>结合上一项，建议 50GB</strong>。</td></tr><tr><td>max_bytes_before_external_sort</td><td>一般按照 max_memory_usage 的一半设置内存，如果不设置该值，那么当内存不够时直接抛错，设置了该值 order by 可以正常完成，但是速度相对存内存来说肯定要慢点(实测慢的非常多，无法接受)。</td></tr><tr><td>max_table_size_to_drop</td><td>此参数在 config.xml 中，应用于需要删除表或分区的情况，默认是50GB，意思是如果删除 50GB 以上的分区表会失败。<strong>建议修改为 0</strong>，这样不管多大的分区表都可以删除。</td></tr></tbody></table><h4 id="2-5-3-存储"><a href="#2-5-3-存储" class="headerlink" title="2.5.3 存储"></a><strong>2.5.3</strong> <strong>存储</strong></h4><p>ClickHouse 不支持设置多数据目录，为了提升数据 io 性能，可以挂载虚拟券组，一个券组绑定多块物理磁盘提升读写性能，多数据查询场景 SSD 会比普通机械硬盘快 2-3 倍。</p><h2 id="第-3-章-ClickHouse-语法优化规则"><a href="#第-3-章-ClickHouse-语法优化规则" class="headerlink" title="第 3 章 ClickHouse 语法优化规则"></a><strong>第</strong> <strong>3</strong> <strong>章</strong> <strong>ClickHouse</strong> <strong>语法优化规则</strong></h2><p>ClickHouse 的 SQL 优化规则是基于 RBO(Rule Based Optimization)，下面是一些优化规则</p><h3 id="3-1-准备测试用表"><a href="#3-1-准备测试用表" class="headerlink" title="3.1 准备测试用表"></a><strong>3.1</strong> <strong>准备测试用表</strong></h3><p><strong>1）下载并导入官方的数据集</strong></p><p>官网地址：<a href="https://clickhouse.com/docs/en/getting-started/example-datasets/metrica">https://clickhouse.com/docs/en/getting-started/example-datasets/metrica</a></p><p><strong>下载 hits 压缩 TSV 文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl https://datasets.clickhouse.com/hits/tsv/hits_v1.tsv.xz | unxz --threads=`nproc` &gt; hits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Validate the checksum</span></span><br><span class="line">md5sum hits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Checksum should be equal to: f3631b6295bf06989c1437491f7592cb</span></span><br></pre></td></tr></table></figure><p><strong>创建数据库和表：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;CREATE DATABASE IF NOT EXISTS datasets&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;CREATE TABLE datasets.hits_v1 ( WatchID UInt64,  JavaEnable UInt8,  Title String,  GoodEvent Int16,  EventTime DateTime,  EventDate Date,  CounterID UInt32,  ClientIP UInt32,  ClientIP6 FixedString(16),  RegionID UInt32,  UserID UInt64,  CounterClass Int8,  OS UInt8,  UserAgent UInt8,  URL String,  Referer String,  URLDomain String,  RefererDomain String,  Refresh UInt8,  IsRobot UInt8,  RefererCategories Array(UInt16),  URLCategories Array(UInt16), URLRegions Array(UInt32),  RefererRegions Array(UInt32),  ResolutionWidth UInt16,  ResolutionHeight UInt16,  ResolutionDepth UInt8,  FlashMajor UInt8, FlashMinor UInt8,  FlashMinor2 String,  NetMajor UInt8,  NetMinor UInt8, UserAgentMajor UInt16,  UserAgentMinor FixedString(2),  CookieEnable UInt8, JavascriptEnable UInt8,  IsMobile UInt8,  MobilePhone UInt8,  MobilePhoneModel String,  Params String,  IPNetworkID UInt32,  TraficSourceID Int8, SearchEngineID UInt16,  SearchPhrase String,  AdvEngineID UInt8,  IsArtifical UInt8,  WindowClientWidth UInt16,  WindowClientHeight UInt16,  ClientTimeZone Int16,  ClientEventTime DateTime,  SilverlightVersion1 UInt8, SilverlightVersion2 UInt8,  SilverlightVersion3 UInt32,  SilverlightVersion4 UInt16,  PageCharset String,  CodeVersion UInt32,  IsLink UInt8,  IsDownload UInt8,  IsNotBounce UInt8,  FUniqID UInt64,  HID UInt32,  IsOldCounter UInt8, IsEvent UInt8,  IsParameter UInt8,  DontCountHits UInt8,  WithHash UInt8, HitColor FixedString(1),  UTCEventTime DateTime,  Age UInt8,  Sex UInt8,  Income UInt8,  Interests UInt16,  Robotness UInt8,  GeneralInterests Array(UInt16), RemoteIP UInt32,  RemoteIP6 FixedString(16),  WindowName Int32,  OpenerName Int32,  HistoryLength Int16,  BrowserLanguage FixedString(2),  BrowserCountry FixedString(2),  SocialNetwork String,  SocialAction String,  HTTPError UInt16, SendTiming Int32,  DNSTiming Int32,  ConnectTiming Int32,  ResponseStartTiming Int32,  ResponseEndTiming Int32,  FetchTiming Int32,  RedirectTiming Int32, DOMInteractiveTiming Int32,  DOMContentLoadedTiming Int32,  DOMCompleteTiming Int32,  LoadEventStartTiming Int32,  LoadEventEndTiming Int32, NSToDOMContentLoadedTiming Int32,  FirstPaintTiming Int32,  RedirectCount Int8, SocialSourceNetworkID UInt8,  SocialSourcePage String,  ParamPrice Int64, ParamOrderID String,  ParamCurrency FixedString(3),  ParamCurrencyID UInt16, GoalsReached Array(UInt32),  OpenstatServiceName String,  OpenstatCampaignID String,  OpenstatAdID String,  OpenstatSourceID String,  UTMSource String, UTMMedium String,  UTMCampaign String,  UTMContent String,  UTMTerm String, FromTag String,  HasGCLID UInt8,  RefererHash UInt64,  URLHash UInt64,  CLID UInt32,  YCLID UInt64,  ShareService String,  ShareURL String,  ShareTitle String,  ParsedParams Nested(Key1 String,  Key2 String, Key3 String, Key4 String, Key5 String,  ValueDouble Float64),  IslandID FixedString(16),  RequestNum UInt32,  RequestTry UInt8) ENGINE = MergeTree() PARTITION BY toYYYYMM(EventDate) ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID) SETTINGS index_granularity = 8192&quot;</span><br></pre></td></tr></table></figure><p><strong>导入 hits 数据：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hits_v1.tsv | clickhouse-client [--password] --query &quot;INSERT INTO datasets.hits_v1 FORMAT TSV&quot; --max_insert_block_size=100000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;SELECT COUNT(*) FROM datasets.hits_v1&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918212056904.png" alt="image-20220918212056904"> </p><p><strong>下载 visits 压缩 TSV 文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl https://datasets.clickhouse.com/visits/tsv/visits_v1.tsv.xz | unxz --threads=`nproc` &gt; visits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Validate the checksum</span></span><br><span class="line">md5sum visits_v1.tsv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Checksum should be equal to: 6dafe1a0f24e59e3fc2d0fed85601de6</span></span><br></pre></td></tr></table></figure><p><strong>创建表：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;CREATE TABLE datasets.visits_v1 ( CounterID UInt32,  StartDate Date,  Sign Int8,  IsNew UInt8,  VisitID UInt64,  UserID UInt64,  StartTime DateTime,  Duration UInt32,  UTCStartTime DateTime,  PageViews Int32,  Hits Int32,  IsBounce UInt8,  Referer String,  StartURL String,  RefererDomain String,  StartURLDomain String,  EndURL String,  LinkURL String,  IsDownload UInt8,  TraficSourceID Int8,  SearchEngineID UInt16,  SearchPhrase String,  AdvEngineID UInt8,  PlaceID Int32,  RefererCategories Array(UInt16),  URLCategories Array(UInt16),  URLRegions Array(UInt32),  RefererRegions Array(UInt32),  IsYandex UInt8,  GoalReachesDepth Int32,  GoalReachesURL Int32,  GoalReachesAny Int32,  SocialSourceNetworkID UInt8,  SocialSourcePage String,  MobilePhoneModel String,  ClientEventTime DateTime,  RegionID UInt32,  ClientIP UInt32,  ClientIP6 FixedString(16),  RemoteIP UInt32,  RemoteIP6 FixedString(16),  IPNetworkID UInt32,  SilverlightVersion3 UInt32,  CodeVersion UInt32,  ResolutionWidth UInt16,  ResolutionHeight UInt16,  UserAgentMajor UInt16,  UserAgentMinor UInt16,  WindowClientWidth UInt16,  WindowClientHeight UInt16,  SilverlightVersion2 UInt8,  SilverlightVersion4 UInt16,  FlashVersion3 UInt16,  FlashVersion4 UInt16,  ClientTimeZone Int16,  OS UInt8,  UserAgent UInt8,  ResolutionDepth UInt8,  FlashMajor UInt8,  FlashMinor UInt8,  NetMajor UInt8,  NetMinor UInt8,  MobilePhone UInt8,  SilverlightVersion1 UInt8,  Age UInt8,  Sex UInt8,  Income UInt8,  JavaEnable UInt8,  CookieEnable UInt8,  JavascriptEnable UInt8,  IsMobile UInt8,  BrowserLanguage UInt16,  BrowserCountry UInt16,  Interests UInt16,  Robotness UInt8,  GeneralInterests Array(UInt16),  Params Array(String),  Goals Nested(ID UInt32, Serial UInt32, EventTime DateTime,  Price Int64,  OrderID String, CurrencyID UInt32),  WatchIDs Array(UInt64),  ParamSumPrice Int64,  ParamCurrency FixedString(3),  ParamCurrencyID UInt16,  ClickLogID UInt64,  ClickEventID Int32,  ClickGoodEvent Int32,  ClickEventTime DateTime,  ClickPriorityID Int32,  ClickPhraseID Int32,  ClickPageID Int32,  ClickPlaceID Int32,  ClickTypeID Int32,  ClickResourceID Int32,  ClickCost UInt32,  ClickClientIP UInt32,  ClickDomainID UInt32,  ClickURL String,  ClickAttempt UInt8,  ClickOrderID UInt32,  ClickBannerID UInt32,  ClickMarketCategoryID UInt32,  ClickMarketPP UInt32,  ClickMarketCategoryName String,  ClickMarketPPName String,  ClickAWAPSCampaignName String,  ClickPageName String,  ClickTargetType UInt16,  ClickTargetPhraseID UInt64,  ClickContextType UInt8,  ClickSelectType Int8,  ClickOptions String,  ClickGroupBannerID Int32,  OpenstatServiceName String,  OpenstatCampaignID String,  OpenstatAdID String,  OpenstatSourceID String,  UTMSource String,  UTMMedium String,  UTMCampaign String,  UTMContent String,  UTMTerm String,  FromTag String,  HasGCLID UInt8,  FirstVisit DateTime,  PredLastVisit Date,  LastVisit Date,  TotalVisits UInt32,  TraficSource    Nested(ID Int8,  SearchEngineID UInt16, AdvEngineID UInt8, PlaceID UInt16, SocialSourceNetworkID UInt8, Domain String, SearchPhrase String, SocialSourcePage String),  Attendance FixedString(16),  CLID UInt32,  YCLID UInt64,  NormalizedRefererHash UInt64,  SearchPhraseHash UInt64,  RefererDomainHash UInt64,  NormalizedStartURLHash UInt64,  StartURLDomainHash UInt64,  NormalizedEndURLHash UInt64,  TopLevelDomain UInt64,  URLScheme UInt64,  OpenstatServiceNameHash UInt64,  OpenstatCampaignIDHash UInt64,  OpenstatAdIDHash UInt64,  OpenstatSourceIDHash UInt64,  UTMSourceHash UInt64,  UTMMediumHash UInt64,  UTMCampaignHash UInt64,  UTMContentHash UInt64,  UTMTermHash UInt64,  FromHash UInt64,  WebVisorEnabled UInt8,  WebVisorActivity UInt32,  ParsedParams    Nested(Key1 String,  Key2 String,  Key3 String,  Key4 String, Key5 String, ValueDouble    Float64),  Market Nested(Type UInt8, GoalID UInt32, OrderID String,  OrderPrice Int64,  PP UInt32,  DirectPlaceID UInt32,  DirectOrderID  UInt32,  DirectBannerID UInt32,  GoodID String, GoodName String, GoodQuantity Int32,  GoodPrice Int64),  IslandID FixedString(16)) ENGINE = CollapsingMergeTree(Sign) PARTITION BY toYYYYMM(StartDate) ORDER BY (CounterID, StartDate, intHash32(UserID), VisitID) SAMPLE BY intHash32(UserID) SETTINGS index_granularity = 8192&quot;</span><br></pre></td></tr></table></figure><p><strong>导入 visits 数据：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat visits_v1.tsv | clickhouse-client [--password] --query &quot;INSERT INTO datasets.visits_v1 FORMAT TSV&quot; --max_insert_block_size=100000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client [--password] --query &quot;SELECT COUNT(*) FROM datasets.visits_v1&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918211502836.png" alt="image-20220918211502836"> </p><h3 id="3-2-COUNT-优化"><a href="#3-2-COUNT-优化" class="headerlink" title="3.2 COUNT 优化"></a><strong>3.2 COUNT</strong> <strong>优化</strong></h3><p>在调用 count 函数时，如果使用的是 count() 或者 count(*)，且没有 where 条件，则会直接使用 system.tables 的 total_rows，例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">count</span>() <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918212520617.png" alt="image-20220918212520617"> </p><p>注意 Optimized trivial count ，这是对 count 的优化。</p><p>如果 count 具体的列字段，则不会使用此项优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">count</span>(CounterID) <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918212624192.png" alt="image-20220918212624192"> </p><h3 id="3-3-消除子查询重复字段"><a href="#3-3-消除子查询重复字段" class="headerlink" title="3.3 消除子查询重复字段"></a><strong>3.3</strong> <strong>消除子查询重复字段</strong></h3><p>下面语句子查询中有两个重复的 id 字段，会被去重:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.UserID,</span><br><span class="line">    b.VisitID,</span><br><span class="line">    a.URL,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        UserID,</span><br><span class="line">        UserID <span class="keyword">AS</span> HaHa,</span><br><span class="line">        VisitID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">) <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID)</span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213307849.png" alt="image-20220918213307849"> </p><h3 id="3-4-谓词下推"><a href="#3-4-谓词下推" class="headerlink" title="3.4 谓词下推"></a><strong>3.4</strong> <strong>谓词下推</strong></h3><p>当 group by 有 having 子句，但是没有 with cube、with rollup 或者 with totals 修饰的时候，having 过滤会下推到 where 提前过滤。例如下面的查询，HAVING name 变成了 WHERE name，在 group by 之前过滤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX <span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">HAVING</span> UserID <span class="operator">=</span> <span class="string">&#x27;8585742290196126178&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213532475.png" alt="image-20220918213532475"> </p><p>子查询也支持谓词下推：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> UserID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="string">&#x27;8585742290196126178&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213712676.png" alt="image-20220918213712676"> </p><p>再来一个复杂例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> UserID</span><br><span class="line">        <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> UserID</span><br><span class="line">        <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="string">&#x27;8585742290196126178&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918213856857.png" alt="image-20220918213856857"> </p><h3 id="3-5-聚合计算外推"><a href="#3-5-聚合计算外推" class="headerlink" title="3.5 聚合计算外推"></a><strong>3.5</strong> <strong>聚合计算外推</strong></h3><p>聚合函数内的计算，会外推，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(UserID <span class="operator">*</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214011204.png" alt="image-20220918214011204"> </p><h3 id="3-6-聚合函数消除"><a href="#3-6-聚合函数消除" class="headerlink" title="3.6 聚合函数消除"></a><strong>3.6</strong> <strong>聚合函数消除</strong></h3><p>如果对聚合键，也就是 group by key 使用 min、max、any 聚合函数，则将函数消除，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">sum</span>(UserID <span class="operator">*</span> <span class="number">2</span>),</span><br><span class="line">    <span class="built_in">max</span>(VisitID),</span><br><span class="line">    <span class="built_in">max</span>(UserID)</span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214136336.png" alt="image-20220918214136336">  </p><h3 id="3-7-删除重复的-order-by-key"><a href="#3-7-删除重复的-order-by-key" class="headerlink" title="3.7 删除重复的 order by key"></a><strong>3.7</strong> <strong>删除重复的</strong> <strong>order by key</strong></h3><p>例如下面的语句，重复的聚合键 id 字段会被去重：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214619369.png" alt="image-20220918214619369"> </p><h3 id="3-8-删除重复的-limit-by-key"><a href="#3-8-删除重复的-limit-by-key" class="headerlink" title="3.8 删除重复的 limit by key"></a><strong>3.8</strong> <strong>删除重复的</strong> <strong>limit by key</strong></h3><p>例如下面的语句，重复声明的 name 字段会被去重：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">LIMIT <span class="number">3</span> <span class="keyword">BY</span></span><br><span class="line">    VisitID,</span><br><span class="line">    VisitID</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214726919.png" alt="image-20220918214726919"> </p><h3 id="3-9-删除重复的-USING-Key"><a href="#3-9-删除重复的-USING-Key" class="headerlink" title="3.9 删除重复的 USING Key"></a><strong>3.9</strong> <strong>删除重复的</strong> <strong>USING Key</strong></h3><p>例如下面的语句，重复的关联键 id 字段会被去重：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.UserID,</span><br><span class="line">    a.UserID,</span><br><span class="line">    b.VisitID,</span><br><span class="line">    a.URL,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID, UserID);</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918214918761.png" alt="image-20220918214918761"> </p><h3 id="3-10-标量替换"><a href="#3-10-标量替换" class="headerlink" title="3.10 标量替换"></a><strong>3.10</strong> <strong>标量替换</strong></h3><p>如果子查询只返回一行数据，在被引用的时候用标量替换，例如下面语句中的 total_disk_usage 字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">WITH</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">sum</span>(bytes)</span><br><span class="line">        <span class="keyword">FROM</span> system.parts</span><br><span class="line">        <span class="keyword">WHERE</span> active</span><br><span class="line">    ) <span class="keyword">AS</span> total_disk_usage</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    (<span class="built_in">sum</span>(bytes) <span class="operator">/</span> total_disk_usage) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> table_disk_usage,</span><br><span class="line">    <span class="keyword">table</span></span><br><span class="line"><span class="keyword">FROM</span> system.parts</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> table_disk_usage <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918215026462.png" alt="image-20220918215026462"> </p><h3 id="3-11-三元运算优化"><a href="#3-11-三元运算优化" class="headerlink" title="3.11 三元运算优化"></a><strong>3.11</strong> <strong>三元运算优化</strong></h3><p>如果开启了 optimize_if_chain_to_multiif 参数，三元运算符会被替换成 multiIf 函数，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX </span><br><span class="line"><span class="keyword">SELECT</span> number <span class="operator">=</span> <span class="number">1</span> ? <span class="string">&#x27;hello&#x27;</span> : (number <span class="operator">=</span> <span class="number">2</span> ? <span class="string">&#x27;world&#x27;</span> : <span class="string">&#x27;atguigu&#x27;</span>) </span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10</span>) </span><br><span class="line">settings optimize_if_chain_to_multiif <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918215233545.png" alt="image-20220918215233545"> </p><h2 id="第-4-章-查询优化"><a href="#第-4-章-查询优化" class="headerlink" title="第 4 章 查询优化"></a><strong>第</strong> <strong>4</strong> <strong>章 查询优化</strong></h2><h3 id="4-1-单表查询"><a href="#4-1-单表查询" class="headerlink" title="4.1 单表查询"></a><strong>4.1</strong> <strong>单表查询</strong></h3><h4 id="4-1-1-Prewhere-替代-where"><a href="#4-1-1-Prewhere-替代-where" class="headerlink" title="4.1.1 Prewhere 替代 where"></a><strong>4.1.1 Prewhere</strong> <strong>替代</strong> <strong>where</strong></h4><p>Prewhere 和 where 语句的作用相同，用来过滤数据。不同之处在于 prewhere 只支持 *MergeTree 族系列引擎的表，首先会读取指定的列数据，来判断数据过滤，等待数据过滤之后再读取 select 声明的列字段来补全其余属性。</p><p>当查询列明显多于筛选列时使用 Prewhere 可十倍提升查询性能，Prewhere 会自动优化执行过滤阶段的数据读取方式，降低 io 操作。</p><p>在某些场合下，prewhere 语句比 where 语句处理的数据量更少性能更高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭 where 自动转 prewhere(默认情况下， where 条件会自动优化成 prewhere)</span></span><br><span class="line"><span class="keyword">set</span> optimize_move_to_prewhere <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 where</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID,</span><br><span class="line">    CounterClass,</span><br><span class="line">    OS,</span><br><span class="line">    UserAgent,</span><br><span class="line">    URL,</span><br><span class="line">    Referer,</span><br><span class="line">    URLDomain,</span><br><span class="line">    RefererDomain,</span><br><span class="line">    Refresh,</span><br><span class="line">    IsRobot,</span><br><span class="line">    RefererCategories,</span><br><span class="line">    URLCategories,</span><br><span class="line">    URLRegions,</span><br><span class="line">    RefererRegions,</span><br><span class="line">    ResolutionWidth,</span><br><span class="line">    ResolutionHeight,</span><br><span class="line">    ResolutionDepth,</span><br><span class="line">    FlashMajor,</span><br><span class="line">    FlashMinor,</span><br><span class="line">    FlashMinor2</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> UserID <span class="operator">=</span> <span class="string">&#x27;3198390223272470366&#x27;</span>;</span><br><span class="line"><span class="comment">-- 152 rows in set. Elapsed: 0.897 sec. Processed 8.87 million rows, 3.86 GB (9.89 million rows/s., 4.30 GB/s.)</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 prewhere 关键字</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID,</span><br><span class="line">    CounterClass,</span><br><span class="line">    OS,</span><br><span class="line">    UserAgent,</span><br><span class="line">    URL,</span><br><span class="line">    Referer,</span><br><span class="line">    URLDomain,</span><br><span class="line">    RefererDomain,</span><br><span class="line">    Refresh,</span><br><span class="line">    IsRobot,</span><br><span class="line">    RefererCategories,</span><br><span class="line">    URLCategories,</span><br><span class="line">    URLRegions,</span><br><span class="line">    RefererRegions,</span><br><span class="line">    ResolutionWidth,</span><br><span class="line">    ResolutionHeight,</span><br><span class="line">    ResolutionDepth,</span><br><span class="line">    FlashMajor,</span><br><span class="line">    FlashMinor,</span><br><span class="line">    FlashMinor2</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">PREWHERE UserID <span class="operator">=</span> <span class="string">&#x27;3198390223272470366&#x27;</span>;</span><br><span class="line"><span class="comment">-- 152 rows in set. Elapsed: 0.083 sec. Processed 8.87 million rows, 116.54 MB (106.55 million rows/s., 1.40 GB/s.)</span></span><br></pre></td></tr></table></figure><p>默认情况，我们肯定不会关闭 where 自动优化成 prewhere，但是某些场景即使开启优化，也不会自动转换成 prewhere，需要手动指定 prewhere：</p><ul><li>使用常量表达式</li><li>使用默认值为 alias 类型的字段</li><li>包含了 arrayJOIN，globalIn，globalNotIn 或者 indexHint 的查询</li><li>select 查询的列字段和 where 的谓词相同</li><li>使用了主键字段</li></ul><h4 id="4-1-2-数据采样"><a href="#4-1-2-数据采样" class="headerlink" title="4.1.2 数据采样"></a><strong>4.1.2</strong> <strong>数据采样</strong></h4><p>通过采样运算可极大提升数据分析的性能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Title,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> PageViews</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">SAMPLE <span class="number">1</span> <span class="operator">/</span> <span class="number">10</span> <span class="comment">-- 代表采样10%的数据,也可以是具体的条数</span></span><br><span class="line"><span class="keyword">WHERE</span> CounterID <span class="operator">=</span> <span class="number">57</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> PageViews <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>采样修饰符只有在 MergeTree engine 表中才有效，且在创建表时需要指定采样策略。</p><h4 id="4-1-3-列裁剪与分区裁剪"><a href="#4-1-3-列裁剪与分区裁剪" class="headerlink" title="4.1.3 列裁剪与分区裁剪"></a><strong>4.1.3</strong> <strong>列裁剪与分区裁剪</strong></h4><p>数据量太大时应避免使用 select * 操作，查询的性能会与查询的字段大小和数量成线性表换，字段越少，消耗的 io 资源越少，性能就会越高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"><span class="comment">-- 正例</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID, </span><br><span class="line">    JavaEnable, </span><br><span class="line">    Title, </span><br><span class="line">    GoodEvent, </span><br><span class="line">    EventTime, </span><br><span class="line">    EventDate, </span><br><span class="line">    CounterID, </span><br><span class="line">    ClientIP, </span><br><span class="line">    ClientIP6, </span><br><span class="line">    RegionID, </span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure><p>分区裁剪就是只读取需要的分区，在过滤条件中指定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    WatchID, </span><br><span class="line">    JavaEnable, </span><br><span class="line">    Title, </span><br><span class="line">    GoodEvent, </span><br><span class="line">    EventTime, </span><br><span class="line">    EventDate, </span><br><span class="line">    CounterID, </span><br><span class="line">    ClientIP, </span><br><span class="line">    ClientIP6, </span><br><span class="line">    RegionID, </span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-23&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-orderby-结合-where、limit"><a href="#4-1-4-orderby-结合-where、limit" class="headerlink" title="4.1.4 orderby 结合 where、limit"></a><strong>4.1.4 orderby 结合 where、limit</strong></h4><p>千万以上数据集进行 order by 查询时需要搭配 where 条件和 limit 语句一起使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正例：</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    Age</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> CounterID <span class="operator">=</span> <span class="number">57</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 反例：</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    Age</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-5-避免构建虚拟列"><a href="#4-1-5-避免构建虚拟列" class="headerlink" title="4.1.5 避免构建虚拟列"></a><strong>4.1.5</strong> <strong>避免构建虚拟列</strong></h4><p>如非必须，不要在结果集上构建虚拟列，虚拟列非常消耗资源浪费性能，可以考虑在前端进行处理，或者在表中构造实际字段进行额外存储。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例：</span></span><br><span class="line"><span class="keyword">SELECT</span> Income, Age, Income<span class="operator">/</span>Age <span class="keyword">as</span> IncRate <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"><span class="comment">-- 正例：拿到 Income 和 Age 后，考虑在前端进行处理，或者在表中构造实际字段进行额外存储</span></span><br><span class="line"><span class="keyword">SELECT</span> Income, Age <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure><h4 id="4-1-6-uniqCombined-替代-distinct"><a href="#4-1-6-uniqCombined-替代-distinct" class="headerlink" title="4.1.6 uniqCombined 替代 distinct"></a><strong>4.1.6 uniqCombined</strong> <strong>替代</strong> <strong>distinct</strong></h4><p>性能可提升 10 倍以上，uniqCombined 底层采用类似 HyperLogLog 算法实现，能接受 2% 左右的数据误差，可直接使用这种去重方式提升查询性能。Count(distinct)会使用 uniqExact 精确去重。</p><p>不建议在千万级不同数据上执行 distinct 去重查询，改为近似去重 uniqCombined</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 反例：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> rand()) <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"><span class="comment">-- 正例：</span></span><br><span class="line"><span class="keyword">SELECT</span> uniqCombined(rand()) <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure><h4 id="4-1-7-使用物化视图"><a href="#4-1-7-使用物化视图" class="headerlink" title="4.1.7 使用物化视图"></a><strong>4.1.7</strong> <strong>使用物化视图</strong></h4><p>参考第 6 章。</p><h4 id="4-1-8-其他注意事项"><a href="#4-1-8-其他注意事项" class="headerlink" title="4.1.8 其他注意事项"></a><strong>4.1.8</strong> <strong>其他注意事项</strong></h4><p><strong>（1）查询熔断</strong></p><p>为了避免因个别慢查询引起的服务雪崩的问题，除了可以为单个查询设置超时以外，还可以配置周期熔断，在一个查询周期内，如果用户频繁进行慢查询操作超出规定阈值后将无法继续进行查询操作。</p><p><strong>（2）关闭虚拟内存</strong></p><p>物理内存和虚拟内存的数据交换，会导致查询变慢，资源允许的情况下关闭虚拟内存。</p><p><strong>（3）配置 join_use_nulls</strong></p><p>为每一个账户添加 join_use_nulls 配置，左表中的一条记录在右表中不存在，右表的相应字段会返回该字段相应数据类型的默认值，而不是标准 SQL 中的 Null 值。</p><p><strong>（4）批量写入时先排序</strong></p><p>批量写入数据时，必须控制每个批次的数据中涉及到的分区的数量，在写入之前最好对需要导入的数据进行排序。无序的数据或者涉及的分区太多，会导致 ClickHouse 无法及时对新导入的数据进行合并，从而影响查询性能。</p><p><strong>（5）关注 CPU</strong></p><p>cpu 一般在 50%左右会出现查询波动，达到 70%会出现大范围的查询超时，cpu 是最关键的指标，要非常关注。</p><h3 id="4-2-多表关联"><a href="#4-2-多表关联" class="headerlink" title="4.2 多表关联"></a><strong>4.2</strong> <strong>多表关联</strong></h3><h4 id="4-2-1-准备表和数据"><a href="#4-2-1-准备表和数据" class="headerlink" title="4.2.1 准备表和数据"></a><strong>4.2.1</strong> <strong>准备表和数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建小表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.visits_v2</span><br><span class="line">ENGINE <span class="operator">=</span> CollapsingMergeTree(Sign)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span> <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">LIMIT <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 join 结果表：避免控制台疯狂打印数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.hits_v2</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span> <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-用-IN-代替-JOIN"><a href="#4-2-2-用-IN-代替-JOIN" class="headerlink" title="4.2.2 用 IN 代替 JOIN"></a><strong>4.2.2</strong> <strong>用</strong> <strong>IN</strong> <strong>代替</strong> <strong>JOIN</strong></h4><p>当多表联查时，查询的数据仅从其中一张表出时，可考虑用 IN 操作而不是 JOIN</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> a.CounterID <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> CounterID</span><br><span class="line">    <span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 1.595 sec. Processed 6.19 million rows, 5.86 GB (3.88 million rows/s., 3.68 GB/s.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 反例：使用 join</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v1 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 25.152 sec. Processed 10.55 million rows, 8.47 GB (419.58 thousand rows/s., 336.60 MB/s.)</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-大小表-JOIN"><a href="#4-2-3-大小表-JOIN" class="headerlink" title="4.2.3 大小表 JOIN"></a><strong>4.2.3</strong> <strong>大小表</strong> <strong>JOIN</strong></h4><p>多表 join 时要满足小表在右的原则，右表关联时被加载到内存中与左表进行比较，ClickHouse 中无论是 Left join 、Right join 还是 Inner join 永远都是拿着右表中的每一条记录到左表中查找该记录是否存在，所以右表必须是小表。</p><p><strong>（1）小表在右</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 23.745 sec. Processed 8.88 million rows, 8.46 GB (374.11 thousand rows/s., 356.28 MB/s.)</span></span><br></pre></td></tr></table></figure><p><strong>（2）大表在右</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v2 <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.hits_v1 <span class="keyword">AS</span> a <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- Code: 241. DB::Exception: Received from localhost:9000. DB::Exception: Memory limit (total) exceeded: would use 3.31 GiB (attempt to allocate chunk of 4202528 bytes), maximum: 3.31 GiB: (while reading column UTMMedium): (while reading from part /var/lib/clickhouse/store/f5f/f5f00661-967a-4a35-b5f0-0661967afa35/201403_25_30_1/ from mark 0 with max_rows_to_read = 8192): While executing MergeTreeThread.</span></span><br></pre></td></tr></table></figure><h4 id="4-2-4-注意谓词下推（版本差异）"><a href="#4-2-4-注意谓词下推（版本差异）" class="headerlink" title="4.2.4 注意谓词下推（版本差异）"></a><strong>4.2.4</strong> <strong>注意谓词下推（版本差异）</strong></h4><p>ClickHouse 在 join 查询时不会主动发起谓词下推的操作，需要每个子查询提前完成过滤操作，需要注意的是，是否执行谓词下推，对性能影响差别很大（新版本中已经不存在此问题，但是需要注意谓词的位置的不同依然有性能的差异）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID</span><br><span class="line"><span class="keyword">HAVING</span> a.EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918230221445.png" alt="image-20220918230221445"> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID</span><br><span class="line"><span class="keyword">HAVING</span> b.StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918230335644.png" alt="image-20220918230335644"> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID</span><br><span class="line"><span class="keyword">WHERE</span> a.EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 5.113 sec. Processed 6.70 million rows, 5.66 GB (1.31 million rows/s., 1.11 GB/s.)</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_v2 <span class="keyword">SELECT</span> a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">    <span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">) <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> datasets.visits_v2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.CounterID <span class="operator">=</span> b.CounterID;</span><br><span class="line"><span class="comment">-- 0 rows in set. Elapsed: 5.204 sec. Processed 6.70 million rows, 5.66 GB (1.29 million rows/s., 1.09 GB/s.)</span></span><br></pre></td></tr></table></figure><h4 id="4-2-5-分布式表使用-GLOBAL"><a href="#4-2-5-分布式表使用-GLOBAL" class="headerlink" title="4.2.5 分布式表使用 GLOBAL"></a><strong>4.2.5</strong> <strong>分布式表使用</strong> <strong>GLOBAL</strong></h4><p>两张<strong>分布式表</strong>上的 IN 和 JOIN 之前必须加上 <strong>GLOBAL</strong> 关键字，右表只会在接收查询请求的那个节点查询一次，并将其分发到其他节点上。如果不加 GLOBAL 关键字的话，每个节点都会单独发起一次对右表的查询，而右表又是分布式表，就导致右表一共会被查询 N²次（N是该分布式表的分片数量），这就是<strong>查询放大</strong>，会带来很大开销。</p><h4 id="4-2-6-使用字典表"><a href="#4-2-6-使用字典表" class="headerlink" title="4.2.6 使用字典表"></a><strong>4.2.6</strong> <strong>使用字典表</strong></h4><p>将一些需要关联分析的业务创建成字典表进行 join 操作，前提是字典表不宜太大，因为字典表会常驻内存</p><h4 id="4-2-7-提前过滤"><a href="#4-2-7-提前过滤" class="headerlink" title="4.2.7 提前过滤"></a><strong>4.2.7</strong> <strong>提前过滤</strong></h4><p>通过增加逻辑过滤可以减少数据扫描，达到提高执行速度及降低内存消耗的目的</p><h2 id="第-5-章-数据一致性（重点）"><a href="#第-5-章-数据一致性（重点）" class="headerlink" title="第 5 章 数据一致性（重点）"></a><strong>第</strong> <strong>5</strong> <strong>章 数据一致性（重点）</strong></h2><p>查询 CK 手册发现，即便对数据一致性支持最好的 Mergetree，也只是保证<strong>最终一致性</strong>：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918231654892.png" alt="image-20220918231654892"> </p><p>我们在使用 ReplacingMergeTree、SummingMergeTree 这类表引擎的时候，会出现短暂数据不一致的情况。</p><p>在某些对一致性非常敏感的场景，通常有以下几种解决方案。</p><h3 id="5-1-准备测试表和数据"><a href="#5-1-准备测试表和数据" class="headerlink" title="5.1 准备测试表和数据"></a><strong>5.1</strong> <strong>准备测试表和数据</strong></h3><p><strong>（1）创建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_a</span><br><span class="line">(</span><br><span class="line">    `user_id` UInt64,</span><br><span class="line">    `score` String,</span><br><span class="line">    `deleted` UInt8 <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    `create_time` DateTime <span class="keyword">DEFAULT</span> toDateTime(<span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure><p>其中：</p><p>user_id 是数据去重更新的标识；</p><p>create_time 是版本号字段，每组数据中 create_time 最大的一行表示最新的数据；</p><p>deleted 是自定的一个标记位，比如 0 代表未删除，1 代表删除数据。</p><p><strong>（2）写入 1000 万 测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score) <span class="keyword">WITH</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>]</span><br><span class="line">    ) <span class="keyword">AS</span> dict</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    number <span class="keyword">AS</span> user_id,</span><br><span class="line">    dict[(number <span class="operator">%</span> <span class="number">7</span>) <span class="operator">+</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10000000</span>);</span><br></pre></td></tr></table></figure><p><strong>（3）修改前 50 万 行数据，修改内容包括 name 字段和 create_time 版本号字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score, create_time) <span class="keyword">WITH</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> [<span class="string">&#x27;AA&#x27;</span>, <span class="string">&#x27;BB&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;DD&#x27;</span>, <span class="string">&#x27;EE&#x27;</span>, <span class="string">&#x27;FF&#x27;</span>, <span class="string">&#x27;GG&#x27;</span>]</span><br><span class="line">    ) <span class="keyword">AS</span> dict</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    number <span class="keyword">AS</span> user_id,</span><br><span class="line">    dict[(number <span class="operator">%</span> <span class="number">7</span>) <span class="operator">+</span> <span class="number">1</span>],</span><br><span class="line">    now() <span class="keyword">AS</span> create_time</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">500000</span>);</span><br></pre></td></tr></table></figure><p><strong>（4）统计总数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>() <span class="keyword">FROM</span> test_a;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918232130909.png" alt="image-20220918232130909"> </p><p>还未触发分区合并，所以还未去重。</p><h3 id="5-2-手动-OPTIMIZE"><a href="#5-2-手动-OPTIMIZE" class="headerlink" title="5.2 手动 OPTIMIZE"></a><strong>5.2</strong> <strong>手动</strong> <strong>OPTIMIZE</strong></h3><p>在写入数据后，立刻执行 OPTIMIZE 强制触发新写入分区的合并动作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> test_a <span class="keyword">FINAL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法：OPTIMIZE TABLE [db.]name [ON CLUSTER cluster] [PARTITION partition | PARTITION ID &#x27;partition_id&#x27;] [FINAL] [DEDUPLICATE [BY expression]]</span></span><br></pre></td></tr></table></figure><h3 id="5-3-通过-Group-by-去重"><a href="#5-3-通过-Group-by-去重" class="headerlink" title="5.3 通过 Group by 去重"></a><strong>5.3</strong> <strong>通过</strong> <strong>Group by</strong> <strong>去重</strong></h3><p><strong>（1）执行去重的查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id,</span><br><span class="line">    argMax(score, create_time) <span class="keyword">AS</span> score,</span><br><span class="line">    argMax(deleted, create_time) <span class="keyword">AS</span> deleted,</span><br><span class="line">    <span class="built_in">max</span>(create_time) <span class="keyword">AS</span> ctime</span><br><span class="line"><span class="keyword">FROM</span> test_a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> deleted <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>函数说明：</p><ul><li>argMax(field1，field2)：按照 field2 的最大值取 field1 的值。</li></ul><p>当我们更新数据时，会写入一行新的数据，例如上面语句中，通过查询最大的 create_time 得到修改后的 score 字段值。</p><p><strong>（2）创建视图，方便测试</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_test_a <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id,</span><br><span class="line">    argMax(score, create_time) <span class="keyword">AS</span> score,</span><br><span class="line">    argMax(deleted, create_time) <span class="keyword">AS</span> deleted,</span><br><span class="line">    <span class="built_in">max</span>(create_time) <span class="keyword">AS</span> ctime</span><br><span class="line"><span class="keyword">FROM</span> test_a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> deleted <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>（3）插入重复数据，再次查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 再次插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score, create_time) <span class="keyword">VALUES</span>(<span class="number">0</span>, <span class="string">&#x27;AAAA&#x27;</span>, now());</span><br><span class="line"><span class="comment">-- 再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> view_test_a</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918232722893.png" alt="image-20220918232722893"> </p><p><strong>（4）删除数据测试</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 再次插入一条标记为删除的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (user_id, score, deleted, create_time) <span class="keyword">VALUES</span>(<span class="number">0</span>, <span class="string">&#x27;AAAA&#x27;</span>, <span class="number">1</span>, now()); </span><br><span class="line"><span class="comment">-- 再次查询，刚才那条数据看不到了</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> view_test_a</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918232843982.png" alt="image-20220918232843982"> </p><p>这行数据并没有被真正的删除，而是被过滤掉了。在一些合适的场景下，可以结合表级别的 TTL 最终将物理数据删除。</p><h3 id="5-4-通过-FINAL-查询"><a href="#5-4-通过-FINAL-查询" class="headerlink" title="5.4 通过 FINAL 查询"></a><strong>5.4</strong> <strong>通过</strong> <strong>FINAL</strong> <strong>查询</strong></h3><p>在查询语句后增加 FINAL 修饰符，这样在查询的过程中将会执行 Merge 的特殊逻辑（例如数据去重，预聚合等）。</p><p>但是这种方法在早期版本基本没有人使用，因为在增加 FINAL 之后，我们的查询将会变成一个单线程的执行过程，查询速度非常慢。</p><p>在 <strong>v20.5.2.7-stable</strong> 版本中，FINAL 查询支持多线程执行，并且可以通过 <strong>max_final_threads 参数</strong>控制单个查询的线程数。但是目前读取 part 部分的动作依然是串行的。</p><p>FINAL 查询最终的性能和很多因素相关，列字段的大小、分区的数量等等都会影响到最终的查询时间，所以还要结合实际场景取舍。</p><p>参考链接：<a href="https://github.com/ClickHouse/ClickHouse/pull/10463">https://github.com/ClickHouse/ClickHouse/pull/10463</a></p><h4 id="5-4-1-测试"><a href="#5-4-1-测试" class="headerlink" title="5.4.1 测试"></a><strong>5.4.1</strong> <strong>测试</strong></h4><p><strong>（1）普通语句查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>查看执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918233420942.png" alt="image-20220918233420942"> </p><p>明显将由 2 个线程并行读取 part 查询。</p><p><strong>（2）FINAL 查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">FINAL</span></span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_final_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>查询速度没有普通的查询快，但是相比之前已经有了一些提升,查看 FINAL 查询的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PIPELINE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> datasets.visits_v1</span><br><span class="line"><span class="keyword">FINAL</span></span><br><span class="line"><span class="keyword">WHERE</span> StartDate <span class="operator">=</span> <span class="string">&#x27;2014-03-17&#x27;</span></span><br><span class="line">LIMIT <span class="number">100</span></span><br><span class="line">SETTINGS max_final_threads <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918233706434.png" alt="image-20220918233706434"> </p><p>从 CollapsingSortedTransform 这一步开始已经是多线程执行，但是读取 part 部分的动作还是串行。</p><h2 id="第-6-章-物化视图"><a href="#第-6-章-物化视图" class="headerlink" title="第 6 章 物化视图"></a><strong>第</strong> <strong>6</strong> <strong>章 物化视图</strong></h2><p>ClickHouse 的物化视图是一种查询结果的持久化，它确实是给我们带来了查询效率的提升。用户查起来跟表没有区别，它就是一张表，它也像是一张时刻在预计算的表，创建的过程它是用了一个特殊引擎，加上后来 as select，就是 create 一个 table as select 的写法。</p><p>“查询结果集”的范围很宽泛，可以是基础表中部分数据的一份简单拷贝，也可以是多表 join 之后产生的结果或其子集，或者原始数据的聚合指标等等。所以，物化视图不会随着基础表的变化而变化，所以它也称为快照（snapshot）</p><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a><strong>6.1</strong> <strong>概述</strong></h3><h4 id="6-1-1-物化视图与普通视图的区别"><a href="#6-1-1-物化视图与普通视图的区别" class="headerlink" title="6.1.1 物化视图与普通视图的区别"></a><strong>6.1.1</strong> <strong>物化视图与普通视图的区别</strong></h4><p><strong>普通视图不保存数据，保存的仅仅是查询语句</strong>，查询的时候还是从原表读取数据，可以将普通视图理解为是个子查询。<strong>物化视图则是把查询的结果根据相应的引擎存入到了磁盘或内存中</strong>，对数据重新进行了组织，你可以理解物化视图是完全的一张新表。</p><h4 id="6-1-2-优缺点"><a href="#6-1-2-优缺点" class="headerlink" title="6.1.2 优缺点"></a><strong>6.1.2</strong> <strong>优缺点</strong></h4><p>优点：查询速度<strong>快</strong>，要是把物化视图这些规则全部写好，它比原数据查询快了很多，总的行数少了，因为都预计算好了。</p><p>缺点：它的本质是一个流式数据的使用场景，是累加式的技术，所以要用历史数据做去重、去核这样的分析，在物化视图里面是不太好用的。在某些场景的使用也是有限的。而且如果一张表加了好多物化视图，在写这张表的时候，就会消耗很多机器的资源，比如数据带宽占满、存储一下子增加了很多。</p><h4 id="6-1-3-基本语法"><a href="#6-1-3-基本语法" class="headerlink" title="6.1.3 基本语法"></a><strong>6.1.3</strong> <strong>基本语法</strong></h4><p>也是 create 语法，会创建一个隐藏的目标表来保存视图数据。也可以 TO 表名，保存到一张显式的表。没有加 TO 表名，表名默认就是 .inner.物化视图名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [MATERIALIZED] <span class="keyword">VIEW</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">TO</span>[db.]name] [ENGINE <span class="operator">=</span> engine] [POPULATE] <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure><p><strong>1）创建物化视图的限制</strong></p><p>1.必须指定物化视图的 engine 用于数据存储</p><p>2.TO [db].[table]语法的时候，不得使用 POPULATE。</p><p>3.查询语句(select）可以包含下面的子句： DISTINCT, GROUP BY, ORDER BY, LIMIT…</p><p>4.物化视图的 alter 操作有些限制，操作起来不大方便。</p><p>5.若物化视图的定义使用了 TO [db.]name 子语句，则可以将目标表的视图 卸载 DETACH 再装载 ATTACH</p><p><strong>2）物化视图的数据更新</strong></p><p>（1）物化视图创建好之后，若源表被写入新数据则物化视图也会同步更新</p><p>（2）POPULATE 关键字决定了物化视图的更新策略：</p><ul><li>若有 POPULATE 则在创建视图的过程会将源表已经存在的数据一并导入，类似于 create table … as</li><li>若无 POPULATE 则物化视图在创建之后没有数据，只会同步之后写入源表的数据</li><li>clickhouse 官方并不推荐使用 POPULATE，因为在创建物化视图的过程中同时写入的数据不能被插入物化视图。</li></ul><p>（3）物化视图不支持同步删除，若源表的数据不存在（删除了）则物化视图的数据仍然保留</p><p>（4）物化视图是一种特殊的数据表，可以用 show tables 查看</p><h3 id="6-2-案例实操"><a href="#6-2-案例实操" class="headerlink" title="6.2 案例实操"></a><strong>6.2</strong> <strong>案例实操</strong></h3><p>对于一些确定的数据模型，可将统计指标通过物化视图的方式进行构建，这样可避免查询时重复计算的过程，物化视图会在有新数据插入时进行更新。</p><h4 id="6-2-1-准备测试用表和数据"><a href="#6-2-1-准备测试用表和数据" class="headerlink" title="6.2.1 准备测试用表和数据"></a><strong>6.2.1</strong> <strong>准备测试用表和数据</strong></h4><p>1）建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.hits_test</span><br><span class="line">(</span><br><span class="line">    `EventDate` <span class="type">Date</span>,</span><br><span class="line">    `CounterID` UInt32,</span><br><span class="line">    `UserID` UInt64,</span><br><span class="line">    `URL` String,</span><br><span class="line">    `Income` UInt8</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">SAMPLE <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span>;</span><br></pre></td></tr></table></figure><p>2）导入一些数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_test <span class="keyword">SELECT</span></span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    UserID,</span><br><span class="line">    URL,</span><br><span class="line">    Income</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line">LIMIT <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h4 id="6-2-2-创建物化视图"><a href="#6-2-2-创建物化视图" class="headerlink" title="6.2.2 创建物化视图"></a><strong>6.2.2</strong> <strong>创建物化视图</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> datasets.hits_mv</span><br><span class="line">ENGINE <span class="operator">=</span> SummingMergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (EventDate, intHash32(UserID)) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate,</span><br><span class="line">    <span class="built_in">count</span>(URL) <span class="keyword">AS</span> ClickCount,</span><br><span class="line">    <span class="built_in">sum</span>(Income) <span class="keyword">AS</span> IncomeSum</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_test</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&gt;=</span> <span class="string">&#x27;2014-03-20&#x27;</span> <span class="comment">-- 设置更新点,该时间点之前的数据可以另外通过 insert into select …… 的方式进行插入</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 或者可以用下列语法，表 A 可以是一张 mergetree 表</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> 物化视图名 <span class="keyword">TO</span> 表 A</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">FROM</span> 表 B; <span class="comment">-- 不建议添加 populate 关键字进行全量更新</span></span><br></pre></td></tr></table></figure><h4 id="6-3-3-导入增量数据"><a href="#6-3-3-导入增量数据" class="headerlink" title="6.3.3 导入增量数据"></a><strong>6.3.3</strong> <strong>导入增量数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入增量数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_test <span class="keyword">SELECT</span></span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    UserID,</span><br><span class="line">    URL,</span><br><span class="line">    Income</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">&gt;=</span> <span class="string">&#x27;2014-03-23&#x27;</span></span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_mv;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918235343145.png" alt="image-20220918235343145"> </p><h4 id="6-3-4-导入历史数据"><a href="#6-3-4-导入历史数据" class="headerlink" title="6.3.4 导入历史数据"></a><strong>6.3.4</strong> <strong>导入历史数据</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入增量数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> datasets.hits_mv <span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate,</span><br><span class="line">    <span class="built_in">count</span>(URL) <span class="keyword">AS</span> ClickCount,</span><br><span class="line">    <span class="built_in">sum</span>(Income) <span class="keyword">AS</span> IncomeSum</span><br><span class="line"><span class="keyword">FROM</span> datasets.hits_test</span><br><span class="line"><span class="keyword">WHERE</span> EventDate <span class="operator">=</span> <span class="string">&#x27;2014-03-20&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate;</span><br><span class="line"><span class="comment">-- 查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> datasets.hits_mv;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220918235440748.png" alt="image-20220918235440748"> </p><h2 id="第-7-章-MaterializeMySQL-引擎"><a href="#第-7-章-MaterializeMySQL-引擎" class="headerlink" title="第 7 章 MaterializeMySQL 引擎"></a><strong>第</strong> <strong>7</strong> <strong>章</strong> <strong>MaterializeMySQL</strong> <strong>引擎</strong></h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a><strong>7.1</strong> <strong>概述</strong></h3><p>MySQL 的用户群体很大，为了能够增强数据的实时性，很多解决方案会利用 binlog 将数据写入到 ClickHouse。为了能够监听 binlog 事件，我们需要用到类似 canal 这样的第三方中间件，这无疑增加了系统的复杂度。</p><p>ClickHouse 20.8.2.3 版本新增加了 MaterializeMySQL 的 database 引擎，该 database 能映射到 MySQL 中的某个 database ，并自动在 ClickHouse 中创建对应的ReplacingMergeTree。ClickHouse 服务做为 MySQL 副本，读取 Binlog 并执行 DDL 和 DML 请求，实现了基于 MySQL Binlog 机制的业务数据库实时同步功能。</p><h4 id="7-1-1-特点"><a href="#7-1-1-特点" class="headerlink" title="7.1.1 特点"></a><strong>7.1.1</strong> <strong>特点</strong></h4><p>（1）MaterializeMySQL 同时支持<strong>全量</strong>和<strong>增量</strong>同步，在 database 创建之初会全量同步 MySQL 中的表和数据，之后则会通过 binlog 进行增量同步。</p><p>（2）MaterializeMySQL database 为其所创建的每张 ReplacingMergeTree 自动增加了 _sign 和 _version 字段。</p><p>其中，_version 用作 ReplacingMergeTree 的 ver 版本参数，每当监听到 insert、update 和 delete 事件时，在 databse 内全局自增。而 _sign 则用于标记是否被删除，取值 1 或者 -1。</p><p>目前 MaterializeMySQL 支持如下几种 binlog 事件：</p><ul><li>MYSQL_WRITE_ROWS_EVENT： _sign &#x3D; 1，_version ++</li><li>MYSQL_DELETE_ROWS_EVENT： _sign &#x3D; -1，_version ++</li><li>MYSQL_UPDATE_ROWS_EVENT：新数据 _sign &#x3D; 1</li><li>MYSQL_QUERY_EVENT：支持 CREATE TABLE 、DROP TABLE 、RENAME TABLE 等。</li></ul><h4 id="7-1-2-使用细则"><a href="#7-1-2-使用细则" class="headerlink" title="7.1.2 使用细则"></a><strong>7.1.2</strong> <strong>使用细则</strong></h4><p><strong>（1）DDL 查询</strong></p><p>MySQL DDL 查询被转换成相应的 ClickHouse DDL 查询（ALTER, CREATE, DROP, RENAME）。如果 ClickHouse 不能解析某些 DDL 查询，该查询将被忽略。</p><p><strong>（2）数据复制</strong></p><p>MaterializeMySQL 不支持直接插入、删除和更新查询，而是将 DDL 语句进行相应转换：</p><p>MySQL INSERT 查询被转换为 INSERT with _sign&#x3D;1。</p><p>MySQL DELETE 查询被转换为 INSERT with _sign&#x3D;-1。</p><p>MySQL UPDATE 查询被转换成 INSERT with _sign&#x3D;1 和 INSERT with _sign&#x3D;-1。</p><p><strong>（3）SELECT 查询</strong></p><p>如果在 SELECT 查询中没有指定_version，则使用 FINAL 修饰符，返回_version 的最大值对应的数据，即最新版本的数据。</p><p>如果在 SELECT 查询中没有指定_sign，则默认使用 WHERE _sign&#x3D;1，即返回未删除状态（_sign&#x3D;1)的数据。</p><p><strong>（4）索引转换</strong></p><p>ClickHouse 数据库表会自动将 MySQL 主键和索引子句转换为 ORDER BY 元组。</p><p>ClickHouse 只有一个物理顺序，由 ORDER BY 子句决定。如果需要创建新的物理顺序，请使用物化视图。</p><h3 id="7-2-案例实操"><a href="#7-2-案例实操" class="headerlink" title="7.2 案例实操"></a><strong>7.2</strong> <strong>案例实操</strong></h3><h4 id="7-2-1-MySQL-开启-binlog-和-GTID-模式"><a href="#7-2-1-MySQL-开启-binlog-和-GTID-模式" class="headerlink" title="7.2.1 MySQL 开启 binlog 和 GTID 模式"></a><strong>7.2.1 MySQL</strong> <strong>开启</strong> <strong>binlog</strong> <strong>和</strong> <strong>GTID</strong> <strong>模式</strong></h4><p><strong>（1）确保 MySQL 开启了 binlog 功能，且格式为 ROW</strong></p><p>打开&#x2F;etc&#x2F;my.cnf，在[mysqld]下添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id=1 </span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure><p><strong>（2）开启 GTID 模式</strong></p><p>如果如果 clickhouse 使用的是 20.8 prestable 之后发布的版本，那么 MySQL 还需要配置开启 GTID 模式, 这种方式在 mysql 主从模式下可以确保数据同步的一致性(主从切换时)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=1 # 设置为主从强一致性</span><br><span class="line">log-slave-updates=1 # 记录日志</span><br></pre></td></tr></table></figure><p>GTID 是 MySQL 复制增强版，从 MySQL 5.6 版本开始支持，目前已经是 MySQL 主流复制模式。它为每个 event 分配一个全局唯一 ID 和序号，我们可以不用关心 MySQL 集群主从拓扑结构，直接告知 MySQL 这个 GTID 即可。</p><p><strong>（3）启用旧的加密方式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_authentication_plugin=mysql_native_password</span><br></pre></td></tr></table></figure><p><strong>（4）重启 MySQL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><h4 id="7-2-2-准备-MySQL-表和数据"><a href="#7-2-2-准备-MySQL-表和数据" class="headerlink" title="7.2.2 准备 MySQL 表和数据"></a><strong>7.2.2</strong> <strong>准备</strong> <strong>MySQL</strong> <strong>表和数据</strong></h4><p><strong>（1）在 MySQL 中创建数据表并写入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE testck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `testck`.`t_organization` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `code` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `name` text <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `updatetime` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> <span class="keyword">UNIQUE</span> KEY (`code`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, name,updatetime) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1000</span>,<span class="string">&#x27;Realinsight&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, name,updatetime) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;Realindex&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, name,updatetime) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1002</span>,<span class="string">&#x27;EDT&#x27;</span>,NOW());</span><br></pre></td></tr></table></figure><p><strong>（2）创建第二张表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `testck`.`t_user` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `code` <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_user (code) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="7-2-3-开启-ClickHouse-物化引擎"><a href="#7-2-3-开启-ClickHouse-物化引擎" class="headerlink" title="7.2.3 开启 ClickHouse 物化引擎"></a><strong>7.2.3</strong> <strong>开启</strong> <strong>ClickHouse</strong> <strong>物化引擎</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> allow_experimental_database_materialize_mysql <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="7-2-4-创建复制管道"><a href="#7-2-4-创建复制管道" class="headerlink" title="7.2.4 创建复制管道"></a><strong>7.2.4</strong> <strong>创建复制管道</strong></h4><p>（1）ClickHouse 中创建 MaterializeMySQL 数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_binlog</span><br><span class="line">ENGINE <span class="operator">=</span> MaterializeMySQL(<span class="string">&#x27;hadoop102:3306&#x27;</span>, <span class="string">&#x27;testck&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;abc123&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中 4 个参数分别是 MySQL 地址、databse、username 和 password。 </p><p>（2）查看 ClickHouse 的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE test_binlog;</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919012323650.png" alt="image-20220919012323650"> </p><h4 id="7-2-5-修改数据"><a href="#7-2-5-修改数据" class="headerlink" title="7.2.5 修改数据"></a><strong>7.2.5</strong> <strong>修改数据</strong></h4><p>（1）在 MySQL 中修改数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_organization <span class="keyword">SET</span> name <span class="operator">=</span> CONCAT(name,<span class="string">&#x27;-v1&#x27;</span>) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>（2）查看 clickhouse 日志可以看到 binlog 监听事件，查询 clickhouse</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919015123209.png" alt="image-20220919015123209"> </p><h4 id="7-2-6-删除数据"><a href="#7-2-6-删除数据" class="headerlink" title="7.2.6 删除数据"></a><strong>7.2.6</strong> <strong>删除数据</strong></h4><p>（1）MySQL 删除数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_organization <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>（2）ClicKHouse，日志有 DeleteRows 的 binlog 监听事件，查看数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br></pre></td></tr></table></figure><p>（3）在刚才的查询中增加 _sign 和 _version 虚拟字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="operator">*</span>,</span><br><span class="line">    _sign,</span><br><span class="line">    _version</span><br><span class="line"><span class="keyword">FROM</span> t_organization</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    _sign <span class="keyword">DESC</span>,</span><br><span class="line">    _version <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919015340982.png" alt="image-20220919015340982"> </p><p>在查询时，对于已经被删除的数据，_sign&#x3D;-1，ClickHouse 会自动重写 SQL，将 _sign &#x3D; -1 的数据过滤掉;</p><p>对于修改的数据，则自动重写 SQL，为其增加 FINAL 修饰符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization;</span><br><span class="line"><span class="comment">-- 等同于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_organization <span class="keyword">FINAL</span> <span class="keyword">WHERE</span> _sign <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="7-2-7-删除表"><a href="#7-2-7-删除表" class="headerlink" title="7.2.7 删除表"></a><strong>7.2.7</strong> <strong>删除表</strong></h4><p>（1）在 mysql 执行删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t_user;</span><br></pre></td></tr></table></figure><p>（2）此时在 clickhouse 处会同步删除对应表，如果查询会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user;</span><br><span class="line"><span class="comment">-- Code: 60. DB::Exception: Received from localhost:9000. DB::Exception: Table test_binlog.t_user doesn&#x27;t exist. </span></span><br></pre></td></tr></table></figure><p>（3）mysql 新建表，clickhouse 可以查询到</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `testck`.`t_user` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `code` <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_user (code) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ClickHouse 查询</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user;</span><br></pre></td></tr></table></figure><h2 id="第-8-章-常见问题排查"><a href="#第-8-章-常见问题排查" class="headerlink" title="第 8 章 常见问题排查"></a><strong>第</strong> <strong>8</strong> <strong>章 常见问题排查</strong></h2><h3 id="8-1-分布式-DDL-某数据节点的副本不执行"><a href="#8-1-分布式-DDL-某数据节点的副本不执行" class="headerlink" title="8.1 分布式 DDL 某数据节点的副本不执行"></a><strong>8.1</strong> <strong>分布式</strong> <strong>DDL</strong> <strong>某数据节点的副本不执行</strong></h3><p><strong>（1）问题：</strong>使用分布式 ddl 执行命令 create table on cluster xxxx 某个节点上没有创建表，但是 client 返回正常，查看日志有如下报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Error&gt; xxx.xxx: Retrying createReplica(), because some other replicas were created at the same time</span><br></pre></td></tr></table></figure><p><strong>（2）解决办法：</strong>重启该不执行的节点。</p><h3 id="8-2-数据副本表和数据不一致"><a href="#8-2-数据副本表和数据不一致" class="headerlink" title="8.2 数据副本表和数据不一致"></a><strong>8.2</strong> <strong>数据副本表和数据不一致</strong></h3><p><strong>（1）问题：</strong>由于某个数据节点副本异常，导致两数据副本表不一致，某个数据副本缺少表，需要将两个数据副本调整一致。</p><p><strong>（2）解决办法：</strong></p><p>在缺少表的数据副本节点上创建缺少的表，创建为本地表，表结构可以在其他数据副本通过 show crete table xxxx 获取。</p><p>表结构创建后，clickhouse 会自动从其他副本同步该表数据，验证数据量是否一致即可。</p><h3 id="8-3-副本节点全量恢复"><a href="#8-3-副本节点全量恢复" class="headerlink" title="8.3 副本节点全量恢复"></a><strong>8.3</strong> <strong>副本节点全量恢复</strong></h3><p><strong>（1）问题：</strong>某个数据副本异常无法启动，需要重新搭建副本。</p><p><strong>（2）解决办法：</strong></p><p>清空异常副本节点的 metadata 和 data 目录。</p><p>从另一个正常副本将 metadata 目录拷贝过来（这一步之后可以启动数据库，但是只有表结构没有数据）。</p><p>执行<code>sudo -u clickhouse touch /data/clickhouse/flags/force_restore_data</code></p><p>启动数据库。</p><h3 id="8-4-数据副本启动缺少-zk-表"><a href="#8-4-数据副本启动缺少-zk-表" class="headerlink" title="8.4 数据副本启动缺少 zk 表"></a><strong>8.4</strong> <strong>数据副本启动缺少</strong> <strong>zk</strong> <strong>表</strong></h3><p><strong>（1）问题：</strong>某个数据副本表在 zk 上丢失数据，或者不存在，但是 metadata 元数据里存在，导致启动异常，报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can’t get data for node /clickhouse/tables/01-02/xxxxx/xxxxxxx/replicas/xxx/metadata: node doesn’t exist (No node): Cannot attach table xxxxxxx</span><br></pre></td></tr></table></figure><p><strong>（2）解决办法：</strong></p><p>metadata 中移除该表的结构文件，如果多个表报错都移除</p><p>mv metadata&#x2F;xxxxxx&#x2F;xxxxxxxx.sql &#x2F;tmp&#x2F;</p><p>启动数据库</p><p>手工创建缺少的表，表结构从其他节点 show create table 获取。</p><p>创建后会自动同步数据，验证数据是否一致。</p><h3 id="8-5-ZK-table-replicas-数据未删除，导致重建表报错"><a href="#8-5-ZK-table-replicas-数据未删除，导致重建表报错" class="headerlink" title="8.5 ZK table replicas 数据未删除，导致重建表报错"></a><strong>8.5 ZK table replicas 数据未删除，导致重建表报错</strong></h3><p><strong>（1）问题：</strong>重建表过程中，先使用 drop table xxx on cluster xxx，各节点在 clickhouse 上 table 已物理删除，但是 zk 里面针对某个 clickhouse 节点的 table meta 信息未被删除（低概率事件），因 zk 里仍存在该表的 meta 信息，导致再次创建该表 create table xxx on cluster, 该节点无法创建表(其他节点创建表成功)，报错：</p><p>Replica &#x2F;clickhouse&#x2F;tables&#x2F;01-03&#x2F;xxxxxx&#x2F;xxx&#x2F;replicas&#x2F;xxx already exists..</p><p><strong>（2）解决办法：</strong></p><p>从其他数据副本 cp 该 table 的 metadata sql 过来。</p><p>重启节点。</p><h3 id="8-6-Clickhouse-节点意外关闭"><a href="#8-6-Clickhouse-节点意外关闭" class="headerlink" title="8.6 Clickhouse 节点意外关闭"></a><strong>8.6 Clickhouse</strong> <strong>节点意外关闭</strong></h3><p><strong>（1）问题：</strong>模拟其中一个节点意外宕机，在大量 insert 数据的情况下，关闭某个节点。</p><p><strong>（2）现象：</strong>数据写入不受影响、数据查询不受影响、建表 DDL 执行到异常节点会卡住，报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code: 159. DB::Exception: Received from localhost:9000. DB::Exception: Watching task /clickhouse/task_queue/ddl/query-0000565925 is executing longer than distributed_ddl_task_timeout (=180) seconds. There are 1 unfinished hosts (0 of them are currently active), they are going to execute the query in background.</span><br></pre></td></tr></table></figure><p><strong>（3）解决办法：</strong>启动异常节点，期间其他副本写入数据会自动同步过来，其他副本的建表 DDL 也会同步。</p><h3 id="8-7-其他问题参考"><a href="#8-7-其他问题参考" class="headerlink" title="8.7 其他问题参考"></a><strong>8.7</strong> <strong>其他问题参考</strong></h3><p><a href="https://help.aliyun.com/document_detail/162815.html?spm=a2c4g.11186623.6.652.312e79bd17U8IO">https://help.aliyun.com/document_detail/162815.html?spm=a2c4g.11186623.6.652.312e79bd17U8IO</a></p><h1 id="第三部分-监控及备份篇"><a href="#第三部分-监控及备份篇" class="headerlink" title="第三部分 监控及备份篇"></a>第三部分 监控及备份篇</h1><h2 id="第-1-章-ClickHouse-监控概述"><a href="#第-1-章-ClickHouse-监控概述" class="headerlink" title="第 1 章 ClickHouse 监控概述"></a><strong>第</strong> <strong>1</strong> <strong>章</strong> <strong>ClickHouse</strong> <strong>监控概述</strong></h2><p>ClickHouse 运行时会将一些个自身的运行状态记录到众多系统表中( system.*)。所以我们对于 CH 自身的一些运行指标的监控数据，也主要来自这些系统表。</p><p>但是直接查询这些系统表会有一些不足之处：</p><ul><li>这种方式太过底层，不够直观，我们还需要在此之上实现可视化展示； </li><li>系统表只记录了 CH 自己的运行指标，有些时候我们需要外部系统的指标进行关联分析，例如 ZooKeeper、服务器 CPU、IO 等等。</li></ul><p>现在 Prometheus + Grafana 的组合比较流行，安装简单易上手，可以集成很多框架，包括服务器的负载，其中 Prometheus 负责收集各类系统的运行指标；Grafana 负责可视化的部分。</p><p>ClickHouse 从 <strong>v20.1.2.4</strong> 开始，内置了对接 Prometheus 的功能，配置的方式也很简单，可以将其作为 Prometheus 的 Endpoint 服务，从而自动的将 metrics 、 events 和 asynchronous_metrics 三张系统的表的数据发送给 Prometheus。 </p><h2 id="第-2-章-Prometheus-amp-Grafana-的安装"><a href="#第-2-章-Prometheus-amp-Grafana-的安装" class="headerlink" title="第 2 章 Prometheus&amp;Grafana 的安装"></a><strong>第</strong> <strong>2</strong> <strong>章</strong> <strong>Prometheus&amp;Grafana</strong> <strong>的安装</strong></h2><p>Prometheus 下载地址：<a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p><p>Grafana 下载地址：<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p><h3 id="2-1-安装-Prometheus"><a href="#2-1-安装-Prometheus" class="headerlink" title="2.1 安装 Prometheus"></a><strong>2.1</strong> <strong>安装</strong> <strong>Prometheus</strong></h3><p>Prometheus 基于 Golang 编写，编译后的软件包，不依赖于任何的第三方依赖。只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动 Prometheus Server。</p><h4 id="2-1-1-上传安装包"><a href="#2-1-1-上传安装包" class="headerlink" title="2.1.1 上传安装包"></a><strong>2.1.1</strong> <strong>上传安装包</strong></h4><p>上传 prometheus-2.37.1.linux-amd64.tar.gz 到虚拟机的&#x2F;opt&#x2F;software 目录</p><h4 id="2-1-2-解压安装包"><a href="#2-1-2-解压安装包" class="headerlink" title="2.1.2 解压安装包"></a><strong>2.1.2</strong> <strong>解压安装包</strong></h4><p>（1）解压到&#x2F;opt&#x2F;module 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf prometheus-2.37.1.linux-amd64.tar.gz -C /opt/module</span><br></pre></td></tr></table></figure><p>（2）修改目录名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/module</span><br><span class="line">mv prometheus-2.37.1.linux-amd64 prometheus-2.37.1</span><br></pre></td></tr></table></figure><h4 id="2-1-3-修改配置文件-prometheus-yml"><a href="#2-1-3-修改配置文件-prometheus-yml" class="headerlink" title="2.1.3 修改配置文件 prometheus.yml"></a><strong>2.1.3</strong> <strong>修改配置文件</strong> <strong>prometheus.yml</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim prometheus.yml</span><br></pre></td></tr></table></figure><p>在 scrape_configs 配置项下添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;prometheus&quot;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;localhost:9090&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">#添加 ClickHouse 监控配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;clickhouse&quot;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9363&#x27;</span>]</span><br></pre></td></tr></table></figure><p>配置说明：</p><p><strong>1、global 配置块：</strong>控制 Prometheus 服务器的全局配置</p><ul><li>scrape_interval：配置拉取数据的时间间隔，默认为 1 分钟。</li><li>evaluation_interval：规则验证（生成 alert）的时间间隔，默认为 1 分钟。</li></ul><p><strong>2、rule_files 配置块：</strong>规则配置文件</p><p><strong>3、scrape_configs 配置块：</strong>配置采集目标相关， prometheus 监视的目标。Prometheus 自身的运行信息可以通过 HTTP 访问，所以 Prometheus 可以监控自己的运行数据。</p><ul><li>job_name：监控作业的名称</li><li>static_configs：表示静态目标配置，就是固定从某个 target 拉取数据</li><li>targets ： 指定监控的目 标，其实就是从哪儿拉取数据。 Prometheus会从<a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a> 上拉取数据。</li></ul><p><strong>Prometheus</strong> <strong>是可以在运行时自动加载配置的。启动时需要添加：–web.enable-lifecycle</strong></p><h4 id="2-1-4-启动-Prometheus-Server"><a href="#2-1-4-启动-Prometheus-Server" class="headerlink" title="2.1.4 启动 Prometheus Server"></a><strong>2.1.4</strong> <strong>启动</strong> <strong>Prometheus Server</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./prometheus --config.file=prometheus.yml &gt; ./prometheus.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><ul><li>浏览器输入：<a href="http://hadoop102:9090/">http://hadoop102:9090/</a> </li><li>点击 Status，选中 Targets：</li></ul><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919231551890.png" alt="image-20220919231551890"> </p><p>prometheus 是 up 状态，表示安装启动成功</p><h3 id="2-2-Grafana-安装"><a href="#2-2-Grafana-安装" class="headerlink" title="2.2 Grafana 安装"></a><strong>2.2 Grafana</strong> <strong>安装</strong></h3><h4 id="2-2-1-上传并解压"><a href="#2-2-1-上传并解压" class="headerlink" title="2.2.1 上传并解压"></a><strong>2.2.1</strong> <strong>上传并解压</strong></h4><p>（1）将 grafana-9.1.5.linux-amd64.tar.gz 上传至&#x2F;opt&#x2F;software&#x2F;目录下，解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf grafana-9.1.5.linux-amd64.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure><p>（2）更改名字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/module</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果解压后就是grafana-9.1.5，无需更改名字</span></span><br><span class="line">mv grafana-9.1.5.linux-amd64 grafana-9.1.5</span><br></pre></td></tr></table></figure><h4 id="2-2-2-启动-Grafana"><a href="#2-2-2-启动-Grafana" class="headerlink" title="2.2.2 启动 Grafana"></a><strong>2.2.2</strong> <strong>启动</strong> <strong>Grafana</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./bin/grafana-server web &gt; ./grafana.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>打开 web：<a href="http://hadoop102:3000，默认用户名和密码：admin">http://hadoop102:3000，默认用户名和密码：admin</a></p><h2 id="第-3-章-ClickHouse-配置"><a href="#第-3-章-ClickHouse-配置" class="headerlink" title="第 3 章 ClickHouse 配置"></a><strong>第</strong> <strong>3</strong> <strong>章</strong> <strong>ClickHouse</strong> <strong>配置</strong></h2><h3 id="3-1-修改配置文件"><a href="#3-1-修改配置文件" class="headerlink" title="3.1 修改配置文件"></a><strong>3.1</strong> <strong>修改配置文件</strong></h3><p>编辑 &#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml，打开如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prometheus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endpoint</span>&gt;</span>/metrics<span class="tag">&lt;/<span class="name">endpoint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9363<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">metrics</span>&gt;</span>true<span class="tag">&lt;/<span class="name">metrics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">events</span>&gt;</span>true<span class="tag">&lt;/<span class="name">events</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asynchronous_metrics</span>&gt;</span>true<span class="tag">&lt;/<span class="name">asynchronous_metrics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">status_info</span>&gt;</span>true<span class="tag">&lt;/<span class="name">status_info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">prometheus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果有多个 CH 节点，分发配置。</p><h3 id="3-2-重启-ClickHouse"><a href="#3-2-重启-ClickHouse" class="headerlink" title="3.2 重启 ClickHouse"></a><strong>3.2</strong> <strong>重启</strong> <strong>ClickHouse</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure><h3 id="3-3-访问-Web-查看"><a href="#3-3-访问-Web-查看" class="headerlink" title="3.3 访问 Web 查看"></a><strong>3.3</strong> <strong>访问</strong> <strong>Web</strong> <strong>查看</strong></h3><p>浏览器打开：<a href="http://hadoop102:9363/metrics">http://hadoop102:9363/metrics</a></p><p>看到信息说明 ClickHouse 开启 Metrics 服务成功。</p><h2 id="第-4-章-Grafana-集成-Prometheus"><a href="#第-4-章-Grafana-集成-Prometheus" class="headerlink" title="第 4 章 Grafana 集成 Prometheus"></a><strong>第</strong> <strong>4</strong> <strong>章</strong> <strong>Grafana</strong> <strong>集成</strong> <strong>Prometheus</strong></h2><h3 id="4-1-添加数据源-Prometheus"><a href="#4-1-添加数据源-Prometheus" class="headerlink" title="4.1 添加数据源 Prometheus"></a><strong>4.1</strong> <strong>添加数据源</strong> <strong>Prometheus</strong></h3><p>（1）点击配置，点击 Data Sources：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233133263.png" alt="image-20220919233133263"> </p><p>（2）点击添加按钮：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233157294.png" alt="image-20220919233157294"> </p><p>（3）找到 Prometheus，单击</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233250177.png" alt="image-20220919233250177"> </p><p>（4）配置 Prometheus Server 地址：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233335904.png" alt="image-20220919233335904"> </p><p>（5）点击下方的 Save&amp;Test：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233415554.png" alt="image-20220919233415554"> </p><p>（6）出现绿色的提示框，表示与 Prometheus 正常联通：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233441963.png" alt="image-20220919233441963"> </p><p>（7）点击 Back 返回即可，可以看到 Data Sources 页面，出现了添加的 Prometheus:</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233611772.png" alt="image-20220919233611772"> </p><h3 id="4-2-添加监控"><a href="#4-2-添加监控" class="headerlink" title="4.2 添加监控"></a><strong>4.2</strong> <strong>添加监控</strong></h3><p>手动一个个添加 Dashboard 比较繁琐，Grafana 社区鼓励用户分享 Dashboard，通过 <a href="https://grafana.com/dashboards">https://grafana.com/dashboards</a> 网站，可以找到大量可直接使用的 Dashboard 模板。</p><p>Grafana 中所有的 Dashboard 通过 JSON 进行共享，下载并且导入这些 JSON 文件，就可以直接使用这些已经定义好的 Dashboard。 </p><p>（1）点击左侧 ”+”号，选择 import：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919233900458.png" alt="image-20220919233900458"> </p><p>（2）上传 JSON 文件：</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220919234258621.png" alt="image-20220919234258621"> </p><h2 id="第-5-章-备份及恢复"><a href="#第-5-章-备份及恢复" class="headerlink" title="第 5 章 备份及恢复"></a><strong>第</strong> <strong>5</strong> <strong>章 备份及恢复</strong></h2><p>官网：<a href="https://clickhouse.com/docs/en/operations/backup/">https://clickhouse.com/docs/en/operations/backup/</a></p><h3 id="5-1-手动实现备份及恢复"><a href="#5-1-手动实现备份及恢复" class="headerlink" title="5.1 手动实现备份及恢复"></a><strong>5.1</strong> <strong>手动实现备份及恢复</strong></h3><p>ClickHouse 允许使用 ALTER TABLE … FREEZE PARTITION … 查询以创建表分区的本地副本。这是利用硬链接(hardlink)到 &#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;shadow&#x2F; 文件夹中实现的，所以它通常不会因为旧数据而占用额外的磁盘空间。 创建的文件副本不由 ClickHouse 服务器处理，所以不需要任何额外的外部系统就有一个简单的备份。防止硬件问题，最好将它们远程复制到另一个位置，然后删除本地副本。</p><h4 id="5-1-1-创建备份路径"><a href="#5-1-1-创建备份路径" class="headerlink" title="5.1.1 创建备份路径"></a><strong>5.1.1</strong> <strong>创建备份路径</strong></h4><p>（1）创建用于存放备份数据的目录 shadow</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/lib/clickhouse/shadow/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改所属组</span></span><br><span class="line">chown clickhouse:clickhouse /var/lib/clickhouse/shadow</span><br></pre></td></tr></table></figure><p><strong>如果目录存在，先清空目录下的数据</strong></p><h4 id="5-1-2-执行备份命令"><a href="#5-1-2-执行备份命令" class="headerlink" title="5.1.2 执行备份命令"></a><strong>5.1.2</strong> <strong>执行备份命令</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &#x27;alter table t_order_mt freeze&#x27; | clickhouse-client [--password]</span><br></pre></td></tr></table></figure><h4 id="5-1-3-将备份数据保存到其他路径"><a href="#5-1-3-将备份数据保存到其他路径" class="headerlink" title="5.1.3 将备份数据保存到其他路径"></a><strong>5.1.3</strong> <strong>将备份数据保存到其他路径</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建备份存储路径</span></span><br><span class="line">sudo mkdir -p /var/lib/clickhouse/backup/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改所属组</span></span><br><span class="line">chown clickhouse:clickhouse /var/lib/clickhouse/backup</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝数据到备份路径</span></span><br><span class="line">sudo cp -r /var/lib/clickhouse/shadow/ /var/lib/clickhouse/backup/my-backup-name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为下次备份准备，删除 shadow 下的数据</span></span><br><span class="line">sudo rm -rf /var/lib/clickhouse/shadow/*</span><br></pre></td></tr></table></figure><h4 id="5-1-4-恢复数据"><a href="#5-1-4-恢复数据" class="headerlink" title="5.1.4 恢复数据"></a><strong>5.1.4</strong> <strong>恢复数据</strong></h4><p>（1）模拟删除备份过的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;drop table t_order_mt&#x27; | clickhouse-client [--password]</span><br></pre></td></tr></table></figure><p>（2）重新创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br></pre></td></tr></table></figure><p>（3）将备份复制到 detached 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rl backup/my-backup-name/1/store/d0e/d0ec02eb-e896-4fee-90ec-02ebe896cfee/* data/default/t_order_mt/detached/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改该目录及其下文件所属组</span></span><br><span class="line">chown -R clickhouse:clickhouse data/default/t_order_mt/detached</span><br></pre></td></tr></table></figure><p>ClickHouse 使用文件系统硬链接来实现即时备份，而不会导致 ClickHouse 服务停机（或锁定）。这些硬链接可以进一步用于有效的备份存储。在支持硬链接的文件系统（例如本地文件系统或 NFS）上，将 cp 与 -l 标志一起使用（或将 rsync 与 –hard-links 和 –numeric-ids 标志一起使用）以避免复制数据。</p><p><strong>注意：仅拷贝分区目录，注意目录所属的用户要是 clickhouse</strong></p><p>（4）执行 attach</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;alter table t_order_mt attach partition 20200601&#x27; | clickhouse-client [--password]</span><br></pre></td></tr></table></figure><p>（5）查看数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;select count() from t_order_mt&#x27; | clickhouse-client [--password]</span><br></pre></td></tr></table></figure><h3 id="5-2-使用-clickhouse-backup"><a href="#5-2-使用-clickhouse-backup" class="headerlink" title="5.2 使用 clickhouse-backup"></a><strong>5.2</strong> <strong>使用</strong> <strong>clickhouse-backup</strong></h3><p>上面的过程，我们可以使用 Clickhouse 的备份工具 <strong>clickhouse-backup</strong> 帮我们自动化实现。</p><p>工具地址：<a href="https://github.com/AlexAkulov/clickhouse-backup/">https://github.com/AlexAkulov/clickhouse-backup/</a></p><h4 id="5-2-1-上传并安装"><a href="#5-2-1-上传并安装" class="headerlink" title="5.2.1 上传并安装"></a><strong>5.2.1</strong> <strong>上传并安装</strong></h4><p>将 clickhouse-backup-2.0.0-1.x86_64.rpm 上传至&#x2F;opt&#x2F;software&#x2F;目录下，安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh clickhouse-backup-2.0.0-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h4 id="5-2-2-配置文件"><a href="#5-2-2-配置文件" class="headerlink" title="5.2.2 配置文件"></a><strong>5.2.2</strong> <strong>配置文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件名</span></span><br><span class="line">mv /etc/clickhouse-backup/config.yml.example /etc/clickhouse-backup/config.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置文件</span></span><br><span class="line">cat /etc/clickhouse-backup/config.yml</span><br></pre></td></tr></table></figure><p>如果配置了密码，则需要修改配置文件</p><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BClickHouse/image-20220920002936444.png" alt="image-20220920002936444"> </p><h4 id="5-2-3-创建备份"><a href="#5-2-3-创建备份" class="headerlink" title="5.2.3 创建备份"></a><strong>5.2.3</strong> <strong>创建备份</strong></h4><p>（1）查看可用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-backup help</span><br></pre></td></tr></table></figure><p>（2）显示要备份的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-backup tables</span><br></pre></td></tr></table></figure><p>（3）创建备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse-backup create</span><br></pre></td></tr></table></figure><p>（4）查看现有的本地备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse-backup list</span><br></pre></td></tr></table></figure><p>备份存储在 &#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;backup&#x2F;BACKUPNAME。备份名称默认为日期，但是可以选择使用 –name 标志指定备份名称。备份包含两个目录：一个“metadata”目录，其中包含重新创建架构所需的 DDL SQL 语句；以及一个“shadow”目录，其中包含作为 ALTER TABLE … FREEZE 操作结果的数据。</p><h4 id="5-2-4-从备份恢复数据"><a href="#5-2-4-从备份恢复数据" class="headerlink" title="5.2.4 从备份恢复数据"></a><strong>5.2.4</strong> <strong>从备份恢复数据</strong></h4><p>（1）模拟删除备份过的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;drop table t_order_rmt&#x27; | clickhouse-client [--password]</span><br></pre></td></tr></table></figure><p>（2）从备份还原</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse-backup restore -t default.t_order_rmt 2022-09-19T16-31-15</span><br></pre></td></tr></table></figure><p>–schema 参数：只还原表结构。</p><p>–data 参数：只还原数据。</p><p>–table 参数：备份（或还原）特定表。也可以使用一个正则表达式，例如，针对特定的数据库：–table&#x3D;dbname.*。 </p><blockquote><p>注意：实测，一定要添加 –table 参数，否则不仅恢复不成功，还会清空数据库！</p></blockquote><h4 id="5-2-5-其他说明"><a href="#5-2-5-其他说明" class="headerlink" title="5.2.5 其他说明"></a><strong>5.2.5</strong> <strong>其他说明</strong></h4><p>（1）API 文档：<a href="https://github.com/AlexAkulov/clickhouse-backup#api">https://github.com/AlexAkulov/clickhouse-backup#api</a></p><p>（2）注意事项：切勿更改文件夹 &#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;backup 的权限，可能会导致数据损坏。</p><p>（3）远程备份</p><ul><li>上传到远程存储：sudo clickhouse-backup upload xxxx</li><li>从远程存储下载：sudo clickhouse-backup download xxxx</li><li>保存周期： <ul><li>backups_to_keep_local，本地保存周期，单位天</li><li>backups_to_keep_remote，远程存储保存周期，单位天</li><li>0 均表示不删除</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://www.bilibili.com/video/BV1Yh411z7os?spm_id_from=333.999.0.0">一套上手ClickHouse-OLAP分析引擎，囊括Prometheus与Grafana</a></p><p>[2] <a href="https://clickhouse.com/docs/en/intro/">ClickHouse 官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ClickHouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce入门学习</title>
      <link href="/2023/02/11/MapReduce%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/02/11/MapReduce%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://i.loli.net/2020/01/16/WozdMtRy59OEF2L.png" alt="MapTask.png"></p><p><img src="https://i.loli.net/2020/01/16/jB6t9W7GTAagwZD.png" alt="ReduceTask.png"></p><p><img src="https://i.loli.net/2020/01/16/yBRLZj7fSMmub34.png" alt="Shuffer.png"></p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>逻辑上可以这样划分：1-10是MapTask ；11-16是ReduceTask；7-14是shuffer</p><h2 id="1-待处理文本"><a href="#1-待处理文本" class="headerlink" title="1. 待处理文本"></a><strong>1. 待处理文本</strong></h2><p>这里假设是<code>/user/input</code>目录下的<code>ss.txt</code> 文件，大小为<strong>200M</strong>。</p><h2 id="2-客户端submit（）"><a href="#2-客户端submit（）" class="headerlink" title="2. 客户端submit（）"></a><strong>2. 客户端submit（）</strong></h2><p>发生在client端，主要获取3个信息：</p><p>（1）<strong>Job.split</strong> ：找到文件ss.txt，根据切片算法，得到切片的元数据信息（起始位置，长度以及所在节点等）如把ss.txt分成两片 0-128M 和 128M-200M</p><p>（2）<strong>Job.xml</strong>：任务的配置信息</p><p>（3）<strong>wc.jar</strong>：任务的jar包</p><h2 id="3-提交信息"><a href="#3-提交信息" class="headerlink" title="3. 提交信息"></a><strong>3. 提交信息</strong></h2><p>将刚刚获取的任务规划信息，提交到资源管理器上，我们这里用Yarn。</p><h2 id="4-RM计算MapTask数量"><a href="#4-RM计算MapTask数量" class="headerlink" title="4. RM计算MapTask数量"></a><strong>4. RM计算MapTask数量</strong></h2><p>接着向Yarn的RM申请资源，RM根据任务规划信息用户Job分成Task，并把任务下发给节点。这里我们数据分成了2片，根据默认规则，会有2个MapTask各自处理一片数据。</p><h2 id="5-根据采用的InputFormat读取数据"><a href="#5-根据采用的InputFormat读取数据" class="headerlink" title="5. 根据采用的InputFormat读取数据"></a><strong>5. 根据采用的InputFormat读取数据</strong></h2><p>这里采用默认的TextInputFormat类，按行读取每条记录。key是行偏移量，value是该行的内容。</p><h2 id="6-执行Mapper的map"><a href="#6-执行Mapper的map" class="headerlink" title="6. 执行Mapper的map()"></a><strong>6. 执行Mapper的map()</strong></h2><p>根据用户的代码执行map逻辑，把结果写入Context中。</p><h2 id="7-向环形缓存区写入数据"><a href="#7-向环形缓存区写入数据" class="headerlink" title="7. 向环形缓存区写入数据"></a><strong>7. 向环形缓存区写入数据</strong></h2><p>环形缓存区取一点：一边写索引，一边写真实数据。达到80%时发生溢写</p><h2 id="8-分区、排序"><a href="#8-分区、排序" class="headerlink" title="8. 分区、排序"></a><strong>8. 分区、排序</strong></h2><p>一种2次排序，先按区号排，再对key排序（快排）。得到一组按区排好序的数据。注意：这步是在环形缓存区就可以执行的，且排序排的是索引，真实数据不用动。且此时可以使用第一次Combiner合并操作。</p><h2 id="9-溢出写入文件"><a href="#9-溢出写入文件" class="headerlink" title="9. 溢出写入文件"></a><strong>9. 溢出写入文件</strong></h2><p>环形缓存区达到80%时，溢写到磁盘上。注意写磁盘前已经完成了分区、排序、合并、压缩等操作。此时生成第一组溢写文件<code>spillN.out</code> 与元数据<code>spillN.out.index</code>。</p><h2 id="10-MapTask的归并排序"><a href="#10-MapTask的归并排序" class="headerlink" title="10. MapTask的归并排序"></a><strong>10. MapTask的归并排序</strong></h2><p>将多组溢写文件，以分区为单位进行归并排序，写入磁盘形成大文件<code>output/file.out</code>，与索引文件<code>output/file.out.index</code>。此时一个MapTask任务完成，得到一个分区有序的数据。注意：在归并排序时可以使用第二次Combiner合并操作。</p><h2 id="11-启动ReduceTask"><a href="#11-启动ReduceTask" class="headerlink" title="11. 启动ReduceTask"></a><strong>11. 启动ReduceTask</strong></h2><p>假设分区数为2，此时启动2个ReduceTask，一个ReduceTask处理一个区的数据。</p><h2 id="12-copy数据"><a href="#12-copy数据" class="headerlink" title="12. copy数据"></a><strong>12. copy数据</strong></h2><p>ReduceTask从各个MapTask上拷贝它要处理的区的数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p><h2 id="13-ReduceTask的归并排序"><a href="#13-ReduceTask的归并排序" class="headerlink" title="13. ReduceTask的归并排序"></a><strong>13. ReduceTask的归并排序</strong></h2><p>把同区的数据复制到同一个ReduceTask后，对它们进行归并排序</p><h2 id="14-分组"><a href="#14-分组" class="headerlink" title="14. 分组"></a><strong>14. 分组</strong></h2><p>默认把key相同的数据分到一组。用户可以继承WritableComparator，自定义分组规则。</p><h2 id="15-执行Reducer的Reduce"><a href="#15-执行Reducer的Reduce" class="headerlink" title="15. 执行Reducer的Reduce()"></a><strong>15. 执行Reducer的Reduce()</strong></h2><p>根据用户的代码执行reduce逻辑，把结果写入Context中。注意：一次读一组，value是迭代器对象，包含一个组的全部数据。</p><h2 id="16-根据采用的OutputFormat读取数据"><a href="#16-根据采用的OutputFormat读取数据" class="headerlink" title="16. 根据采用的OutputFormat读取数据"></a><strong>16. 根据采用的OutputFormat读取数据</strong></h2><p>这里采用默认的TextOutputFormat类，按行写入key和value，key和value用tab分开。</p><h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><h2 id="1个逻辑"><a href="#1个逻辑" class="headerlink" title="1个逻辑"></a><strong>1个逻辑</strong></h2><p><strong>先分区 -&gt; 再排序 -&gt; 再分组</strong></p><p>分区：用户定义分区数后，默认按hash分区。用户也可以继承<code>Partitioner</code>，自定义分区规则。ReduceTask的个数一般等于分区数。</p><p>排序：默认对key排序，key必须实现<code>WritableComparable</code>接口。用户可以重写<code>WritableComparable</code>接口的<code>compareTo()</code>方法，定义自己的排序规则。</p><p>分组：默认把key相同的数据分到一组。用户也可以继承WritableComparator，自定义分组规则。用于reduce阶段，一次读取一组.</p><h2 id="2次合并"><a href="#2次合并" class="headerlink" title="2次合并"></a><strong>2次合并</strong></h2><p>Combiner的父类就是Reducer，它可以通过对Map阶段的局部结果进行汇总，减少输出。</p><p>时机： 2次，<strong>分区排序后、MapTask的归并排序时</strong>。</p><p>条件：不能影响业务逻辑 且 输入输出的范型一致</p><h2 id="3次排序"><a href="#3次排序" class="headerlink" title="3次排序"></a><strong>3次排序</strong></h2><p>MapTask：</p><p><strong>分区排序</strong>：在缓行缓冲区进行，是一种2次排序。先按分区号排序，再对key排序（快排）。</p><p><strong>归并排序</strong>：对每组溢写的数据，进行的按区，归并排序。</p><p>ReduceTask：</p><p><strong>归并排序</strong>：对从MapTask拷贝的同区数据，进行的归并排序。</p><h2 id="分片和分区"><a href="#分片和分区" class="headerlink" title="分片和分区"></a><strong>分片和分区</strong></h2><p>分片：<strong>分片数决定MapTask的个数</strong>。在客户端即完成，举FileInputFormat切片机制为例：简单的按文件长度进行切片，切片大小等于块大小（默认128M），切片时是对文件单独切片。</p><p>分区：<strong>分区数决定ReduceTask的个数</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS入门学习</title>
      <link href="/2023/02/11/HDFS%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/02/11/HDFS%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>介绍了HDFS读写数据、NameNode和SecondaryNameNode、DataNode和NameNode的交互</p><h1 id="HDFS写数据"><a href="#HDFS写数据" class="headerlink" title="HDFS写数据"></a>HDFS写数据</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://i.loli.net/2020/01/16/J7wzPWbQpBIgsH3.png" alt="readHDFS.png"></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>客户端调用DS模块向NameNode请求上传文件。</li><li>NameNode会检查目标文件和父目录是否已存在，再返回是否可以上传</li><li>假设文件为200M，客户端请求上传第一个 Block ，希望得到DataNode服务器位置。</li><li>NameNode返回3个DataNode节点，分别为dn1、dn2、dn3，用它们存储数据。</li><li>客户端通过FSDataOutputStream模块请求dn1建立上传数据通道，dn1收到请求会继续请求dn2，然后dn2请求dn3，直到将这个通信管道建立完成。</li><li>dn3、dn2、dn1逐级应答客户端。</li><li>客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。（类似队列，以Packet为单位）</li><li>当一个Block（0-128M）传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。</li><li>向NameNode汇报上传完毕。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>DataNode位置选择，以默认3副本为例：第一个副本是最近的一般是它自己；第二个副本选择同一机架（同一路由）的不同节点；第三个副本是另一机架的随机节点。</li><li>数据传递以包为单位，第一个节点收到一个包，就把包传递给下一个DataNode。并不是等数据传完，再传递。</li></ul><h1 id="HDFS读数据"><a href="#HDFS读数据" class="headerlink" title="HDFS读数据"></a>HDFS读数据</h1><h2 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://i.loli.net/2020/01/16/nh45VUlZBjywe1d.png" alt="writeHDFS.png"></p><h2 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>客户端调用DS模块向NameNode请求下载文件。</li><li>NameNode会检查目标文件是否存在，再通过查询元数据，返回文件块所在的DataNode地址。</li><li>客户端通过FSDataInputStream模块向dn1（就近挑选）请求读取 Block1。</li><li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。</li><li>当一个Block（0-128M）传输完成之后，客户端再次请求下载Block2。（重复执行2-4步）。</li><li>向NameNode汇报下载完毕。</li></ol><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>如果块的第一个副本请求失败，会向第二个副本请求，依次类推。</li></ul><h1 id="NameNode和SecondaryNameNode"><a href="#NameNode和SecondaryNameNode" class="headerlink" title="NameNode和SecondaryNameNode"></a>NameNode和SecondaryNameNode</h1><h2 id="流程图-2"><a href="#流程图-2" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://i.loli.net/2020/01/16/oTxaRfPXkVrsO2g.png" alt="NNand2NN.png"></p><h2 id="具体步骤-2"><a href="#具体步骤-2" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>第一阶段：NameNode</p><ol><li>第一次启动NameNode（格式化）后，会创建Fsimage（镜像文件）和Edits（编辑日志）文件。以后启动，会直接加载镜像文件和编辑日志到内存，此时会进行合并操作。</li><li>假设此时客户端提出了增删改的请求。</li><li>NameNode记录之前的编辑日志（edits_n），更新新日志到滚动日志（edits_inprogress_n）中。</li><li>日志记录完毕后，NameNode在内存中对数据进行增删改。</li></ol><p>第二阶段：SecondaryNameNode</p><ol><li>Secondary NameNode向NameNode询问是否需要CheckPoint。</li><li>如果需要，Secondary NameNode请求执行CheckPoint。</li><li>NameNode滚动日志。</li><li>将滚动前的编辑日志（edits_001）和镜像文件(fsimage)拷贝到Secondary NameNode。</li><li>Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</li><li>合并后，生成新的镜像文件fsimage.chkpoint。</li><li>拷贝fsimage.chkpoint到NameNode。</li><li>NameNode将fsimage.chkpoint重新命名成fsimage。</li></ol><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>Fsimage 和 Edits文件？</li></ul><p>fsimage是NameNode内存中元数据序列化后形成的文件。Edits中记录客户端更新元数据信息的每一步操作。每次执行增删改时，先改日志再改文件。好处是：如果保证中途gg，可以保证操作不丢失，便于复原。</p><ul><li>为啥要Secondary NameNode？</li></ul><p>首先要知道只有NameNode重启时，edit.log才会合并到fsimage文件中，所以运行时间久了就会有3个问题：edis.log文件会变的很大；NameNode下次重启会花费很长时间；fsimage文件文件很旧，如果中途挂掉就很睿智。</p><p>为了解决上述问题，SecondaryNameNode诞生，每隔一定时间辅助合并NameNode的edit.log到fsimage文件中。从上述流程图就可以发现，它做的就是这个。</p><ul><li>什么时候执行CheckPoint？</li></ul><p>（1） 用户定时 （2）edit.log 满了</p><ul><li>Secondary NameNode是热备份吗？</li></ul><p>不是，可以发现Secondary NameNode合并的是滚动前的edis，它总是比NameNode的编辑日志少一点。</p><h1 id="DataNode和NameNode"><a href="#DataNode和NameNode" class="headerlink" title="DataNode和NameNode"></a>DataNode和NameNode</h1><h2 id="流程图-3"><a href="#流程图-3" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://i.loli.net/2020/01/16/Gz1VEYR7hq32ymX.png" alt="DataNode.png"></p><h2 id="具体步骤-3"><a href="#具体步骤-3" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>DataNode启动后向NameNode注册。</li><li>NameNode告知注册成功。</li><li>DataNode周期性（1小时）的向NameNode上报所有的块信息。</li><li>DataNode每3秒发送一次心跳，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。</li><li>超过10分钟没有收到心跳，表示该节点不可用。</li></ol><h2 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度、校验和 以及时间戳。</li><li>节点增加：新节点配置好后，自动向NameNode注册的。</li><li>节点退役：NameNode可以通过白名单指定需要的节点；通过黑名单指定不要的节点。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fireReport</title>
      <link href="/2023/02/11/fireReport/"/>
      <url>/2023/02/11/fireReport/</url>
      
        <content type="html"><![CDATA[<h2 id="帆软普通报表入门示例"><a href="#帆软普通报表入门示例" class="headerlink" title="帆软普通报表入门示例"></a>帆软普通报表入门示例</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>​报表设计主要可以分为新建报表、数据准备、报表主体设计、报表预览几大部分。其中报表主体可以分为大标题、小标题、表格数据、结尾几大部分，本文主要以普通报表为例，讲述如何按照报表设计流程快速设计一张报表。</p><h4 id="1、1-预期效果"><a href="#1、1-预期效果" class="headerlink" title="1、1 预期效果"></a>1、1 预期效果</h4><p><img src="/2023/02/11/fireReport/image-20230117173031755.png" alt="image-20230117173031755"></p><h3 id="2、报表开发"><a href="#2、报表开发" class="headerlink" title="2、报表开发"></a>2、报表开发</h3><p>​新建数据连接，打开设计器，点击最上方菜单栏中「服务器&gt;定义数据连接」，弹出「定义数据连接」对话框，设计器已经默认连接了一个名为 FRDemo 的内置数据库，点击「测试链接」，弹出「连接成功」提示框，表示数据库 FRDemo 成功与设计器建立连接。</p><p><img src="/2023/02/11/fireReport/image-20230117173352327.png" alt="image-20230117173352327"></p><h4 id="2-2-新建报表"><a href="#2-2-新建报表" class="headerlink" title="2.2 新建报表"></a>2.2 新建报表</h4><p>​菜单栏点击「文件」可选择新建报表的类型，或点击快捷按钮<img src="https://help.fanruan.com/finereport/uploads/20220217/1645066223l8aC.png" alt="img">，快速新建一张空白的「普通报表」。如下图所示：</p><p><img src="https://help.fanruan.com/finereport/uploads/20220217/1645066260ZwPP.png" alt="img"></p><h4 id="2-3-准备数据"><a href="#2-3-准备数据" class="headerlink" title="2.3 准备数据"></a>2.3 准备数据</h4><p>​数据集是报表设计时的直接数据来源。数据集按照作用范围分为两种：服务器数据集 和 模板数据集。</p><p>服务器数据所有模版可用，模版数据集只有该模版才可用。</p><p>1）本示例在数据集管理面板中选择「模板数据集」，点击上方的【+】，新建【数据库查询】，输入 SQL 查询语句取出表中的所有数据。</p><p>ps：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">rownum,</span><br><span class="line">cdsr.company_code,</span><br><span class="line">cdsr.business_account_period,</span><br><span class="line">cdsr.&quot;business_cost&quot;,</span><br><span class="line">t1.meaning <span class="keyword">as</span> &quot;business_task&quot;,</span><br><span class="line">cdsr.&quot;mkt&quot;,</span><br><span class="line">cdsr.&quot;pro&quot;,</span><br><span class="line">cdsr.&quot;sit&quot;,</span><br><span class="line">cdsr.&quot;ve2&quot;,</span><br><span class="line">cdsr.&quot;ntv&quot;,</span><br><span class="line">cdsr.&quot;stm&quot;,</span><br><span class="line">cdsr.&quot;dimension_amount&quot; cur_dimension_amount,</span><br><span class="line">(<span class="keyword">select</span> dimension_amount <span class="keyword">from</span> cdas_dms_summary_result <span class="keyword">where</span> </span><br><span class="line">&quot;business_account_period&quot; <span class="operator">=</span> to_char( ADD_MONTHS(to_date(cdsr.business_account_period,<span class="string">&#x27;yyyy-mm&#x27;</span>)</span><br><span class="line">,<span class="number">-1</span>),<span class="string">&#x27;yyyy-mm&#x27;</span>) </span><br><span class="line"> <span class="keyword">and</span> company_code <span class="operator">=</span> cdsr.company_code) last_dimension_amount</span><br><span class="line"><span class="keyword">from</span> cdas_dms_summary_result cdsr</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">value</span>,meaning <span class="keyword">from</span> hzero.hpfm_lov_value  <span class="keyword">where</span> lov_code <span class="operator">=</span> <span class="string">&#x27;CDIM.WORK_COST&#x27;</span>) t1 <span class="keyword">on</span> t1.value <span class="operator">=</span> cdsr.&quot;business_task&quot;</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line"><span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">$&#123;if(len(p_company_code) <span class="operator">=</span> <span class="number">0</span>,&quot;&quot;,</span><br><span class="line">    &quot;and cdsr.company_code in (&#x27;&quot; <span class="operator">+</span> p_company_code <span class="operator">+</span> &quot;&#x27;)&quot;</span><br><span class="line">  )&#125;</span><br><span class="line">$&#123;if(len(p_company_code) <span class="operator">=</span> <span class="number">0</span>,&quot;&quot;,</span><br><span class="line">    &quot;and cdsr.business_account_period in (&#x27;&quot; <span class="operator">+</span> p_period_name <span class="operator">+</span> &quot;&#x27;)&quot;</span><br><span class="line">  )&#125;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cdsr.business_account_period</span><br></pre></td></tr></table></figure><p>2）新建好数据集之后，可在数据集管理面板查看取出的数据。</p><h4 id="2-4-标题设计"><a href="#2-4-标题设计" class="headerlink" title="2.4 标题设计"></a>2.4 标题设计</h4><p>按照自己的需求设计标题和表头，将数据集中的字段拖到对应要展示列的下方，如下所示</p><p><img src="/2023/02/11/fireReport/image-20230117174342841.png" alt="image-20230117174342841"></p><h4 id="2-5-设置父子格"><a href="#2-5-设置父子格" class="headerlink" title="2.5 设置父子格"></a>2.5 设置父子格</h4><p>​由于每个单元格均存在父子格关系，单元格会跟随父格扩展或计算，如下所示，在本例中，圈起来的字段是公司，是根据sql查询结果而变化的，属于动态字段，要设计其扩展方向向右扩展。</p><img src="/2023/02/11/fireReport/image-20230117175609792.png" alt="image-20230117175609792" style="zoom:50%;"><p>​然后设置子单元格的父格，使其可以随父格移动。</p><img src="/2023/02/11/fireReport/image-20230117175500072.png" alt="image-20230117175500072" style="zoom:50%;"><h4 id="2-6-设置查询参数"><a href="#2-6-设置查询参数" class="headerlink" title="2.6 设置查询参数"></a>2.6 设置查询参数</h4><p>​可以选择自己所需的控件（标签、下拉框或者多选下拉框），下面展示的是一个多选下拉框，主要设置：</p><p> 1、控件名称（p_company_code）这个参数将作为sql里面的引用变量。</p><p> 2、设置控件值为字符串，设置返回值类型为字符串，分隔符为’,’</p><p> 3、设置数据字典，可选择的数据字典类型有 4 种，其中包括「数据库表，数据查询，自定义，公式」，将分别对应不同应用场景。</p><p>ps ：使用如下方式传参</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;if(len(p_company_code) <span class="operator">=</span> <span class="number">0</span>,&quot;&quot;,</span><br><span class="line">    &quot;and cdsr.company_code in (&#x27;&quot; <span class="operator">+</span> p_company_code <span class="operator">+</span> &quot;&#x27;)&quot;</span><br><span class="line">  )&#125;</span><br></pre></td></tr></table></figure><img src="/2023/02/11/fireReport/image-20230117180637367.png" alt="image-20230117180637367" style="zoom:50%;"><img src="/2023/02/11/fireReport/image-20230117180715779.png" alt="image-20230117180715779" style="zoom: 50%;"><p>备注：如果预览列数展示不全分页了，可设置页面宽高为2000。</p>]]></content>
      
      
      
        <tags>
            
            <tag> fireReport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN入门学习</title>
      <link href="/2023/02/11/YARN%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/02/11/YARN%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Yarn运行机制流程图"><a href="#Yarn运行机制流程图" class="headerlink" title="Yarn运行机制流程图"></a>Yarn运行机制流程图</h1><p><img src="https://i.loli.net/2020/01/16/iV4PBsSf59gZnlb.png" alt="Yarn.png"></p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>（1）作业提交</p><ol><li>Client调用<code>job.waitForCompletion</code>方法，向整个集群提交MapReduce作业。</li><li>Client向RM申请一个作业id。</li><li>RM给Client返回该job资源的提交路径(<code>hdfs://.../.staging/</code>)和作业<code>application_id</code>。</li><li>Client在该路径提交jar包、切片信息和配置文件。</li><li>Client提交完资源后，向RM申请运行MrAppMaster。</li></ol><p>（2）作业初始化</p><ol><li>当RM收到Client的请求后，将该job添加到资源调度器中，将job初始化成task。</li><li>某一个空闲的NM领取到该Job。</li><li>在该NM中创建Container，并产生MRAppmaster(一个job创建一个)，它管理该job。</li><li>下载之前Client提交的资源到本地。</li></ol><p>（3）任务分配</p><ol><li>MRAppMaster向RM申请运行多个MapTask任务资源。</li><li>RM将运行MapTask任务分配给另外两个NodeManager，另外两个NodeManager分别领取任务并创建容器。</li></ol><p>（4）任务执行</p><ol><li>MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。</li><li>MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。</li><li>ReduceTask向MapTask获取相应分区的数据。</li><li>程序运行完毕后，MR会向RM申请注销自己。</li></ol><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><h2 id="4大组件"><a href="#4大组件" class="headerlink" title="4大组件"></a>4大组件</h2><ul><li><strong>ResourceManager</strong>：总的老大：处理客户端请求，监控NodeManager，启动或监控ApplicationMaster，资源的分配与调度</li><li><strong>NodeManager</strong>：单个节点的老大：管理单个节点的资源，处理来自ResourceManager、ApplicationMaster的命令</li><li><strong>ApplicationMaster</strong>：单个job的老大：负责数据切分，为应用程序申请资源并分配内部的任务，任务的监控与容错</li><li><strong>Container</strong>：资源抽象：如内存、cpu、磁盘、网络等</li></ul><h2 id="3种资源调度器"><a href="#3种资源调度器" class="headerlink" title="3种资源调度器"></a>3种资源调度器</h2><ul><li><strong>FIFO</strong>：先进先出</li><li><strong>Capacity Scheduler</strong>：多FIFO队列，会对同一用户提交资源进行限定，会把任务分配给更闲的队列。</li><li><strong>Fair Scheduler</strong>：多队列，按缺额排序，缺额大者优先执行</li></ul><h2 id="任务推测执行机制"><a href="#任务推测执行机制" class="headerlink" title="任务推测执行机制"></a>任务推测执行机制</h2><ul><li>问题：系统中有99%的Map任务都完成了，只有少数几个Map老是进度很慢，完不成。</li><li>办法：为拖后腿任务启动一个备份任务，同时运行。谁先运行完，则采用谁的结果。</li><li>前提：每个Task只能有一个备份任务，当前Job已完成的Task必须不小于0.05（5%）。</li><li>不适用：任务间存在严重的负载倾斜；特殊任务，比如任务向数据库中写数据。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
